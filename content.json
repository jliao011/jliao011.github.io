{"meta":{"title":"My Blog","subtitle":null,"description":null,"author":"Jiafeng Liao","url":"https://jliao011.github.io"},"pages":[{"title":"404 Not Found...","date":"2018-05-27T14:29:14.000Z","updated":"2018-05-27T14:29:14.000Z","comments":false,"path":"/404.html","permalink":"https://jliao011.github.io//404.html","excerpt":"","text":""},{"title":"About Me","date":"2018-05-27T14:00:43.000Z","updated":"2018-05-27T14:00:43.000Z","comments":false,"path":"about/index.html","permalink":"https://jliao011.github.io/about/index.html","excerpt":"","text":"I am a NEW M.S. CS GRAD (May 2018) from the University of Texas at Dallas and actively seeking a full-time SOFTWARE ENGINEER position. I am a QUICK learner and self-motivated. I have passion in learning new skills and technology. Skill Set:• Programming Languages: Java, Python, C/C++, Scala• Databases: SQL, JPQL, MySQL, PostgreSQL• Back-end Technologies: JDBC, JPA, PHP, RESTful web service• Front-end Technologies: HTML5/CSS3/JavaScript, jQuery, AJAX, BootStrap, JSON/XML• Tools &amp; OS: Eclipse, MatLab, MAMP, OpenCV, Mac/Linux Shell script, Windows• Frameworks: SLF4j/Log4j, Hadoop, Spark, Swing• Management: GIT, Maven Knowledge in Core Java concepts such as OOP concepts, Collections, Exception handling, Multi-Threading, Concurrency, JDBC, Socket, Swing. Basic knowledge and experience in Object Relational Mapping (ORM) related technology like Persistence Unit configuration, Entity Bean creation, Data Access Object (DAO) manipulation, DB connection using JPA Entity Manager and interaction using Java Persistence Query Language (JPQL). Hands-on experience in using debugging framework SLF4j/Log4j and writing Python script for large data/log files processing. Hands-on experience in using GIT for source code management. Knowledge and experience in using Relational Databases like MySQL, PostgreSQL and schema design. Hands-on experience and knowledge in Big Data technology such as Hadoop, Spark, Kafka, MapReduce. Familiar with RESTful web service, MVC pattern and hands-on experience in PHP. Experience in building and configuring Eclipse Maven projects. Hands-on experience in front end technology and data transfer techniques such as HTML/HTML5, CSS/CSS3, JavaScript, jQuery, BootStrap, AJAX, XML, JSON. Familiar with Machine Learning concepts such as SVM with slack/dual/kernel, Decision Tree, Random Forest, K-Mean, AdaBoost, Gaussian Mixture Models with EM, Bayesian Network, Neural Network, etc."},{"title":"Repositories","date":"2018-05-27T11:28:23.000Z","updated":"2018-05-27T10:07:31.000Z","comments":false,"path":"repository/index.html","permalink":"https://jliao011.github.io/repository/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-27T11:28:23.000Z","updated":"2018-05-27T09:17:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://jliao011.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-05-27T11:28:23.000Z","updated":"2018-05-27T09:16:46.000Z","comments":false,"path":"categories/index.html","permalink":"https://jliao011.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Another test","slug":"another-test","date":"2018-05-28T12:31:15.000Z","updated":"2018-05-27T12:41:09.000Z","comments":true,"path":"2018/05/28/another-test/","link":"","permalink":"https://jliao011.github.io/2018/05/28/another-test/","excerpt":"","text":"content 1test aaaaa","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jliao011.github.io/categories/leetcode/"}],"tags":[{"name":"testa","slug":"testa","permalink":"https://jliao011.github.io/tags/testa/"}]},{"title":"LeetCode Solutions","slug":"leet-code","date":"2018-05-27T07:31:15.000Z","updated":"2018-05-27T12:48:08.000Z","comments":true,"path":"2018/05/27/leet-code/","link":"","permalink":"https://jliao011.github.io/2018/05/27/leet-code/","excerpt":"","text":"1 ~ 200 1 ~ 100 101 ~ 200 #101-symmetric-tree-easy #102-level-order-traversal-medium #3-longest-substring-without-repeating-characters-medium #103-zigzag-level-order-traversal-medium #105-construct-tree-preorder-inorder-medium #106-construct-tree-inorder-postorder-medium #109-sorted-list-to-bst-medium #10-regular-expression-match-hard #110-balanced-binary-tree-easy #111-min-depth-of-binary-tree-easy #112-path-sum-easy #113-path-sum-ii-medium #114-flatten-binary-tree-to-linked-list-medium #115-distinct-subsequences-hard #116-populating-next-right-pointer-medium #117-populating-next-right-pointer-ii-medium #118-pascals-triangle-easy #29-divide-two-integers-medium #120-triangle-medium #22-generate-parentheses-medium #25-reverse-nodes-in-k-group-hard #130-surrounded-regions #32-longest-valid-parentheses-hard #33-search-in-rotated-sorted-array-medium #133-clone-graph-medium #136-single-number-easy #38-count-and-say-easy #41-first-missing-positive-hard #141-linked-list-cycle-easy #42-trapping-rain-water-hard #142-linked-list-cycle-ii-medium #146-lru-cache-hard #149-max-points-on-a-line-hard #151-reverse-words-in-a-string-medium #156-binary-tree-upside-down-medium #159-longest-substring-with-at-most-2-distince-characters-hard #160-intersection-of-two-linked-list-easy #61-rotate-list-medium #62-unique-paths-medium #63-unique-paths-ii-medium #163-missing-ranges-medium #64-minimum-path-sum-medium #165-compare-version-numbers-medium #66-plus-one-easy #67-add-binary-easy #169-majority-element-easy #70-climbing-stairs-easy #71-simplify-path-medium #72-edit-distance-hard #73-set-matrix-zeros-medium #74-search-a-2d-matrix-medium #75-sort-colors-medium #76-minimun-window-substring-hard #77-combinations-medium #78-subsets-medium #79-word-search-medium #80-remove-duplicates-from-sorted-array-ii-medium #81-search-in-rotated-sorted-array-ii-medium #82-remove-duplicates-from-sorted-list-ii-medium #83-remove-duplicates-from-sorted-list-easy #84-largest-rectangle-in-histogram-hard #86-partition-list-medium #87-scramble-string-hard #88-merge-sorted-array-easy #89-gray-code-medium #90-subsets-ii-medium #92-reverse-linked-list-ii-medium #93-restore-ip-addresses-medium #94-binary-tree-inorder-traversal-medium #97-interleaving-string-hard #98-validate-binary-search-tree-medium #100-same-tree-easy 201 ~ 400 201 ~ 300 301 ~ 400 #201-bitwise-and-of-numbers-range-medium #204-count-primes-easy #207-course-schedule-medium #210-course-schedule-ii-medium #313-supper-ugly-number-medium #217-contains-duplicate-easy #219-contains-duplicate-ii-easy #220-contains-duplicate-iii-medium #223-rectangle-area-medium #325-max-size-subarray-sum-equals-k-medium #228-summary-ranges-medium #229-majority-element-ii-medium #235-lca-of-a-bst-easy #335-self-crossing-hard #236-lca-of-a-binary-tree-medium #241-different-ways-to-add-parentheses-medium #243-shortest-word-distance-easy #244-shortest-word-distance-ii-medium #245-shortest-word-distance-iii-medium #347-top-k-frequent-elements-medium #248-strobogrammatic-number-iii-hard #350-intersection-of-two-arrays-easy #253-meeting-rooms-ii-medium #263-ugly-number-easy #268-missing-number-easy #271-encode-and-decode-strings-medium #371-sum-of-two-integers-easy #272-closest-bst-value-ii-hard #373-find-k-pairs-with-smallest-sum-medium #279-perfect-squares-medium #384-shuffle-an-array-medium #285-inorder-successor-in-bst-medium #287-find-duplicate-number-medium #388-longest-absolute-file-path-medium #297-encode-and-decode-binary-tree-hard 401 ~ 600 401 ~ 500 501 ~ 600 #406-queue-reconstruction-by-height-medium #516-longest-palindromic-subsequence-medium #419-battleships-in-a-board-medium #443-string-compression-easy #448-find-all-disappeared-number-easy #560-subarray-sum-equals-k-medium #463-island-perimeter-easy #476-number-complement-easy #500-keyboard-row-easy 601 ~ 800 601 ~ 700 701 ~ 800 #604-compressed-string-iterator-easy #625-minimun-factorization-medium #632-smallest-range-hard 801 ~ 1000 801 ~ 900 901 ~ 1000 #809-expressive-word-medium #814-binary-tree-pruning-medium #817-linked-list-components-medium #3-longest-substring-without-repeating-characters-mediumGiven a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 12345678910111213public static int lengthOfLongestSubstringDistinct(String s) &#123; int maxLen = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // save character, index for (int head = 0, tail = 0; tail &lt; s.length(); tail++) &#123; // if duplicated, move head if (map.containsKey(s.charAt(tail))) // head cannot move back e.g. abbbbbba head = Math.max(head, map.get(s.charAt(tail)) + 1); map.put(s.charAt(tail), tail); maxLen = Math.max(maxLen, tail - head + 1); &#125; return maxLen;&#125; 12345678910public static int lengthOfLongestSubstringDistinctOPT(String s) &#123; int maxLen = 0; int[] bin = new int[26]; // case only alphabet, save index for (int head = 0, tail = 0; tail &lt; s.length(); tail++) &#123; head = Math.max(head, bin[s.charAt(tail) - 'a']); // maybe 0 bin[s.charAt(tail) - 'a'] = tail + 1; // save same's next maxLen = Math.max(maxLen, tail - head + 1); &#125; return maxLen;&#125; #10-regular-expression-match-hardGiven an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;. 12&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. 123456789101112131415161718192021222324252627282930313233 public boolean isMatch(String s, String p) &#123;if (s == null || p == null) return false;boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];dp[0][0] = true;// initial the first linefor (int j = 1; j &lt;= p.length(); j++) &#123; if (p.charAt(j - 1) == '*') dp[0][j] = dp[0][j - 2];&#125;// dp conditions:// (1) p.char == . || p.char == s.char// (2) p.char == *:// 1. treat as 0 : check i, j-2// 2. if p[j-1] == s.char || .: check i-1,jfor (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 1; j &lt;= p.length(); j++) &#123; if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) dp[i][j] = dp[i - 1][j - 1]; else if (p.charAt(j - 1) == '*') &#123; // check * is 0 dp[i][j] = dp[i][j - 2]; if (dp[i][j]) continue; // if p.prev equal or . if (p.charAt(j - 2) == s.charAt(i - 1) || p.charAt(j - 2) == '.') &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125;&#125;return dp[s.length()][p.length()]; &#125; #22-generate-parentheses-mediumGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 12345678910111213141516171819202122232425public List&lt;String&gt; generateParenthesis(int n) &#123; // utilizing backtracking List&lt;String&gt; result = new ArrayList&lt;&gt;(); backtrack(result,new StringBuilder(),0,0,n); return result;&#125;private void backtrack(List&lt;String&gt; result,StringBuilder temp,int left,int right,int n)&#123; if(temp.length() == n * 2)&#123; result.add(temp.toString()); return; &#125; int len = temp.length(); // append ( if(left &lt; n)&#123; temp.append('('); backtrack(result,temp,left+1,right,n); temp.setLength(len); &#125; // append ) if(right &lt; left)&#123; temp.append(')'); backtrack(result,temp,left,right+1,n); temp.setLength(len); &#125;&#125; #25-reverse-nodes-in-k-group-hardGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 12345678910111213141516171819202122232425262728293031public ListNode reverseKGroup(ListNode head, int k) &#123; // constant memory, cannot use recursion (dummy) if(head==null || k==1) return head; ListNode dummy = new ListNode(0), prev = dummy, tail = dummy, next = null, curr = null; prev.next = head; while(true)&#123; // find group first, k th node int count = 0; while(count&lt;k &amp;&amp; tail!=null)&#123; count ++; tail = tail.next; &#125; // less than k break if(tail == null) break; // reverse prev to curr // D -&gt; 1 -&gt; 2 -&gt; 3(T) -&gt; N // move 1 after 3: D 2 3 1 N head = prev.next; for(int i=0;i&lt;k-1;i++)&#123; next = prev.next; // save 1 prev.next = next.next; // assign head next.next = tail.next; // assign tail tail.next = next; &#125; prev = head; tail = head; &#125; return dummy.next;&#125; #29-divide-two-integers-mediumGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. 12345678910111213141516171819202122232425262728public int divide(int dividend, int divisor) &#123; if(divisor == 0) return Integer.MAX_VALUE; if(dividend == 0) return 0; if(divisor == 1) return dividend; if(divisor == -1) return dividend == Integer.MIN_VALUE? Integer.MAX_VALUE : -dividend; int sign = 1; if(dividend &lt; 0 ^ divisor &lt;0) sign = -1; long ldividend = Math.abs((long)dividend); // notice long inside long ldivisor = Math.abs((long)divisor); int result = 0; while(ldividend &gt;= ldivisor)&#123; long temp = ldivisor, multi = 1; while(temp &lt;&lt; 1 &lt; ldividend)&#123; temp &lt;&lt;= 1; multi &lt;&lt;= 1; &#125; ldividend -= temp; result += multi; &#125; return sign==1? result : -result;&#125; #32-longest-valid-parentheses-hardGiven a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. For &quot;(()&quot;, the longest valid parentheses substring is &quot;()&quot;, which has length = 2. Another example is &quot;)()())&quot;, where the longest valid parentheses substring is &quot;()()&quot;, which has length = 4. 1234567891011121314151617181920public int longestValidParentheses(String s) &#123; if(s==null || s.length()==0) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(-1); // for first pair if () int maxLen = 0; for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i) == '(') stack.push(i); else&#123; stack.pop(); if(stack.isEmpty())&#123; stack.push(i); // first not valid &#125;else&#123; maxLen = Math.max(maxLen,i-stack.peek()); &#125; &#125; &#125; return maxLen;&#125; #33-search-in-rotated-sorted-array-mediumSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1: 12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2: 12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 1234567891011121314151617181920212223242526public int search(int[] nums, int target) &#123; if(nums==null || nums.length==0) return -1; int left = 0, right = nums.length - 1; while(left &lt;= right)&#123; int mid = left + (right-left)/2; if(nums[mid] == target) return mid; // left half not rotate if(nums[left] &lt;= nums[mid])&#123; // mid in not rotate part if(nums[left]&lt;=target &amp;&amp; target&lt;nums[mid]) right = mid - 1; // mid in rotate part else left = mid + 1; // right half not rotate &#125;else&#123; // mid in not rotate part if(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right]) left = mid + 1; // mid in rotate part else right = mid -1; &#125; &#125; return -1;&#125; 36. Valid Sudoku (medium)Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character &#39;.&#39;. A partially filled sudoku which is valid. Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. 123456789101112131415161718192021222324252627public boolean isValidSudoku(char[][] board) &#123; if(board==null || board.length!=9 || board[0].length!=9) return false; Set&lt;Character&gt; rowSet = new HashSet&lt;&gt;(); Set&lt;Character&gt; colSet = new HashSet&lt;&gt;(); Set&lt;Character&gt; cubSet = new HashSet&lt;&gt;(); // check row, col, cube for(int row=0;row&lt;9;row++)&#123; rowSet.clear(); colSet.clear(); cubSet.clear(); for(int col=0;col&lt;9;col++)&#123; // left to right if(board[row][col]!='.' &amp;&amp; !rowSet.add(board[row][col])) return false; // up to down if(board[col][row]!='.' &amp;&amp; !colSet.add(board[col][row])) return false; // map to a cube int cubeRow = 3 * (row / 3) + col / 3; int cubeCol = 3 * (row % 3) + col % 3; if(board[cubeRow][cubeCol]!='.' &amp;&amp; !cubSet.add(board[cubeRow][cubeCol])) return false; &#125; &#125; return true;&#125; 37. Sudoku Solver (hard)Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character &#39;.&#39;. You may assume that there will be only one unique solution. A sudoku puzzle… …and its solution numbers marked in red. 123456789101112131415161718192021222324252627282930313233public void solveSudoku(char[][] board) &#123; if(board==null || board.length!=9 || board[0].length!=9) return; solver(board);&#125;private boolean solver(char[][] board)&#123; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; if(board[i][j] != '.') continue; for(char c='1';c&lt;='9';c++)&#123; if(isValid(board,i,j,c))&#123; board[i][j] = c; if(solver(board)) return true; board[i][j] = '.'; &#125; &#125; return false; &#125; &#125; return true;&#125;private boolean isValid(char[][] board,int i,int j,char c)&#123; for(int k=0;k&lt;9;k++)&#123; if(board[i][k] == c) return false; if(board[k][j] == c) return false; int row = 3 * (i / 3) + k / 3; int col = 3 * (j / 3) + k % 3; if(board[row][col] == c) return false; &#125; return true;&#125; #38-count-and-say-easyThe count-and-say sequence is the sequence of integers with the first five terms as following: 123451. 12. 113. 214. 12115. 111221 1 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211. Given an integer n, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string. Example 1: 12Input: 1Output: &quot;1&quot; Example 2: 12Input: 4Output: &quot;1211&quot; 123456789101112131415161718192021public String countAndSay(int n) &#123; if(n == 1) return \"1\"; String result = \"1\"; for(int i=2;i&lt;=n;i++)&#123; int idx = 0; StringBuilder sb = new StringBuilder(); while(idx &lt; result.length())&#123; char curr = result.charAt(idx); int count = 1; while(idx&lt;result.length()-1 &amp;&amp; result.charAt(idx)==result.charAt(idx+1))&#123; idx ++; count ++; &#125; sb.append(count).append(curr); idx ++; &#125; result = sb.toString(); &#125; return result;&#125; 39. Combination Sum (medium)Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: 1234[ [7], [2, 2, 3]] 12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; // use backtracking List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,candidates,new ArrayList&lt;&gt;(),target,0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] candidates,List&lt;Integer&gt; temp,int target,int idx)&#123; if(target &lt; 0) return; if(target == 0)&#123; // should build a new list result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=idx;i&lt;candidates.length;i++)&#123; temp.add(candidates[i]); // item repeatly used, should call i backtrack(result,candidates,temp,target-candidates[i],i); // remove after recursion temp.remove(temp.size()-1); &#125;&#125; 40. Combination Sum II (medium)Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is: 123456[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; // backtracking, duplicate element, use once List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(candidates); // to skip duplicate backtrack(result,candidates,new ArrayList&lt;&gt;(),target,0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] candidates,List&lt;Integer&gt; temp,int target,int idx)&#123; if(target &lt; 0) return; if(target == 0)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=idx;i&lt;candidates.length;i++)&#123; // here i &gt; idx not 0. to avoid duplicate // since same adjacent same element, so need sorting if(i&gt;idx &amp;&amp; candidates[i]==candidates[i-1]) continue; temp.add(candidates[i]); backtrack(result,candidates,temp,target-candidates[i],i+1); temp.remove(temp.size()-1); &#125;&#125; #41-first-missing-positive-hardGiven an unsorted integer array, find the first missing positive integer. For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 1234567891011121314151617public int firstMissingPositive(int[] nums) &#123; // swap pos num to corresponding index for(int i=0;i&lt;nums.length;i++)&#123; // use nums[i]-1 as index, cannot have cycle while(nums[i]&gt;0 &amp;&amp; nums[i]&lt;=nums.length &amp;&amp; nums[i]!=nums[nums[i]-1])&#123; int temp = nums[nums[i]-1]; nums[nums[i]-1] = nums[i]; nums[i] = temp; &#125; &#125; // traverse find nums[i]-1 != i for(int i=0;i&lt;nums.length;i++) if(nums[i] != i + 1) return i + 1; // beyond the bound return nums.length + 1;&#125; #42-trapping-rain-water-hardGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example,Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. DP approach O(n) &amp; O(n) 123456789101112131415161718192021222324public int trap(int[] height) &#123; // use dp 3 pass if(height.length == 0) return 0; // first pass find left max int[] left = new int[height.length]; int leftMax = height[0]; for(int i=0;i&lt;height.length;i++)&#123; leftMax = Math.max(leftMax,height[i]); left[i] = leftMax; &#125; // second pass find right max int[] right = new int[height.length]; int rightMax = height[height.length-1]; for(int i=height.length-1;i&gt;=0;i--)&#123; rightMax = Math.max(rightMax,height[i]); right[i] = rightMax; &#125; // third pass find water each idx int result = 0; for(int i=0;i&lt;height.length;i++) result += Math.min(left[i],right[i]) - height[i]; return result;&#125; Stack approach O(n) &amp; O(n) 12345678910111213141516171819202122public int trap(int[] height) &#123; // stack approaching if(height.length == 0) return 0; // use stack to save index Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int result = 0; for(int i=0;i&lt;height.length;i++)&#123; // if larger than prev while(!stack.isEmpty() &amp;&amp; height[i]&gt;height[stack.peek()])&#123; int currIdx = stack.pop(); if(stack.isEmpty()) break; // compare prev height and i height int h = Math.min(height[stack.peek()],height[i]) - height[currIdx]; int w = i - stack.peek() - 1; result += h * w; &#125; stack.push(i); &#125; return result;&#125; Two pointer approach O(n) &amp; O(1) 12345678910111213141516171819202122232425public int trap(int[] height) &#123; // two pointer if(height.length == 0) return 0; // left &amp; right max, int left = 0, right = height.length - 1; int leftMax = height[left], rightMax = height[right]; int result = 0; // stop when left&gt;right, should be &lt;= while(left &lt;= right)&#123; // case left ++ if(leftMax &lt; rightMax)&#123; if(height[left] &lt; leftMax) result += leftMax - height[left]; leftMax = Math.max(leftMax,height[left]); left ++; &#125;else&#123; // case right -- if(height[right] &lt; rightMax) result += rightMax - height[right]; rightMax = Math.max(rightMax,height[right]); right --; &#125; &#125; return result;&#125; 43. Multiply Strings (medium)Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2. Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. 1234567891011121314151617181920212223242526272829public String multiply(String num1, String num2) &#123; if(num1==null || num1.length()==0) return \"\"; if(num2==null || num2.length()==0) return \"\"; if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\"; int m = num1.length(), n = num2.length(); // num1 * num2 max len = m + n int[] result = new int[m+n]; // i bit * j bit head is at i+j for(int i=m-1;i&gt;=0;i--)&#123; for(int j=n-1;j&gt;=0;j--)&#123; int n1 = num1.charAt(i) - '0'; int n2 = num2.charAt(j) - '0'; int sum = n1 * n2 + result[i+j+1]; // one digit result[i+j+1] = sum % 10; // ten digit result[i+j] += sum / 10; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;result.length;i++)&#123; if(!(sb.length()==0 &amp;&amp; result[i]==0)) sb.append(result[i]); &#125; return sb.toString();&#125; 44. Wildcard Matching (hard)Implement wildcard pattern matching with support for &#39;?&#39; and &#39;*&#39;. 12345678910111213141516&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;*&quot;) → trueisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;ab&quot;, &quot;?*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false Similar method to regular expression match, DP approach 123456789101112131415161718192021222324public boolean isMatch(String s, String p) &#123; if(s==null || p==null) return false; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; // go through first row, * could match \"\" // first col is false, dont match \"\" for(int j=1;j&lt;=p.length();j++) if(p.charAt(j-1) == '*') dp[0][j] = dp[0][j-1]; // case 1: p.char==(s.char, ?) =&gt; dp[i][j] = dp[i-1][j-1] // case 2: p.char==* =&gt; * is \"\" dp[i][j] = dp[i][j-1] // =&gt; * is not \"\" dp[i][j] = dp[i-1][j]; for(int i=1;i&lt;=s.length();i++)&#123; for(int j=1;j&lt;=p.length();j++)&#123; if(p.charAt(j-1)==s.charAt(i-1) || p.charAt(j-1)=='?') dp[i][j] = dp[i-1][j-1]; else if(p.charAt(j-1) == '*') // * is sequence and * is blank dp[i][j] = dp[i-1][j] || dp[i][j-1]; &#125; &#125; return dp[s.length()][p.length()];&#125; 46. Permutations (distinct)(medium)Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations: 12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Backtracking add to temp 1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // use backtracking, remember to use visited List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,nums,new ArrayList&lt;&gt;(),new boolean[nums.length]); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,List&lt;Integer&gt; temp,boolean[] visited)&#123; if(temp.size() == nums.length)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; // check visited, i from 0 to n for(int i=0;i&lt;nums.length;i++)&#123; if(visited[i]) continue; visited[i] = true; temp.add(nums[i]); backtrack(result,nums,temp,visited); // reset when return to here visited[i] = false; temp.remove(temp.size()-1); &#125;&#125; Backtracking swap (quicker) 1234567891011121314151617181920212223242526public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,nums,0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,int idx)&#123; if(idx == nums.length)&#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for(int num: nums) temp.add(num); result.add(temp); return; &#125; for(int i=idx;i&lt;nums.length;i++)&#123; swap(nums,idx,i); // swap every position with idx backtrack(result,nums,idx+1); // swap back when return here swap(nums,idx,i); &#125;&#125;private void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; 47. Permutations II (duplicates)(medium)Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations: 12345[ [1,1,2], [1,2,1], [2,1,1]] 1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); // need sorting to remove duplicate Arrays.sort(nums); backtrack(result,nums,new ArrayList&lt;&gt;(),new boolean[nums.length]); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,List&lt;Integer&gt; temp,boolean[] used)&#123; if(temp.size() == nums.length)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; // both !used[i-1] and used[i-1] work if(used[i] || i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!used[i-1]) continue; used[i] = true; temp.add(nums[i]); backtrack(result,nums,temp,used); used[i] = false; temp.remove(temp.size()-1); &#125;&#125; 48. Rotate Image (medium)Rotate the image by 90 degrees (clockwise). Note:You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. clockwise: upside down first, then symmetry anti-clockwise: left right first, then symmetry 1234567891011121314151617181920212223242526public void rotate(int[][] matrix) &#123; if(matrix.length==0 || matrix[0].length==0) return; if(matrix.length != matrix[0].length) return; // upside down int n = matrix.length; for(int col=0;col&lt;n;col++)&#123; int up = 0, down = n-1; while(up &lt; down)&#123; int temp = matrix[up][col]; matrix[up][col] = matrix[down][col]; matrix[down][col] = temp; up ++; down --; &#125; &#125; // symmetry for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125;&#125; 49. Group Anagrams (medium)Given an array of strings, group anagrams together. For example, given: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Return: 12345[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lower-case. HashMap, return 123456789101112131415161718public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; // using hashtable // key is sorted str List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); if(strs.length == 0) return result; for(String str: strs)&#123; char[] c = str.toCharArray(); Arrays.sort(c); String key = new String(c); if(!map.containsKey(key)) map.put(key,new ArrayList&lt;&gt;()); map.get(key).add(str); &#125; // map.keySet() map.values() return new ArrayList&lt;&gt;(map.values());&#125; 50. Pow(x,n) (medium)recursion 12345678910111213141516public double myPow(double x, int n) &#123; if(n == 0) return 1; if(n &lt; 0)&#123; // deal with int.min // +2 could remain even or odd if(n == Integer.MIN_VALUE) n+=2; n = -n; x = 1 / x; &#125; if(n % 2 == 0) return myPow(x*x,n/2); else return x * myPow(x*x,n/2);&#125; iteration 1234567891011121314151617181920public double myPow(double x, int n) &#123; if(n == 0) return 1; if(n &lt; 0)&#123; // deal with int.min // +2 could remain even or odd if(n == Integer.MIN_VALUE) n+=2; n = -n; x = 1 / x; &#125; double result = 1; while(n &gt; 0)&#123; if((n &amp; 1) == 1) // n is odd result *= x; x *= x; n &gt;&gt;= 1; &#125; return result;&#125; 51. N-Queens (hard)backtracking The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively. For example,There exist two distinct solutions to the 4-queens puzzle: 1234567891011[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); // construct blank board char[][] board = new char[n][n]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) board[i][j] = '.'; // backtracking backtrack(result,board,0); return result; &#125;private void backtrack(List&lt;List&lt;String&gt;&gt; result,char[][] board,int col)&#123; if(col == board.length)&#123; result.add(build(board)); return; &#125; // for each row, try each col, only one loop need for(int row=0;row&lt;board.length;row++)&#123; if(isValid(board,row,col))&#123; board[row][col] = 'Q'; backtrack(result,board,col+1); board[row][col] = '.'; &#125; &#125;&#125;private boolean isValid(char[][] board,int row,int col)&#123; int n = board.length; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(board[i][j] == '.') continue; // in same row, same col, same diagnal if(i==row || j==col || Math.abs(i-row)==Math.abs(j-col)) return false; &#125; &#125; return true;&#125;private List&lt;String&gt; build(char[][] board)&#123; // build board to a result instance int n = board.length; List&lt;String&gt; rows = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++) rows.add(String.valueOf(board[i])); return rows;&#125; 52. N-Queens II (hard)Now, instead outputting board configurations, return the total number of distinct solutions. 123456789101112131415161718192021222324252627282930313233343536public int totalNQueens(int n) &#123; // only check valid cases // use 4 boolean arrays to mark: // 1. traverse each row, no check same row // 2. same col occupied // 3. 45 diagnal occupied: y=x+b =&gt; b=y-x constant // 4. 135 diagnal occupied y=-x+b =&gt; b=y+x constant // board has 2n-1 diagnals each case int[] result = new int[1]; boolean[] cols = new boolean[n]; // for col boolean[] diag1 = new boolean[2*n-1]; // for y-x boolean[] diag2 = new boolean[2*n-1]; // for y+x backtrack(result,0,cols,diag1,diag2); return result[0]; &#125;private void backtrack(int[] result,int col,boolean[] cols,boolean[] diag1,boolean[] diag2)&#123; // traverse along rows, int n = cols.length; if(col == n)&#123; result[0]++; return; &#125; for(int row=0;row&lt;n;row++)&#123; int idx1 = col - row + n - 1; // n-1 offset int idx2 = col + row; if(cols[row] || diag1[idx1] || diag2[idx2]) continue; cols[row] = true; diag1[idx1] = true; diag2[idx2] = true; backtrack(result,col+1,cols,diag1,diag2); cols[row] = false; diag1[idx1] = false; diag2[idx2] = false; &#125;&#125; 53. Maximum subarray (easy)Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. 123456789public int maxSubArray(int[] nums) &#123; // save currSum and maxSum int currSum = 0, maxSum = nums[0]; for(int num: nums)&#123; currSum = Math.max(num,num+currSum); maxSum = Math.max(maxSum,currSum); &#125; return maxSum;&#125; 54. Spiral Matrix (medium)Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example,Given the following matrix: 12345[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] You should return [1,2,3,6,9,8,7,4,5]. 123456789101112131415161718192021222324252627public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(matrix.length==0 || matrix[0].length==0) return result; int r1 = 0, r2 = matrix.length-1; int c1 = 0, c2 = matrix[0].length-1; while(r1&lt;=r2 &amp;&amp; c1&lt;=c2)&#123; // add all r1 for(int c=c1;c&lt;=c2;c++) result.add(matrix[r1][c]); // add all c2 for(int r=r1+1;r&lt;=r2;r++) result.add(matrix[r][c2]); // if las row or col break if(r1==r2 || c1==c2) break; // add all r2 for(int c=c2-1;c&gt;=c1+1;c--) result.add(matrix[r2][c]); // add all c1 for(int r=r2;r&gt;=r1+1;r--) result.add(matrix[r][c1]); // update r1++;r2--;c1++;c2--; &#125; return result;&#125; 55. Jump Game (medium)Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example:A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. end to head, check whether it’s a good point 1234567891011public boolean canJump(int[] nums) &#123; if(nums.length == 0) return false; // last index that is a good point int last = nums.length - 1; for(int i=last-1;i&gt;=0;i--)&#123; if(i + nums[i] &gt;= last) last = i; &#125; return last == 0;&#125; 56. Merge Intervals (medium)Given a collection of intervals, merge all overlapping intervals. For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18]. 12345678910111213141516171819202122232425/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); if(intervals==null || intervals.size()==0) return result; Collections.sort(intervals,(o1,o2)-&gt;o1.start-o2.start); Interval prev = null; for(Interval curr : intervals)&#123; // result blank or no overlapping if(prev==null || curr.start&gt;prev.end)&#123; prev = curr; result.add(prev); &#125;else // have overlapping prev.end = Math.max(prev.end,curr.end); &#125; return result;&#125; 57. Insert Interval (hard)Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1:Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9]. Example 2:Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 12345678910111213141516171819202122232425262728293031323334/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); // assume already sorted // Collections.sort(intervals,(o1,o2)-&gt;o1.start-o2.start); int idx = 0; // add intervals before newIntervals first, no overlapping while(idx&lt;intervals.size() &amp;&amp; intervals.get(idx).end&lt;newInterval.start)&#123; result.add(intervals.get(idx)); idx++; &#125; // merge overlapping intervals, curr.end &gt;= new.start while(idx&lt;intervals.size() &amp;&amp; intervals.get(idx).start&lt;=newInterval.end)&#123; Interval curr = intervals.get(idx); newInterval.start = Math.min(newInterval.start,curr.start); newInterval.end = Math.max(newInterval.end,curr.end); idx++; &#125; result.add(newInterval); // add intervals after newIntervals, no overlapping while(idx&lt;intervals.size())&#123; result.add(intervals.get(idx)); idx++; &#125; return result;&#125; 58. Length of Last Word (easy)Given a string s consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: 12Input: &quot;Hello World&quot;Output: 5 123456789public int lengthOfLastWord(String s) &#123; int tail = s.length()-1; while(tail&gt;=0 &amp;&amp; s.charAt(tail)==' ') tail--; int head = tail; while(head&gt;=0 &amp;&amp; s.charAt(head)!=' ') head--; return tail - head;&#125; 59. Spiral Matrix II (medium)Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. For example,Given n = 3, You should return the following matrix: 12345[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 1234567891011121314151617181920public int[][] generateMatrix(int n) &#123; int[][] result = new int[n][n]; int num = 1; int r1 = 0, r2 = n - 1; int c1 = 0, c2 = n - 1; while(r1&lt;=r2 &amp;&amp; c1&lt;=c2)&#123; for(int c=c1;c&lt;=c2;c++) result[r1][c] = num++; for(int r=r1+1;r&lt;=r2;r++) result[r][c2] = num++; if(r1==r2 || c1==c2) break; for(int c=c2-1;c&gt;=c1+1;c--) result[r2][c] = num++; for(int r=r2;r&gt;=r1+1;r--) result[r][c1] = num++; r1++;r2--;c1++;c2--; &#125; return result;&#125; 61. Rotate List (medium)Given a list, rotate the list to the right by k places, where k is non-negative. Example: 12Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public ListNode rotateRight(ListNode head, int k) &#123; // notice corner case if(head == null || head.next == null) return head; ListNode dummy = new ListNode(0), fast = dummy; dummy.next = head; // find length first, and end node int len = 0; while(fast.next != null)&#123; len ++; fast = fast.next; &#125; // find node before new head // k may larger than len =&gt; % ListNode slow = dummy; for(int i=0;i&lt;len-k%len;i++) slow = slow.next; // rotation order, fast.next = dummy.next; dummy.next = slow.next; slow.next = null; return dummy.next;&#125; 62. Unique Paths (medium)A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? Note: m and n will be at most 100. 1234567891011121314public int uniquePaths(int m, int n) &#123; // time O(mn), space O(min(m,n)) if(m &lt;= 0 || n &lt;=0) return 0; // use 1D dp int[] dp = new int[n]; Arrays.fill(dp,1); for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; dp[j] += dp[j-1]; &#125; &#125; return dp[n-1];&#125; 63. Unique Paths II (medium)Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example, There is one obstacle in the middle of a 3x3 grid as illustrated below. 12345[ [0,0,0], [0,1,0], [0,0,0]] The total number of unique paths is 2. 12345678910111213141516171819public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; // similar to previous, use 1D DP if(obstacleGrid==null || obstacleGrid.length==0 || obstacleGrid[0].length==0) return 0; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[] dp = new int[n]; dp[0] = 1; // init head as 0 for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; // obstacle, curr count reset 0 if(obstacleGrid[i][j] == 1) dp[j] = 0; // accumulate when j &gt; 0 else if(j &gt; 0) dp[j] += dp[j-1]; &#125; &#125; return dp[n-1];&#125; 64. Minimum Path Sum (medium)Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example 1: 123[[1,3,1], [1,5,1], [4,2,1]] Given the above grid map, return 17 . Because the path 1→3→1→1→1 minimizes the sum. 12345678910111213141516public int minPathSum(int[][] grid) &#123; if(grid==null || grid.length==0 || grid[0].length==0) return 0; int m = grid.length, n = grid[0].length; // go through first row for(int j=1;j&lt;n;j++) grid[0][j] += grid[0][j-1]; // go through first col for(int i=1;i&lt;m;i++) grid[i][0] += grid[i-1][0]; // go through other for(int i=1;i&lt;m;i++) for(int j=1;j&lt;n;j++) grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]); return grid[m-1][n-1];&#125; 66. Plus One (easy)Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. 123456789101112131415161718192021public int[] plusOne(int[] digits) &#123; if(digits==null || digits.length==0) return new int[0]; // if 9, continue check previous, // if not 9, +1 will stop for(int i=digits.length-1;i&gt;=0;i--)&#123; if(digits[i] == 9) digits[i] = 0; else&#123; digits[i] ++; break; &#125; &#125; // if all 0 if(digits[0] == 0)&#123; int[] result = new int[digits.length+1]; result[0] = 1; return result; &#125; return digits;&#125; 67-add-binary-easyGiven two binary strings, return their sum (also a binary string). For example,a = &quot;11&quot;b = &quot;1&quot;Return &quot;100&quot;. 12345678910111213141516171819public String addBinary(String a, String b) &#123; if(a == null || b == null) return \"\"; // use string builder and reverse StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() - 1; int sum = 0; while(i &gt;= 0 || j &gt;= 0)&#123; if(i &gt;= 0) sum += a.charAt(i--) - '0'; if(j &gt;= 0) sum += b.charAt(j--) - '0'; sb.append(sum % 2); sum /= 2; &#125; if(sum != 0) sb.append(sum); return sb.reverse().toString(); &#125; 69. int sqrt(x) (easy)binary search 12345678910111213141516public int mySqrt(int x) &#123; if(x &lt;= 1) return x; int left = 1, right = x; while(true)&#123; int mid = left + (right-left)/2; if(mid &gt; x / mid) right = mid - 1; else&#123; // mid^2 &lt; x but mid+1 ^2 &gt; x if(mid+1 &gt; x/(mid+1)) return mid; left = mid + 1; &#125; &#125;&#125; #70-climbing-stairs-easyYou are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. **Example 2: 1234567Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step basic: Assume T(n-1) = O(2`n-1)`, therefore T(n) = T(n-1) + T(n-2) + O(1) which is equal to T(n) = O(2`n-1) + O(2n-2) + O(1) = O(2n)` 123456789101112public int climbStairs(int n) &#123; // n step is count n-1 step + count n-2 step if(n &lt;= 2) return n; int first = 1, second = 2, curr = 0; for(int i=3;i&lt;=n;i++)&#123; curr = first + second; first = second; second = curr; &#125; return curr;&#125; add memo top down: 1234567891011121314public int climbStairs(int n) &#123; // 0:1, 1:1, 2:2, 3:3, 4:5, 5:8 if(n &lt;= 1) return 1; int[] memo = new int[n+1]; return helper(n,memo);&#125;private int helper(int n,int[] memo)&#123; if(n &lt;= 1) return 1; if(memo[n] != 0) return memo[n]; memo[n] = helper(n-1,memo) + helper(n-2,memo); return memo[n];&#125; top down dp iteration space O(n) 12345678public int climbStairs(int n) &#123; int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for(int i=2; i&lt;=n; i++) dp[i] = dp[i-1] + dp[i-2]; return dp[n];&#125; iteration O(1) 1234567891011public int climbStairs(int n) &#123; if(n &lt;= 1) return 1; int first = 1, second = 1, result = 0; for(int i=2; i&lt;=n; i++)&#123; result = first + second; first = second; second = result; &#125; return result;&#125; #71-simplify-path-mediumGiven an absolute path for a file (Unix-style), simplify it. For example,path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot; Did you consider the case where path = &quot;/../&quot;?In this case, you should return &quot;/&quot;. Another corner case is the path might contain multiple slashes &#39;/&#39; together, such as &quot;/home//foo/&quot;.In this case, you should ignore redundant slashes and return &quot;/home/foo&quot;. 1234567891011121314151617181920212223242526272829public String simplifyPath(String path) &#123; // use stack .. pop else push if(path == null || path.length() == 0) return \"\"; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for(String s : path.split(\"/\"))&#123; // case .(curr folder) continue if(s.equals(\".\")) continue; // case .. prev folder else if(s.equals(\"..\"))&#123; if(!stack.isEmpty()) stack.pop(); // case name dir, not empty, not /// &#125;else if(!s.isEmpty())&#123; stack.push(s); &#125; &#125; // case / if(stack.isEmpty()) return \"/\"; // pop and build result StringBuilder sb = new StringBuilder(); // build list from stack List&lt;String&gt; list = new ArrayList&lt;&gt;(stack); for(String s : list) sb.append(\"/\").append(s); return sb.toString();&#125; #72-edit-distance-hardGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: 123456Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;) Example 2: 12345678Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;) 123456789101112131415161718192021222324252627282930public int minDistance(String word1, String word2) &#123; // similar regex if(word1==null || word2==null) return 0; // row word1, col word2 int[][] dp = new int[word2.length()+1][word1.length()+1]; // init first row: word1 to \"\" for(int j=0; j&lt;word1.length(); j++) dp[0][j+1] = dp[0][j] + 1; // init first col: \"\" to word2 for(int i=0; i&lt;word2.length(); i++) dp[i+1][0] = dp[i][0] + 1; // the other for(int i=0; i&lt;word2.length(); i++)&#123; for(int j=0; j&lt;word1.length(); j++)&#123; // char1 != char2: // 1. insert: dp[i][j] = dp[i-1][j]+1; // 2. replace: dp[i][j] = dp[i-1][j-1]+1; // 3. delete: dp[i][j] = dp[i][j-1]+1; if(word2.charAt(i) != word1.charAt(j))&#123; dp[i+1][j+1] = 1 + Math.min(dp[i][j], Math.min(dp[i][j+1], dp[i+1][j])); &#125;else // case char1 == char2 dp[i+1][j+1] = dp[i][j]; &#125; &#125; return dp[word2.length()][word1.length()];&#125; #73-set-matrix-zeros-mediumGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Did you use extra space?A straight forward solution using O(m**n) space is probably a bad idea.A simple improvement uses O(m + n) space, but still not the best solution.Could you devise a constant space solution? 123456789101112131415161718192021222324252627282930313233343536373839public void setZeroes(int[][] matrix) &#123; // set all leading row &amp; col to zeros if(matrix.length==0 || matrix[0].length==0) return; boolean firstRow = false, firstCol = false; int row = matrix.length, col = matrix[0].length; // check first col for(int i=0;i&lt;row;i++) if(matrix[i][0] == 0) firstCol = true; // check first row for(int j=0;j&lt;col;j++) if(matrix[0][j] == 0) firstRow = true; // the other for(int i=1;i&lt;row;i++)&#123; for(int j=1;j&lt;col;j++)&#123; if(matrix[i][j] == 0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; // set 0 skip first row &amp; col for(int i=1;i&lt;row;i++)&#123; for(int j=1;j&lt;col;j++)&#123; if(matrix[i][0]==0 || matrix[0][j]==0) matrix[i][j] = 0; &#125; &#125; // update first row &amp; col can cause problem // update first row &amp; col if(firstRow) for(int j=0;j&lt;col;j++) matrix[0][j] = 0; if(firstCol) for(int i=0;i&lt;row;i++) matrix[i][0] = 0;&#125; #74-search-a-2d-matrix-mediumWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example, Consider the following matrix: 12345[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] Given target = 3, return true. 1234567891011121314151617181920public boolean searchMatrix(int[][] matrix, int target) &#123; // convert to binary search if(matrix==null || matrix.length==0 || matrix[0].length==0) return false; final int m = matrix.length, n = matrix[0].length; // left right should be index int left = 0, right = m * n - 1; while(left &lt;= right)&#123; int mid = left + (right-left)/2; int row = mid / n; int col = mid % n; if(matrix[row][col] == target) return true; else if(matrix[row][col] &lt; target) left = mid + 1; else right = mid - 1; &#125; return false;&#125; #75-sort-colors-mediumGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem. 1234567891011121314151617181920public void sortColors(int[] nums) &#123; // 0000|i|1111|j|????|k|2222 if(nums==null || nums.length==0) return; int i = 0, j = 0, k = nums.length-1; // j is unvisited, notice j = k while(j &lt;= k)&#123; if(nums[j] == 0)&#123; swap(nums,i++,j++); &#125;else if(nums[j] == 1) j++; else if(nums[j] == 2) swap(nums,j,k--); &#125;&#125;private void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; 123456789101112131415161718public void sortColors(int[] nums) &#123; // 0000|i|1111|j|????|k|2222 if(nums==null || nums.length==0) return; int i = 0, j = 0, k = nums.length-1; // j is unvisited, notice j = k while(j &lt;= k)&#123; if(nums[j] == 0)&#123; nums[j++] = nums[i]; nums[i++] = 0; &#125;else if(nums[j] == 1)&#123; j ++; &#125;else if(nums[j] == 2)&#123; nums[j] = nums[k]; nums[k--] = 2; &#125; &#125;&#125; #76-minimun-window-substring-hardGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). For example,S = &quot;ADOBECODEBANC&quot;T = &quot;ABC&quot; Minimum window is &quot;BANC&quot;. Note:If there is no such window in S that covers all characters in T, return the empty string &quot;&quot;. If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S. 1234567891011121314151617181920212223242526272829public String minWindow(String s, String t) &#123; if(s==null || t==null) return \"\"; // find t histogram first int[] bin = new int[256]; for(char c : t.toCharArray()) bin[c] ++; // sliding window int head = 0, count = t.length(); int minLen = s.length() + 1, minHead = 0; for(int tail=0;tail&lt;s.length();tail++)&#123; if(bin[s.charAt(tail)] &gt; 0) count --; bin[s.charAt(tail)]--; // valid edge condition while(count == 0)&#123; // update min then shift window if(tail-head+1 &lt; minLen)&#123; minLen = tail - head + 1; minHead = head; &#125; if(bin[s.charAt(head)] == 0) count ++; bin[s.charAt(head)]++; head++; &#125; &#125; return minLen &gt; s.length() ? \"\" : s.substring(minHead,minHead+minLen);&#125; #77-combinations-mediumGiven two integers n and k, return all possible combinations of k numbers out of 1 … n. For example,If n = 4 and k = 2, a solution is: 12345678[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; // backtracking List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,new ArrayList&lt;&gt;(),1,n,k); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,List&lt;Integer&gt; temp,int start,int end,int count)&#123; // optimization here, if start to close to end so no enough elements if(count - temp.size() &gt; end - start + 1) return; ////////////////////////////////////// if(temp.size() == count)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=start;i&lt;=end;i++)&#123; temp.add(i); backtrack(result,temp,i+1,end,count); temp.remove(temp.size()-1); &#125;&#125; #78-subsets-mediumGiven a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; // backtracking // distinct List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,nums,new ArrayList&lt;&gt;(),0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result, int[] nums,List&lt;Integer&gt; temp,int idx)&#123; // add result each level result.add(new ArrayList&lt;&gt;(temp)); for(int i=idx;i&lt;nums.length;i++)&#123; temp.add(nums[i]); backtrack(result,nums,temp,i+1); temp.remove(temp.size()-1); &#125;&#125; #79-word-search-mediumGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example,Given board = 12345[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]] word = &quot;ABCCED&quot;, -&gt; returns true, word = &quot;SEE&quot;, -&gt; returns true, word = &quot;ABCB&quot;, -&gt; returns false. 12345678910111213141516171819202122232425262728293031public boolean exist(char[][] board, String word) &#123; // similar to num of island // use ^256 to obtain space O(1) if(board==null || board.length==0 || board[0].length==0) return false; final int m = board.length, n = board[0].length; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(helper(board,word,0,i,j)) return true; &#125; &#125; return false;&#125;private boolean helper(char[][] board,String word,int idx,int x,int y)&#123; if(idx == word.length()) return true; if(x&lt;0 || x&gt;=board.length || y&lt;0 || y&gt;=board[0].length || word.charAt(idx)!=board[x][y]) return false; // set to not a valid letter board[x][y] ^= 256; if(helper(board,word,idx+1,x-1,y) || helper(board,word,idx+1,x+1,y) || helper(board,word,idx+1,x,y-1) || helper(board,word,idx+1,x,y+1)) return true; // reset to letter board[x][y] ^= 256; return false;&#125; #80-remove-duplicates-from-sorted-array-ii-mediumFollow up for “Remove Duplicates”:What if duplicates are allowed at most twice? For example,Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length. 1234567891011121314151617181920212223242526public int removeDuplicates(int[] nums) &#123; if(nums==null) return 0; if(nums.length &lt;= 2) return nums.length; int tail = 2; // similar but check tail - 2 for(int i=2;i&lt;nums.length;i++)&#123; if(nums[i] != nums[tail-2]) nums[tail++] = nums[i]; &#125; return tail;&#125;public int removeDuplicates(int[] nums) &#123; // optimized if(nums==null) return 0; if(nums.length &lt;= 2) return nums.length; int tail = 0; for(int num : nums)&#123; if(tail &lt; 2 || num != nums[tail-2]) nums[tail++] = num; &#125; return tail;&#125; #81-search-in-rotated-sorted-array-ii-medium Follow up for “Search in Rotated Sorted Array”:What if duplicates are allowed? Would this affect the run-time complexity? How and why? #33-search-in-rotated-sorted-array-medium Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. 12345678910111213141516171819202122232425262728293031323334353637 public boolean search(int[] nums, int target) &#123;// 1) everytime check if targe == nums[mid], if so, we find it.// 2) otherwise, we check if the first half is in order (i.e. nums[left]&lt;=nums[mid]) // and if so, go to step 3), otherwise, the second half is in order, go to step 4)// 3) check if target in the range of [left, mid-1] (i.e. nums[left]&lt;=target &lt; nums[mid]), // if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;// 4) check if target in the range of [mid+1, right] (i.e. nums[mid]&lt;target &lt;= nums[right]), // if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1; if(nums==null || nums.length==0) return false; int left = 0, right = nums.length - 1; while(left &lt;= right)&#123; int mid = left + (right-left)/2; if(nums[mid] == target) return true; // difference to deal with duplicate here if(nums[left]==nums[mid] &amp;&amp; nums[mid]==nums[right])&#123; left++; right--; // left half not rotate &#125;else if(nums[left] &lt;= nums[mid])&#123; // mid in not rotate part if(nums[left]&lt;=target &amp;&amp; target&lt;nums[mid]) right = mid - 1; // mid in rotate part else left = mid + 1; // right half not rotate &#125;else if(nums[mid] &lt;= nums[right])&#123; // mid in not rotate part if(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right]) left = mid + 1; // mid in rotate part else right = mid -1; &#125; &#125; return false; &#125; #82-remove-duplicates-from-sorted-list-ii-mediumGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode dummy = new ListNode(0); ListNode prev = dummy, curr = head; dummy.next = head; while(curr != null)&#123; // if next val = curr val, check next while(curr.next!=null &amp;&amp; curr.val==curr.next.val) curr = curr.next; // if curr is distinct if(prev.next == curr) prev = prev.next; else // prev stays, case next sequence duplication // curr is the last duplication prev.next = curr.next; curr = curr.next; &#125; return dummy.next;&#125; #83-remove-duplicates-from-sorted-list-easyGiven a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. iteration 1234567891011public ListNode deleteDuplicates(ListNode head) &#123; if(head==null || head.next==null) return head; ListNode curr = head; while(curr != null)&#123; while(curr.next!=null &amp;&amp; curr.val==curr.next.val) curr.next = curr.next.next; curr = curr.next; &#125; return head;&#125; recursion 1234567public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); // here head.next != null return head.val == head.next.val ? head.next : head;&#125; #84-largest-rectangle-in-histogram-hardGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. For example,Given heights = [2,1,5,6,2,3],return 10. #42-trapping-rain-water-hard 123456789101112131415161718192021// Maintains an increasing stack// encounter smaller height, check all previous areas.public int largestRectangleArea(int[] heights) &#123; Stack&lt;Integer&gt; idxStack = new Stack&lt;&gt;(); int maxArea = 0; for (int i = 0; i &lt;= heights.length; i++) &#123; // push -1 for last, to pop all previous int height = i == heights.length ? 0 : heights[i]; // when increasing is broken while (!idxStack.isEmpty() &amp;&amp; heights[idxStack.peek()] &gt;= height) &#123; // get previous higher one, compute previous area // it's all area from smaller to the highest int h = heights[idxStack.pop()]; // if is empty, there is a bottom rectangle from current to head int w = idxStack.isEmpty() ? i : i - 1 - idxStack.peek(); maxArea = Math.max(maxArea, h * w); &#125; idxStack.push(i); &#125; return maxArea;&#125; optimized beats 98%, check left then right idea 1234567891011121314151617181920212223242526272829public int largestRectangleArea(int[] heights) &#123; // save left and right index // width is most left &amp; right idx whose h is larger if(heights==null || heights.length==0) return 0; int[] left = new int[heights.length]; int[] right = new int[heights.length]; // find left/right index whose h is larger // utilize previous result to reduce run time for(int i=0;i&lt;heights.length;i++)&#123; int l = i-1; while(l&gt;=0 &amp;&amp; heights[l]&gt;=heights[i]) l = left[l]; left[i] = l; &#125; for(int i=heights.length-1;i&gt;=0;i--)&#123; int r = i+1; while(r&lt;heights.length &amp;&amp; heights[r]&gt;=heights[i]) r = right[r]; right[i] = r; &#125; // then for h, the width is r - l - 1; int maxArea = 0; for(int i=0;i&lt;heights.length;i++)&#123; int w = right[i] - left[i] - 1; maxArea = Math.max(maxArea,heights[i]*w); &#125; return maxArea;&#125; #86-partition-list-mediumGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: 12Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 12345678910111213141516171819public ListNode partition(ListNode head, int x) &#123; // use two head; ListNode dummy1 = new ListNode(0), prev1 = dummy1; ListNode dummy2 = new ListNode(0), prev2 = dummy2; while(head != null)&#123; if(head.val &lt; x)&#123; prev1.next = head; prev1 = prev1.next; &#125;else&#123; prev2.next = head; prev2 = prev2.next; &#125; head = head.next; &#125; // combine two list prev1.next = dummy2.next; prev2.next = null; return dummy1.next;&#125; #87-scramble-string-hardGiven a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = &quot;great&quot;: 1234567 great / \\ gr eat / \\ / \\g r e at / \\ a t To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;. 1234567 rgeat / \\ rg eat / \\ / \\r g e at / \\ a t We say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;. Similarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;. 1234567 rgtae / \\ rg tae / \\ / \\r g ta e / \\ t a We say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: 12Input: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;Output: true Example 2: 12Input: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;Output: false 12345678910111213141516171819202122232425262728public boolean isScramble(String s1, String s2) &#123; // check all possible case if(s1.equals(s2)) return true; // check char count int[] bin = new int[256]; for(int i=0; i&lt;s1.length(); i++)&#123; bin[s1.charAt(i)]++; bin[s2.charAt(i)]--; &#125; // check is char equal for(int n : bin) if(n != 0) return false; // recursion call, check all substring // origin not include, from 1 to length for(int i=1; i&lt;s1.length(); i++)&#123; // a b | c d e, a b | d e c if(isScramble(s1.substring(0,i),s2.substring(0,i)) &amp;&amp; isScramble(s1.substring(i),s2.substring(i))) return true; // a b | c d e, c d e | a b if(isScramble(s1.substring(0,i),s2.substring(s2.length()-i)) &amp;&amp; isScramble(s1.substring(i),s2.substring(0,s2.length()-i))) return true; &#125; return false;&#125; #88-merge-sorted-array-easyGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: 12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 12345678public void merge(int[] nums1, int m, int[] nums2, int n) &#123; // from end to head, int i = m - 1, j = n - 1, k = m + n - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) nums1[k--] = nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--]; while(j &gt;= 0) // nums2 rest nums1[k--] = nums2[j--];&#125; #89-gray-code-mediumThe gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given n = 2, return [0,1,3,2]. Its gray code sequence is: 123400 - 001 - 111 - 310 - 2 Note:For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. 123456789public List&lt;Integer&gt; grayCode(int n) &#123; // bit manipulate List&lt;Integer&gt; result = new ArrayList(); // total should &lt; 1 &lt;&lt; n for(int i=0; i &lt; 1&lt;&lt;n; i++)&#123; result.add(i ^ i&gt;&gt;1); &#125; return result;&#125; #90-subsets-ii-mediumGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 12345678910Input: [1,2,2]Output:[ [2], [1], [1,2,2], [2,2], [1,2], []] 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); // since remove duplicate, need sorting Arrays.sort(nums); backtrack(result,nums,new ArrayList&lt;&gt;(),0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,List&lt;Integer&gt; temp,int idx)&#123; // no need to check result.add(new ArrayList&lt;&gt;(temp)); for(int i=idx;i&lt;nums.length;i++)&#123; // jump duplicate // notice its &gt; idx not &gt; 0 if(i&gt;idx &amp;&amp; nums[i]==nums[i-1]) continue; temp.add(nums[i]); backtrack(result,nums,temp,i+1); temp.remove(temp.size()-1); &#125;&#125; #92-reverse-linked-list-ii-mediumReverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 1234567891011121314151617public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummy = new ListNode(0); ListNode start = dummy; dummy.next = head; // find slow prev first for(int i=1; i&lt;m; i++) start = start.next; // end not change, curr for saving ListNode end = start.next, curr = null; for(int i=0; i&lt;n-m; i++)&#123; curr = end.next; end.next = curr.next; curr.next = start.next; start.next = curr; &#125; return dummy.next;&#125; #93-restore-ip-addresses-mediumGiven a string containing only digits, restore it by returning all possible valid IP address combinations. Example: 12Input: &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 12345678910111213141516171819202122232425262728293031public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); backtrack(result,s,new StringBuilder(),0,1); return result;&#125;private void backtrack(List&lt;String&gt; result,String s,StringBuilder sb,int idx,int block)&#123; // to 5 block and s is empty if(block == 5 &amp;&amp; idx == s.length())&#123; result.add(sb.toString()); return; &#125; // s left or block left if(block &gt; 4 || idx == s.length()) return; int len = sb.length(); // for reset // one block most 3 digit for(int i=1; i&lt;4 &amp;&amp; idx+i&lt;=s.length(); i++)&#123; String partition = s.substring(idx,idx+i); // case 001 &amp;&amp; 256 if(i!=1 &amp;&amp; partition.charAt(0)=='0' || i==3 &amp;&amp; Integer.parseInt(partition)&gt;255) continue; sb.append(partition); // for seperator if(block &lt; 4) sb.append('.'); // backtrack backtrack(result,s,sb,idx+i,block+1); sb.setLength(len); &#125;&#125; #94-binary-tree-inorder-traversal-mediumRecursion: 123456789101112public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); dfs(root,result); return result;&#125;private void dfs(TreeNode root,List&lt;Integer&gt; result)&#123; if(root == null) return; dfs(root.left,result); result.add(root.val); dfs(root.right,result);&#125; Iteration: 123456789101112131415public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.isEmpty() || root!=null)&#123; if(root != null)&#123; stack.push(root); root = root.left; &#125;else&#123; TreeNode curr = stack.pop(); result.add(curr.val); root = curr.right; &#125; &#125; return result;&#125; #97-interleaving-string-hardGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: 12Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;Output: true Example 2: 12Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;Output: false 12345678910111213141516171819202122232425262728293031public boolean isInterleave(String s1, String s2, String s3) &#123; if(s1==null || s2==null || s3==null) return false; if(s1.length() + s2.length() != s3.length()) return false; // s2 row, s1 col boolean[][] dp = new boolean[s1.length()+1][s2.length()+1]; dp[0][0] = true; // \"\" + \"\" == \"\" // init first row: check j-1 &amp;&amp; char==char for s2 for(int j=0; j&lt;s2.length(); j++) dp[0][j+1] = dp[0][j] &amp;&amp; s2.charAt(j)==s3.charAt(j); // init first col: check i-1 &amp;&amp; char==char for s1 for(int i=0; i&lt;s1.length(); i++) dp[i+1][0] = dp[i][0] &amp;&amp; s1.charAt(i)==s3.charAt(i); // dp for(int i=0; i&lt;s1.length(); i++)&#123; for(int j=0; j&lt;s2.length(); j++)&#123; // case1, add s1.char at tail // [i-1][j] &amp;&amp; s1.char==s3.char // case2, add s2.char at tail // [i][j-1] &amp;&amp; s2.char==s3.char char c1 = s1.charAt(i); char c2 = s2.charAt(j); char c3 = s3.charAt(i+j+1); // notice +1 // use if will quicker dp[i+1][j+1] = (dp[i][j+1] &amp;&amp; c1==c3) || (dp[i+1][j] &amp;&amp; c2==c3); &#125; &#125; return dp[s1.length()][s2.length()];&#125; #98-validate-binary-search-tree-mediumGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 1234567891011121314151617181920public boolean isValidBST(TreeNode root) &#123; // inorder iteration Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode prev = null; while(!stack.isEmpty() || root!=null)&#123; if(root != null)&#123; stack.push(root); root = root.left; &#125;else&#123; TreeNode curr = stack.pop(); // do inorder here if(prev==null || prev.val&lt;curr.val) prev = curr; // valid, mush &lt; else return false; root = curr.right; &#125; &#125; return true;&#125; #100-same-tree-easy123456789public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p==null &amp;&amp; q==null) return true; if(p==null || q==null) return false; if(p.val == q.val) return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); return false;&#125; #101-symmetric-tree-easyrecursion: 12345678910111213public boolean isSymmetric(TreeNode root) &#123; return root == null || isSymmetric(root.left,root.right); &#125;private boolean isSymmetric(TreeNode left,TreeNode right)&#123; if(left == null &amp;&amp; right == null) return true; if(left == null || right == null) return false; if(left.val == right.val) return isSymmetric(left.left,right.right) &amp;&amp; isSymmetric(left.right,right.left); return false;&#125; iteration: 12345678910111213141516171819202122public boolean isSymmetric(TreeNode root) &#123; if(root == null) return true; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root.left); queue.offer(root.right); while(queue.size() &gt;= 2)&#123; TreeNode left = queue.poll(); TreeNode right = queue.poll(); if(left==null &amp;&amp; right==null) continue; if(left==null || right==null) return false; if(left.val != right.val) return false; queue.add(left.left); queue.add(right.right); queue.add(left.right); queue.add(right.left); &#125; return true;&#125; #102-level-order-traversal-mediumIteration: 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(size); result.add(level); for(int i=0; i&lt;size; i++)&#123; TreeNode curr = queue.poll(); level.add(curr.val); if(curr.left != null) queue.offer(curr.left); if(curr.right != null) queue.offer(curr.right); &#125; &#125; return result;&#125; DFS recursion: 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; dfs(result,root,0); return result;&#125;private void dfs(List&lt;List&lt;Integer&gt;&gt; result, TreeNode root,int level)&#123; if(root == null) return; if(result.size() &lt; level + 1) result.add(new ArrayList&lt;&gt;()); result.get(level).add(root.val); dfs(result,root.left,level+1); dfs(result,root.right,level+1);&#125; DFS iteration: 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Map&lt;TreeNode,Integer&gt; map = new HashMap&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); map.put(root,0); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); int level = map.get(node); if(level + 1 &gt; result.size()) result.add(new ArrayList&lt;&gt;()); result.get(level).add(node.val); if(node.right != null)&#123; stack.push(node.right); map.put(node.right,level+1); &#125; if(node.left != null)&#123; stack.push(node.left); map.put(node.left,level+1); &#125; &#125; return result;&#125; Level order II 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if(root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(size); result.add(0,level); for(int i=0; i&lt;size; i++)&#123; TreeNode curr = queue.poll(); level.add(curr.val); if(curr.left != null) queue.offer(curr.left); if(curr.right != null) queue.offer(curr.right); &#125; &#125; return result;&#125; #103-zigzag-level-order-traversal-mediumGiven a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 return its zigzag level order traversal as: 12345[ [3], [20,9], [15,7]] 1234567891011121314151617181920212223242526public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int cnt = 0; while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; level = new LinkedList&lt;&gt;(); result.add(level); for(int i=0; i&lt;size; i++)&#123; TreeNode curr = queue.poll(); if(cnt % 2 == 0) level.add(curr.val); else level.add(0,curr.val); if(curr.left != null) queue.offer(curr.left); if(curr.right != null) queue.offer(curr.right); &#125; cnt ++; &#125; return result;&#125; #105-construct-tree-preorder-inorder-mediumGiven preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] Return the following binary tree: 12345 3 / \\9 20 / \\ 15 7 123456789101112131415161718192021public TreeNode buildTree(int[] preorder, int[] inorder) &#123; // use preorder traverse root, inorder find left &amp; right return helper(preorder,inorder,0,0,inorder.length-1);&#125;private TreeNode helper(int[] preorder,int[] inorder,int preTail,int inHead,int inTail)&#123; if(inHead &gt; inTail || preTail==preorder.length) return null; TreeNode node = new TreeNode(preorder[preTail]); // search node in inorder int idx = 0; for(int i=inHead; i&lt;=inTail; i++)&#123; if(inorder[i] == node.val) idx = i; &#125; // [inHead, i-1] left part, [i+1,inTail] right part int leftNode = preTail + 1; int rightNode = preTail + 1 + idx - inHead; node.left = helper(preorder,inorder,leftNode,inHead,idx-1); node.right = helper(preorder,inorder,rightNode,idx+1,inTail); return node;&#125; #106-construct-tree-inorder-postorder-mediumGiven inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12inorder = [9,3,15,20,7]postorder = [9,15,7,20,3] Return the following binary tree: 12345 3 / \\9 20 / \\ 15 7 12345678910111213141516171819202122232425public TreeNode buildTree(int[] inorder, int[] postorder) &#123; // from postorder define root, left child, // from inorder define left half, right half return helper(inorder, postorder, 0, inorder.length-1, 0, postorder.length-1);&#125;private TreeNode helper(int[] inorder, int[] postorder, int inHead, int inTail, int postHead, int postTail)&#123; // postHead,postTail not matter if(inHead &gt; inTail || postHead &gt; postTail) return null; // use postTail define root TreeNode node = new TreeNode(postorder[postTail]); // define left half and right half, search in inorder int idx = 0; for(int i=inHead; i&lt;=inTail; i++) if(inorder[i] == node.val)&#123; idx = i; break; &#125; // define left child and right child int leftNode = postHead + (idx - inHead - 1); int rightNode = leftNode + 1; node.left = helper(inorder,postorder,inHead,idx-1,postHead,leftNode); node.right = helper(inorder,postorder,idx+1,inTail,rightNode,postTail-1); return node;&#125; #109-sorted-list-to-bst-mediumGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 12345678910111213141516171819202122public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; // from here see tail init null, exclude return helper(head,null);&#125;private TreeNode helper(ListNode head,ListNode tail)&#123; // tail exclude if(head == tail) return null; ListNode slow = head, fast = head; // find mid when fast reach tail while(fast != tail &amp;&amp; fast.next != tail)&#123; slow = slow.next; fast = fast.next.next; &#125; // mid is slow TreeNode node = new TreeNode(slow.val); node.left = helper(head,slow);// mid exclude node.right = helper(slow.next,tail); return node;&#125; #110-balanced-binary-tree-easy12345678910111213public boolean isBalanced(TreeNode root) &#123; if(root == null) return true; int left = depth(root.left); int right = depth(root.right); if(Math.abs(left - right) &gt; 1) return false; return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125;private int depth(TreeNode root)&#123; return root == null ? 0 : 1 + Math.max(depth(root.left),depth(root.right));&#125; #111-min-depth-of-binary-tree-easy12345678910public int minDepth(TreeNode root) &#123; if(root == null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); if(left == 0 || right == 0) return left + right + 1; else return Math.min(left,right) + 1;&#125; #112-path-sum-easyGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. 12345678public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; // when leaf node if(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==sum) return true; return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);&#125; #113-path-sum-ii-mediumGiven a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); helper(root,sum,result,new ArrayList&lt;&gt;()); return result;&#125;private void helper(TreeNode root,int sum,List&lt;List&lt;Integer&gt;&gt; result,List&lt;Integer&gt; temp)&#123; if(root == null) return; // add here, add when null=&gt;duplicate result temp.add(root.val); // valid result added if(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==sum) result.add(new ArrayList&lt;&gt;(temp)); // left and right helper(root.left,sum-root.val,result,temp); helper(root.right,sum-root.val,result,temp); // remove curr temp.remove(temp.size()-1);&#125; #114-flatten-binary-tree-to-linked-list-mediumGiven a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 / \\ 2 5 / \\ \\3 4 6 The flattened tree should look like: 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 12345678910111213class Solution &#123; TreeNode prev = null; public void flatten(TreeNode root) &#123; if(root == null) return; // use reverse post order flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; &#125;&#125; #115-distinct-subsequences-hardGiven a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ACE&quot; is a subsequence of &quot;ABCDE&quot; while &quot;AEC&quot; is not). Example 1: 12345678910111213Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;Output: 3Explanation:As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.(The caret symbol ^ means the chosen letters)rabbbit^^^^ ^^rabbbit^^ ^^^^rabbbit^^^ ^^^ 12345678910111213141516171819202122232425public int numDistinct(String s, String t) &#123; // similar to regex 10 // use dp if(s==null || t==null) return 0; // rows t, columns s, remove char from s int[][] dp = new int[t.length()+1][s.length()+1]; // init first row: remove all to get \"\" for(int col=0; col&lt;=s.length(); col++) dp[0][col] = 1; // init first col: should all be 0: \"\" cannot get un-\"\" for(int i=0; i&lt;t.length(); i++)&#123; // for t for(int j=0; j&lt;s.length(); j++)&#123; // for s // 1. if same char: keep it || remove it // if keep dp[i][j] = dp[i-1][j-1]; // if remove dp[i][j] = dp[i][j-1]; if(s.charAt(j) == t.charAt(i))&#123; dp[i+1][j+1] = dp[i][j] + dp[i+1][j]; &#125;else&#123; // 2. if not same: remove it dp[i+1][j+1] = dp[i+1][j]; &#125; &#125; &#125; return dp[t.length()][s.length()]; &#125; #116-populating-next-right-pointer-mediumGiven a binary tree 12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. After calling your function, the tree should look like: 12345 1 -&gt; NULL / \\ 2 -&gt; 3 -&gt; NULL / \\ / \\4-&gt;5-&gt;6-&gt;7 -&gt; NULL 1234567891011121314151617public void connect(TreeLinkNode root) &#123; if(root == null) return; TreeLinkNode level = root, curr = null; while(level != null)&#123; curr = level; while(curr != null)&#123; if(curr.left != null)&#123; curr.left.next = curr.right; if(curr.next != null) curr.right.next = curr.next.left; &#125; curr = curr.next; &#125; level = level.left; &#125;&#125; #117-populating-next-right-pointer-ii-mediumGiven the following binary tree, 12345 1 / \\ 2 3 / \\ \\4 5 7 After calling your function, the tree should look like: 12345 1 -&gt; NULL / \\ 2 -&gt; 3 -&gt; NULL / \\ \\4-&gt; 5 -&gt; 7 -&gt; NULL 123456789101112131415161718192021222324252627282930public void connect(TreeLinkNode root) &#123; TreeLinkNode curr = root; // one high level TreeLinkNode head = null, prev = null; // two low level while(curr != null)&#123; // in curr level while(curr != null)&#123; if(curr.left != null)&#123; if(prev == null)&#123; // no head found head = curr.left; &#125;else&#123; prev.next = curr.left; &#125; prev = curr.left; &#125; if(curr.right != null)&#123; if(prev == null)&#123; head = curr.right; &#125;else&#123; prev.next = curr.right; &#125; prev = curr.right; &#125; curr = curr.next; &#125; // jump to next level head &amp; reset curr = head; head = null; prev = null; &#125;&#125; #118-pascals-triangle-easy123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 1234567891011public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for(int row=1; row&lt;=numRows; row++)&#123; temp.add(1); for(int i=temp.size()-2; i&gt;0; i--) temp.set(i,temp.get(i)+temp.get(i-1)); result.add(new ArrayList&lt;&gt;(temp)); &#125; return result;&#125; #120-triangle-mediumGiven a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 1234567891011121314151617public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; // add bottom up, so that space O(1) if(triangle.size() == 0) return 0; int n = triangle.size(); // n+1 for the last line int[] memo = new int[n+1]; // for location i, check i &amp; i+1 for(int i=n-1; i&gt;=0; i--)&#123; for(int j=0; j&lt;triangle.get(i).size(); j++)&#123; int curr = triangle.get(i).get(j); // memo is init as 0s memo[j] = Math.min(memo[j],memo[j+1]) + curr; &#125; &#125; return memo[0];&#125; #130-surrounded-regionsGiven a 2D board containing &#39;X&#39; and &#39;O&#39; (the letter O), capture all regions surrounded by &#39;X&#39;. A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region. For example, 1234X X X XX O O XX X O XX O X X After running your function, the board should be: 1234X X X XX X X XX X X XX O X X Notice overflow case: 12345678910OOOOOOOOOOXXXXXXXXXOOOOOOOOOOOOXXXXXXXXXOOOOOOOOOOXXXXXXXXXOOOOOOOOOOOOXXXXXXXXXOOOOOOOOOOXXXXXXXXXO 12345678910OOOOOOOOOOOXXXXXXXXXXXOXXOOOOOOOOOOXXOXXXXXXXXXXXOOOOOOOOOOXXXXXXXXXXXOXXOOOOOOOOOOXXOXXXXXXXXXXXOOOOOOOOOOXXXXXXXXXXXOX 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void solve(char[][] board) &#123; // if surrounded, must at edge // check edge set 0 to 1 if(board==null||board.length==0||board[0].length==0) return; int m = board.length, n = board[0].length; // set first last row for(int j=0; j&lt;n; j++)&#123; check(board,m,n,0,j); if(m &gt; 1) check(board,m,n,m-1,j); &#125; // set left right col for(int i=1; i&lt;m; i++)&#123; check(board,m,n,i,0); if(n &gt; 1) check(board,m,n,i,n-1); &#125; // set 1 to 0, 0 to X for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(board[i][j] == '1') board[i][j] = 'O'; else if(board[i][j] == 'O') board[i][j] = 'X'; &#125; &#125;&#125;private void check(char[][] board,int m,int n,int i,int j)&#123; // use trick avoid TLE, skip first row and left col // skip only one not both for best performance if(board[i][j] == 'O')&#123; board[i][j] = '1'; // use i&gt;1 instead of i&gt;=1 if(i &gt; 1) check(board,m,n,i-1,j); if(i &lt; m-1) check(board,m,n,i+1,j); // use j&gt;1 instead of j&gt;=1 if(j &gt; 1) check(board,m,n,i,j-1); if(j &lt; n-1) check(board,m,n,i,j+1); &#125;&#125; #133-clone-graph-mediumClone an undirected graph. Each node in the graph contains a label and a list of its neighbors. 123456789101112131415161718192021222324/** * Definition for undirected graph. * class UndirectedGraphNode &#123; * int label; * List&lt;UndirectedGraphNode&gt; neighbors; * UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125; * &#125;; */ public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; Map&lt;Integer,UndirectedGraphNode&gt; visited = new HashMap&lt;&gt;(); return clone(node,visited); &#125; private UndirectedGraphNode clone(UndirectedGraphNode node, Map&lt;Integer,UndirectedGraphNode&gt; visited)&#123; if(node == null) return null; if(visited.containsKey(node.label)) return visited.get(node.label); UndirectedGraphNode newNode = new UndirectedGraphNode(node.label); visited.put(node.label,newNode); for(UndirectedGraphNode n : node.neighbors)&#123; newNode.neighbors.add(clone(n,visited)); &#125; return newNode; &#125; #136-single-number-easyGiven a non-empty array of integers, every element appears twice except for one. Find that single one. 123456public int singleNumber(int[] nums) &#123; int result = 0; for(int num : nums) result ^= num; return result;&#125; #141-linked-list-cycle-easyGiven a linked list, determine if it has a cycle in it. 123456789101112public boolean hasCycle(ListNode head) &#123; if(head == null) return false; ListNode slow = head, fast = head; do&#123; if(fast==null || fast.next==null) return false; slow = slow.next; fast = fast.next.next; &#125;while(slow != fast); return true;&#125; 123456789101112public boolean hasCycle(ListNode head) &#123; if(head==null) return false; ListNode slow = head, fast = head; while(fast !=null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if(slow == fast) return true;; &#125; return false;&#125; #142-linked-list-cycle-ii-mediumGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. 12345678910111213141516public ListNode detectCycle(ListNode head) &#123; if(head==null || head.next==null) return null; ListNode slow = head, fast = head; do&#123; if(fast==null || fast.next==null) return null; slow = slow.next; fast = fast.next.next; &#125;while(slow != fast); while(head != fast)&#123; head = head.next; fast = fast.next; &#125; return head;&#125; #146-lru-cache-hardDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class LRUCache &#123; // implement double linked list // most recent at head // least recent at tail DListNode head = null; DListNode tail = null; int capacity = 0; Map&lt;Integer,DListNode&gt; map; // save key, node public LRUCache(int capacity) &#123; this.capacity = capacity; map = new HashMap&lt;&gt;(); // init head tail head = new DListNode(); tail = new DListNode(); head.next = tail; tail.prev = head; &#125; public int get(int key) &#123; if(!map.containsKey(key)) return -1; DListNode node = map.get(key); moveToHead(node); // most recent return node.val; &#125; public void put(int key, int value) &#123; // notice when same key, diff val if(map.containsKey(key))&#123; DListNode node = map.get(key); node.setVal(value); moveToHead(node); // active return; &#125; DListNode node = new DListNode(key,value); if(capacity == 0)&#123; int removeKey = removeLast(); // remove least from list and map map.remove(removeKey); capacity ++; &#125; addFirst(node); map.put(key,node); capacity --; &#125; // add most recent to head private void addFirst(DListNode node)&#123; node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; &#125; // remove a node private void remove(DListNode node)&#123; node.prev.next = node.next; node.next.prev = node.prev; node.prev = null; node.next = null; &#125; // remove least recent node, return key private int removeLast()&#123; DListNode last = tail.prev; remove(tail.prev); return last.key; &#125; // set to head private void moveToHead(DListNode node)&#123; remove(node); addFirst(node); &#125; private class DListNode&#123; int key; int val; DListNode prev; DListNode next; public DListNode()&#123;&#125; public DListNode(int key,int val)&#123; this.key = key; this.val = val; &#125; // use when put with same key public void setVal(int val)&#123; this.val = val; &#125; &#125;&#125; #149-max-points-on-a-line-hardGiven n points on a 2D plane, find the maximum number of points that lie on the same straight line. #151-reverse-words-in-a-string-medium1234567891011121314151617181920212223242526272829303132333435363738394041public String reverseWords(String s) &#123; if(s == null || s.length() == 0) return \"\"; char[] input = s.toCharArray(); int l = 0, r = 0; while(r &lt; input.length)&#123; // find head l = r; while(l&lt;input.length &amp;&amp; input[l]==' ') l++; // find tail r = l; while(r&lt;input.length &amp;&amp; input[r]!=' ') r++; // reverse reverse(input,l,r-1); &#125; // reverse whole reverse(input,0,input.length-1); return reduce(input); &#125;private String reduce(char[] c)&#123; int head = 0; for(int tail=0; tail&lt;c.length; tail++)&#123; if(c[tail]==' ' &amp;&amp; (head==0 || c[tail-1]==' ')) continue; c[head++] = c[tail]; &#125; // case last \" \" if(head &gt; 0 &amp;&amp; c[head-1] == ' ') return new String(c,0,head-1); return new String(c,0,head);&#125;private void reverse(char[] c,int i,int j)&#123; while(i &lt; j)&#123; char temp = c[i]; c[i] = c[j]; c[j] = temp; i++; j--; &#125;&#125; #156-binary-tree-upside-down-mediumGiven a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root. For example:Given a binary tree {1,2,3,4,5}, 12345 1 / \\ 2 3 / \\4 5 return the root of the binary tree [4,5,2,#,#,3,1]. 1234567891011 4 / \\ 5 2 / \\ 3 1 1 / 2 -- 3 / 4 -- 5 1234567891011121314151617181920public TreeNode upsideDownBinaryTree(TreeNode root) &#123; // 1 // / \\ // 2 - 3 // / \\ // 4 - 5 TreeNode curr = root; TreeNode next = null, prev = null, right = null; while(curr != null)&#123; next = curr.left; // save left curr.left = right; right = curr.right; curr.right = prev; prev = curr; curr = next; &#125; return prev;&#125; #159-longest-substring-with-at-most-2-distince-characters-hardGiven a string s , find the length of the longest substring t that contains at most 2 distinct characters. Example 1: 123Input: &quot;eceba&quot;Output: 3Explanation: t is &quot;ece&quot; which its length is 3. Example 2: 123Input: &quot;ccaabbb&quot;Output: 5Explanation: t is &quot;aabbb&quot; which its length is 5. 123456789101112131415161718192021public int lengthOfLongestSubstringTwoDistinct(String s) &#123; // sliding window if(s == null || s.length() == 0) return 0; int[] bin = new int[256]; int head = 0, maxLen = 0, count = 0; for(int tail=0; tail&lt;s.length(); tail++)&#123; if(bin[s.charAt(tail)] == 0) // new char count ++; bin[s.charAt(tail)] ++; while(count &gt; 2)&#123; // make it most 2 if(bin[s.charAt(head)] == 1) // remove a distinct char count --; bin[s.charAt(head)] --; head++; &#125; maxLen = Math.max(maxLen,tail-head+1); &#125; return maxLen;&#125; #160-intersection-of-two-linked-list-easyWrite a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 O(n) &amp; O(1) 1234567891011public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; ListNode pointer1 = headA; ListNode pointer2 = headB; // 2 iterations to overcome the difference while(pointer1 != pointer2)&#123; pointer1 = pointer1==null? headB:pointer1.next; pointer2 = pointer2==null? headA:pointer2.next; &#125; return pointer1;&#125; #163-missing-ranges-mediumGiven a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges. For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return [&quot;2&quot;, &quot;4-&gt;49&quot;, &quot;51-&gt;74&quot;, &quot;76-&gt;99&quot;]. Corner cases: Integer.min, Integer.max #228-summary-ranges-medium 1234567891011121314151617181920212223242526272829public List&lt;String&gt; findMissingRanges(int[] nums, int lower, int upper) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(nums==null) return result; int head = lower; for(int i=0; i&lt;nums.length; i++)&#123; // deal with corner case // [-2147483648,-2147483648,0,2147483647,2147483647] // -2147483648 // 2147483647 if(nums[i] == Integer.MIN_VALUE)&#123; // tail cannot be nums[i] - 1 head = nums[i] + 1; continue; &#125; int tail = nums[i] - 1; if(tail &gt;= head) result.add(head + (tail&gt;head? \"-&gt;\"+tail : \"\")); // deal with corner case, return here if(nums[i] == Integer.MAX_VALUE) return result; head = nums[i] + 1; &#125; // deal with last num if(head &lt;= upper) result.add(head + (upper&gt;head? \"-&gt;\"+upper : \"\")); return result;&#125; #165-compare-version-numbers-mediumCompare two version numbers version1 and version2.If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character.The . character does not represent a decimal point and is used to separate number sequences.For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. Here is an example of version numbers ordering: 120.1 &lt; 1.1 &lt; 1.2 &lt; 13.37 01 = 1, 1.0 = 1 12345678910111213141516public int compareVersion(String version1, String version2) &#123; // . match a char String[] v1 = version1.split(\"\\\\.\"); String[] v2 = version2.split(\"\\\\.\"); for(int i=0,j=0;i&lt;v1.length||j&lt;v2.length;)&#123; int num1 = i &gt;= v1.length ? 0 : Integer.parseInt(v1[i++]); int num2 = j &gt;= v2.length ? 0 : Integer.parseInt(v2[j++]); if(num1 == num2) continue; else if(num1 &lt; num2) return -1; else return 1; &#125; return 0;&#125; #169-majority-element-easyGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Can use sorting as well #229-majority-element-ii-medium 12345678910public int majorityElement(int[] nums) &#123; // Boyer-Moore Voting Algorithm int result = 0, count = 0; for(int num : nums)&#123; if(count == 0) result = num; count += num == result ? 1 : -1; &#125; return result;&#125; 200. Number of Islands (medium)Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. *Example 1:* Answer: 1 123411110110101100000000 *Example 2:* Answer: 3 123411000110000010000011 dfs approach time O(mn), space O(mn) worst 1234567891011121314151617181920212223242526272829public int numIslands(char[][] grid) &#123; if(grid==null || grid.length==0 || grid[0].length==0) return 0; // dfs approach, connected component idea int m = grid.length, n = grid[0].length; int count = 0; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; // if 1, count ++, traverse neighbor if(grid[i][j] == '1')&#123; count ++; dfs(grid,i,j); &#125; &#125; &#125; return count;&#125;private void dfs(char[][] grid,int i,int j)&#123; int m = grid.length, n = grid[0].length; // if out of bound, or not island if(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || grid[i][j]=='0') return; grid[i][j] = '0'; // set visited // visit up down left right dfs(grid,i-1,j); dfs(grid,i+1,j); dfs(grid,i,j-1); dfs(grid,i,j+1);&#125; BFS approach, time O(mn), space O(min(m,n)) 12345678910111213141516171819202122232425262728293031323334353637383940public int numIslands(char[][] grid) &#123; // bfs approach if(grid==null || grid.length==0 || grid[0].length==0) return 0; int count = 0; int m = grid.length, n = grid[0].length; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; // only care about 1 if(grid[i][j] == '1')&#123; count ++; grid[i][j] = '0'; int[] curr = &#123;i,j&#125;; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(curr); while(!queue.isEmpty())&#123; curr = queue.poll(); int row = curr[0], col = curr[1]; if(row-1&gt;=0 &amp;&amp; grid[row-1][col] == '1')&#123; queue.offer(new int[]&#123;row-1,col&#125;); grid[row-1][col] = '0'; &#125; if(row+1&lt;m &amp;&amp; grid[row+1][col] == '1')&#123; queue.offer(new int[]&#123;row+1,col&#125;); grid[row+1][col] = '0'; &#125; if(col-1&gt;=0 &amp;&amp; grid[row][col-1] == '1')&#123; queue.offer(new int[]&#123;row,col-1&#125;); grid[row][col-1] = '0'; &#125; if(col+1&lt;n &amp;&amp; grid[row][col+1] == '1')&#123; queue.offer(new int[]&#123;row,col+1&#125;); grid[row][col+1] = '0'; &#125; &#125; &#125; &#125; &#125; return count;&#125; #201-bitwise-and-of-numbers-range-mediumGiven a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. For example, given the range [5, 7], you should return 4. 123456789101112131415public int rangeBitwiseAnd(int m, int n) &#123; // right shift, all tail digits are 0 // until m == n, this is the head // append 0 tail to head if(m == 0) // 0 &amp; x == 0 return 0; int tailLen = 0; while(m != n)&#123; m &gt;&gt;= 1; n &gt;&gt;= 1; tailLen ++; &#125; return m &lt;&lt; tailLen;&#125; #204-count-primes-easyDescription: Count the number of prime numbers less than a non-negative number, n. 1234567891011121314151617public int countPrimes(int n) &#123; if(n &lt; 1) return 0; // indicate whether prime boolean[] prime = new boolean[n]; Arrays.fill(prime,true); int count = 0; for(int i=2; i&lt;n; i++)&#123; if(prime[i])&#123; count ++; for(int j=2; i*j&lt;n; j++)&#123; prime[i * j] = false; &#125; &#125; &#125; return count;&#125; #207-course-schedule-mediumThere are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: 1234Input: 2, [[1,0]] Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. 1234567891011121314151617181920212223242526272829303132333435public boolean canFinish(int numCourses, int[][] prerequisites) &#123; // detect cycle // use adjacency list, assume input valid List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); for(int i=0; i&lt;numCourses; i++) graph.add(new ArrayList&lt;&gt;()); for(int[] prerequisite : prerequisites)&#123; graph.get(prerequisite[0]).add(prerequisite[1]); &#125; // track visited node Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); // track along a path for one start Set&lt;Integer&gt; path = new HashSet&lt;&gt;(); for(int i=0; i&lt;numCourses; i++)&#123; if(hasCycle(graph,visited,path,i)) return false; &#125; return true;&#125;private boolean hasCycle(List&lt;List&lt;Integer&gt;&gt; graph,Set&lt;Integer&gt; visited,Set&lt;Integer&gt; path,int node)&#123; // visited in path, cycle if(path.contains(node)) return true; // no need to visit if(visited.contains(node)) return false; visited.add(node); // set visited path.add(node); // add to path for(int child : graph.get(node))&#123; if(hasCycle(graph,visited,path,child)) return true; &#125; path.remove(node); // path finish, remove return false;&#125; #210-course-schedule-ii-mediumtopological sort a directed graph dfs with check cycle: 12345678910111213141516171819202122232425262728293031323334353637383940public int[] findOrder(int numCourses, int[][] prerequisites) &#123; // dfs topological, stack result // no outcome node bottom, no income top List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); // graph save cout come edge for(int i=0; i&lt;numCourses; i++) graph.add(new ArrayList&lt;&gt;()); for(int[] p : prerequisites) graph.get(p[1]).add(p[0]); // check path, and visited (in result) // use stack to save visited node boolean[] path = new boolean[numCourses]; boolean[] visited = new boolean[numCourses]; Stack&lt;Integer&gt; order = new Stack&lt;&gt;(); // start dfs for(int i=0; i&lt;numCourses; i++)&#123; if(hasCycle(graph,order,visited,path,i)) return new int[0]; &#125; int[] result = new int[numCourses]; int idx = 0; while(!order.isEmpty()) result[idx++] = order.pop(); return result;&#125;private boolean hasCycle(List&lt;List&lt;Integer&gt;&gt; graph,Stack&lt;Integer&gt; order,boolean[] visited,boolean[] path,int curr)&#123; if(visited[curr]) return false; if(path[curr]) return true; path[curr] = true; for(int child : graph.get(curr))&#123; if(hasCycle(graph,order,visited,path,child)) return true; &#125; path[curr] = false; visited[curr] = true; order.push(curr); return false;&#125; BFS: ADJ list save outcome, then count income 1234567891011121314151617181920212223242526272829303132333435public int[] findOrder(int numCourses, int[][] prerequisites) &#123; // topological output: no income node firse, this case no pre // check degree 0 node (no prerequisites), add to queue, // adj list save out edge [0,1] =&gt; 1 -&gt; 0, when save 1 : 0 List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); // graph saved is node and outcome // but countPre save income number int[] countPre = new int[numCourses]; for(int i=0; i&lt;numCourses; i++) graph.add(new LinkedList&lt;&gt;()); for(int[] p : prerequisites)&#123; graph.get(p[1]).add(p[0]); // save outcome countPre[p[0]]++; // count income (pre) &#125; // init queue, find course with no pre int[] order = new int[numCourses]; int idx = 0; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i=0; i&lt;countPre.length; i++)&#123; if(countPre[i] == 0) queue.offer(i); &#125; // start bfs while(!queue.isEmpty())&#123; int curr = queue.poll(); order[idx++] = curr; // no income(pre) for(int child : graph.get(curr))&#123; // for all outcome node, income -- countPre[child]--; if(countPre[child] == 0) queue.offer(child); &#125; &#125; return idx == numCourses ? order : new int[0];&#125; #217-contains-duplicate-easyGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Use HashSet: time O(n), space O(n) Use Sort: time O(nlgn), space O(1) #219-contains-duplicate-ii-easyGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. 123456789public boolean containsNearbyDuplicate(int[] nums, int k) &#123; if(k&lt;=0) return false; Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(i-k&gt;0) visited.remove(nums[i-k-1]); if(!visited.add(nums[i])) return true; &#125; return false;&#125; #220-contains-duplicate-iii-mediumGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. Use TreeSet 1234567891011121314151617181920212223242526public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; // abs(nums[i] - nums[j]) &lt;= t // abs(i - j) &lt;= k // O(n log k) if(nums==null || nums.length==0 || t&lt;0 || k&lt;0) return false; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for(int i=0; i&lt;nums.length; i++)&#123; // maintance a window if(i - k &gt; 0) set.remove(nums[i - k - 1]); // floor: greatest less or equal to // ceiling: smallest greater or equal to // NOTICE: overflow Integer left = set.ceiling(Integer.MIN_VALUE + t &lt; nums[i] ? nums[i] - t : Integer.MIN_VALUE); Integer right = set.floor(Integer.MAX_VALUE - t &gt; nums[i] ? nums[i] + t : Integer.MAX_VALUE); if(left != null &amp;&amp; left &lt;= nums[i] || right != null &amp;&amp; right &gt;= nums[i]) return true; // add set set.add(nums[i]); &#125; return false;&#125; #223-rectangle-area-mediumFind the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. Assume that the total area is never beyond the maximum possible value of int. 12345678910111213141516171819202122232425262728293031public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; // FIND INTERSECTION // x axis: A---C E---F int X = 0; if(C-A&gt;G-E &amp;&amp; E&gt;=A &amp;&amp; G&lt;=C) X = G - E; else if(C-A&lt;=G-E &amp;&amp; A&gt;=E &amp;&amp; C&lt;=G) X = C - A; // after above 2, low priority else if(G&gt;A &amp;&amp; E&lt;A) X = G - A; else if(E&lt;C &amp;&amp; G&gt;C) X = C - E; // y axis: B---D F---H int Y = 0; // check include relation first if(D-B&gt;H-F &amp;&amp; F&gt;=B &amp;&amp; H&lt;=D) Y = H - F; else if(D-B&lt;=H-F &amp;&amp; B&gt;=F &amp;&amp; D&lt;=H) Y = D - B; else if(H&gt;B &amp;&amp; F&lt;B) Y = H - B; else if(F&lt;D &amp;&amp; H&gt;D) Y = D - F; // compute int area1 = (C-A) * (D-B); int area2 = (G-E) * (H-F); int area3 = X * Y; return area1 + area2 - area3;&#125; #228-summary-ranges-mediumGiven a sorted integer array without duplicates, return the summary of its ranges. Example 1: 12Input: [0,1,2,4,5,7]Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;] Example 2: 12Input: [0,2,3,4,6,8,9]Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;] 1234567891011121314151617181920212223public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(nums==null || nums.length==0) return result; Integer head = null; StringBuilder sb = new StringBuilder(); for(int i=0; i&lt;nums.length; i++)&#123; if(head == null) head = nums[i]; if(i&lt;nums.length-1 &amp;&amp; nums[i]+1==nums[i+1]) continue; else&#123; // last one or new range sb.append(head); // notice one num if(head != nums[i]) sb.append(\"-&gt;\"+nums[i]); result.add(sb.toString()); sb.setLength(0); head = null; &#125; &#125; return result;&#125; 12345678910111213141516public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(nums==null || nums.length==0) return result; for(int head=0; head&lt;nums.length; head++)&#123; int tail = head; while(tail&lt;nums.length-1 &amp;&amp; nums[tail]+1==nums[tail+1]) tail ++; if(head != tail) result.add(nums[head] + \"-&gt;\" + nums[tail]); else result.add(nums[head] + \"\"); head = tail; &#125; return result;&#125; #229-majority-element-ii-mediumGiven an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space. Check existence first!! 1234567891011121314151617181920212223242526272829303132333435363738public List&lt;Integer&gt; majorityElement(int[] nums) &#123; // majority vote List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(nums == null || nums.length == 0) return result; int major1 = 0, major2 = 0, cnt1 = 0, cnt2 = 0; for(int num : nums)&#123; // order matters if(major1 == num) cnt1 ++; else if(major2 == num) cnt2 ++; else if(cnt1 == 0)&#123; major1 = num; cnt1 ++; &#125;else if(cnt2 == 0)&#123; major2 = num; cnt2 ++; &#125;else&#123; cnt1 --; cnt2 --; &#125; &#125; // 2nd pass, cnt accurance cnt1 = cnt2 = 0; for(int num : nums)&#123; if(major1 == num) cnt1 ++; else if(major2 == num) cnt2 ++; &#125; // add to result if(cnt1 &gt; nums.length / 3) result.add(major1); if(cnt2 &gt; nums.length / 3) result.add(major2); return result;&#125; #235-lca-of-a-bst-easyGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. 123456789 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null) return null; if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right,p,q); if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left,p,q); return root;&#125; #236-lca-of-a-binay-tree-mediumGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” 1234567891011public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null) return right; if(right == null) return left; return root; &#125; #239-sliding-window-maxmum-hardGiven an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 123456789101112131415161718192021222324// use deque maintains max at headpublic int[] maxSlidingWindow(int[] nums, int k) &#123; if(nums==null || nums.length==0) return new int[0]; int[] result = new int[nums.length - k + 1]; Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); for(int i=0;i&lt;k-1;i++) inQueue(deque,nums[i]); for(int i=k-1;i&lt;nums.length;i++)&#123; inQueue(deque,nums[i]); result[i-k+1] = deque.peekFirst(); outQueue(deque,nums[i-k+1]); &#125; return result;&#125;private void inQueue(Deque&lt;Integer&gt; deque,int num)&#123; while(!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;num) deque.pollLast(); deque.offerLast(num);&#125;private void outQueue(Deque&lt;Integer&gt; deque,int num)&#123; if(deque.peekFirst() == num) deque.pollFirst();&#125; #241-different-ways-to-add-parentheses-mediumGiven a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1 Input: &quot;2-1-1&quot;. 12((2-1)-1) = 0(2-(1-1)) = 2 Output: [0, 2] Example 2 Input: &quot;2*3-4*5&quot; 12345(2*(3-(4*5))) = -34((2*3)-(4*5)) = -14((2*(3-4))*5) = -10(2*((3-4)*5)) = -10(((2*3)-4)*5) = 10 Output: [-34, -14, -10, -10, 10] 12345678910111213141516171819202122232425262728293031323334353637public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; // use recursion List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int i=0;i&lt;input.length();i++)&#123; char c = input.charAt(i); // divide input to two part if(c=='+' || c=='-' || c=='*')&#123; String left = input.substring(0,i); String right = input.substring(i+1); List&lt;Integer&gt; list1 = diffWaysToCompute(left); List&lt;Integer&gt; list2 = diffWaysToCompute(right); // combine to subset for(int num1 : list1)&#123; for(int num2 : list2)&#123; int temp = 0; switch(c)&#123; case '+': temp = num1 + num2; break; case '-': temp = num1 - num2; break; case '*': temp = num1 * num2; break; &#125; // one possible result result.add(temp); &#125; &#125; &#125; &#125; // case theres no operator in input if(result.size() == 0) result.add(Integer.parseInt(input)); return result;&#125; add memory and optimization 1234567891011121314151617181920212223242526272829303132333435363738394041424344public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); return dfs(input,map,0,input.length());&#125;private List&lt;Integer&gt; dfs(String input,Map&lt;String,List&lt;Integer&gt;&gt; map,int start,int end)&#123; // use recursion // if this expression is saved String expression = input.substring(start,end); if(map.containsKey(expression)) return map.get(expression); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int i=start;i&lt;end;i++)&#123; char c = input.charAt(i); // divide input to two part if(c=='+' || c=='-' || c=='*')&#123; List&lt;Integer&gt; list1 = dfs(input,map,start,i); List&lt;Integer&gt; list2 = dfs(input,map,i+1,end); // combine to subset for(int num1 : list1)&#123; for(int num2 : list2)&#123; int temp = 0; switch(c)&#123; case '+': temp = num1 + num2; break; case '-': temp = num1 - num2; break; case '*': temp = num1 * num2; break; &#125; // one possible result result.add(temp); &#125; &#125; &#125; &#125; // case theres no operator in input if(result.size() == 0) result.add(Integer.parseInt(expression)); map.put(expression,result); return result; &#125; #243-shortest-word-distance-easyGiven a list of words and two words word1 and word2, return the shortest distance between these two words in the list. For example,Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]. Given word1 = “coding”, word2 = “practice”, return 3.Given word1 = &quot;makes&quot;, word2 = &quot;coding&quot;, return 1. Note:You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. 123456789101112131415public int shortestDistance(String[] words, String word1, String word2) &#123; if(words==null || words.length==0) return 0; int idx1 = -1, idx2 = -1, min = words.length; for(int i=0;i&lt;words.length;i++)&#123; if(words[i].equals(word1)) idx1 = i; else if(words[i].equals(word2)) idx2 = i; // need to check whether idx are set if(idx1!=-1 &amp;&amp; idx2!=-1) min = Math.min(min,Math.abs(idx1-idx2)); &#125; return min;&#125; #244-shortest-word-distance-ii-mediumThis is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it? Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list. For example,Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]. Given word1 = “coding”, word2 = “practice”, return 3.Given word1 = &quot;makes&quot;, word2 = &quot;coding&quot;, return 1. Note:You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. 123456789101112131415161718192021222324252627class WordDistance &#123; Map&lt;String,List&lt;Integer&gt;&gt; map; public WordDistance(String[] words) &#123; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;words.length;i++)&#123; if(!map.containsKey(words[i])) map.put(words[i],new ArrayList&lt;&gt;()); map.get(words[i]).add(i); &#125; &#125; public int shortest(String word1, String word2) &#123; List&lt;Integer&gt; l1 = map.get(word1); List&lt;Integer&gt; l2 = map.get(word2); int min = Integer.MAX_VALUE; int idx1 = 0, idx2 = 0; // utilize two pointer to optimize while(idx1&lt;l1.size() &amp;&amp; idx2&lt;l2.size())&#123; min = Math.min(min,Math.abs(l1.get(idx1)-l2.get(idx2))); if(l1.get(idx1) &lt; l2.get(idx2)) idx1++; else idx2++; &#125; return min; &#125;&#125; #245-shortest-word-distance-iii-mediumThis is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2. Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. word1 and word2 may be the same and they represent two individual words in the list. For example,Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]. Given word1 = “makes”, word2 = “coding”, return 1.Given word1 = &quot;makes&quot;, word2 = &quot;makes&quot;, return 3. Note:You may assume word1 and word2 are both in the list. 1234567891011121314151617181920public int shortestWordDistance(String[] words, String word1, String word2) &#123; if(words==null || words.length==0) return 0; int min = words.length; int idx1 = -1, idx2 = -1; for(int i=0; i&lt;words.length; i++)&#123; if(words[i].equals(word1)) idx1 = i; if(words[i].equals(word2))&#123; if(word1.equals(word2)) // set idx1 to prev idx2 idx1 = idx2; idx2 = i; &#125; if(idx1 != -1 &amp;&amp; idx2 != -1)&#123; min = Math.min(min,Math.abs(idx1-idx2)); &#125; &#125; return min;&#125; quicker 12345678910111213141516171819202122232425262728public int shortestWordDistance(String[] words, String word1, String word2) &#123; if(words==null || words.length==0) return 0; int min = words.length; int idx1 = -1, idx2 = -1; if(word1.equals(word2))&#123; for(int i=0;i&lt;words.length;i++)&#123; if(words[i].equals(word1))&#123; if(idx1 == -1) idx1 = i; else&#123; min = Math.min(min,i-idx1); idx1 = i; &#125; &#125; &#125; &#125;else&#123; for(int i=0;i&lt;words.length;i++)&#123; if(words[i].equals(word1)) idx1 = i; else if(words[i].equals(word2)) idx2 = i; if(idx1!=-1 &amp;&amp; idx2!=-1) min = Math.min(min,Math.abs(idx1-idx2)); &#125; &#125; return min;&#125; #248-strobogrammatic-number-iii-hardA strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to count the total strobogrammatic numbers that exist in the range of low &lt;= num &lt;= high. Example: 123Input: low = &quot;50&quot;, high = &quot;100&quot;Output: 3 Explanation: 69, 88, and 96 are three strobogrammatic numbers. Note:Because the range might be a large number, the low and high numbers are represented as string. 12345678910111213141516171819202122232425262728293031323334public int strobogrammaticInRange(String low, String high) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i=low.length(); i&lt;=high.length(); i++)&#123; list.addAll(findStrobogrammatic(i)); &#125; int count = 0; for(String s : list)&#123; if(s.length()==low.length() &amp;&amp; s.compareTo(low)&lt;0 || s.length()==high.length() &amp;&amp; s.compareTo(high)&gt;0) continue; count ++; &#125; return count;&#125;public List&lt;String&gt; findStrobogrammatic(int n) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(n % 2 == 0) result = Arrays.asList(\"\"); else result = Arrays.asList(\"0\",\"1\",\"8\"); for(int i=(n%2)+2; i&lt;=n; i+=2)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(String s : result)&#123; if(i != n) list.add(\"0\" + s + \"0\"); list.add(\"1\" + s + \"1\"); list.add(\"8\" + s + \"8\"); list.add(\"6\" + s + \"9\"); list.add(\"9\" + s + \"6\"); &#125; result = list; &#125; return result;&#125; #253-meeting-rooms-ii-mediumGiven an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si &lt; ei), find the minimum number of conference rooms required. Example 1: 12Input: [[0, 30],[5, 10],[15, 20]]Output: 2 Example 2: 12Input: [[7,10],[2,4]]Output: 1 12345678910111213141516171819202122public int minMeetingRooms(Interval[] intervals) &#123; // seperate array of start and end then sort if(intervals == null || intervals.length == 0) return 0; int[] starts = new int[intervals.length]; int[] ends = new int[intervals.length]; for(int i=0; i&lt;intervals.length; i++)&#123; starts[i] = intervals[i].start; ends[i] = intervals[i].end; &#125; Arrays.sort(starts); Arrays.sort(ends); // if start &lt; end add room, else update end int count = 0, end = 0; for(int i=0; i&lt;starts.length; i++)&#123; if(starts[i] &lt; ends[end]) count ++; else end ++; &#125; return count;&#125; Greedy: 123456789101112131415161718192021222324 public int minMeetingRooms(Interval[] intervals) &#123; // greedy, sort on start first // then use heap on end time to track rooms if(intervals == null || intervals.length == 0) return 0; // sort start time and init end sorted heap Arrays.sort(intervals,(o1,o2)-&gt;o1.start-o2.start); PriorityQueue&lt;Interval&gt; heap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o1.end-o2.end);// start heap.offer(intervals[0]);Interval prev = intervals[0], curr = null;for (int i = 1; i &lt; intervals.length; i++) &#123; // find min end room, cannot use peek prev = heap.poll(); curr = intervals[i]; // can put in this min end room, update end time if(curr.start &gt;= prev.end) prev.end = curr.end; else // sign a new room heap.offer(curr); heap.offer(prev);&#125;return heap.size(); &#125; count max schedules 123456789101112131415public int maxSchedules(Interval[] intervals) &#123; if(intervals == null || intervals.length == 0) return 0; // sort on end time Arrays.sort(intervals, (o1,o2)-&gt;o1.end-o2.end); int count = 0; Interval prev = null; for(int i=0; i&lt;intervals.length; i++) &#123; if(prev == null || intervals[i].start&gt;=prev.end) &#123; count ++; prev = intervals[i]; &#125; &#125; return count;&#125; #263-ugly-number-easyWrite a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note: 1 is typically treated as an ugly number. Input is within the 32-bit signed integer range. 12345678910public boolean isUgly(int num) &#123; if(num == 0) return false; if(num == 1) return true; while(num % 2 == 0) num /= 2; while(num % 3 == 0) num /= 3; while(num % 5 == 0) num /= 5; return num == 1;&#125; #264-ugly-number-ii-mediumWrite a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly number, and n does not exceed 1690. The idea of this solution is from this page:http://www.geeksforgeeks.org/ugly-numbers/ 123456789101112131415161718public int nthUglyNumber(int n) &#123; // pointer for multi of 2,3,5 int i2 = 0, i3 = 0, i5 = 0; // dp int[] dp = new int[n]; dp[0] = 1; for(int i=1; i&lt;n; i++)&#123; int ugly = Math.min(dp[i5]*5, Math.min(dp[i2]*2, dp[i3]*3)); dp[i] = ugly; // check to increase pointer if(dp[i2]*2 == ugly) i2++; if(dp[i3]*3 == ugly) i3++; if(dp[i5]*5 == ugly) i5++; &#125; return dp[n-1];&#125; #268-missing-number-easyGiven an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: 12Input: [3,0,1]Output: 2 Example 2: 12Input: [9,6,4,2,3,5,7,0,1]Output: 8 1234567891011121314public int missingNumber(int[] nums) &#123; for(int i=0; i&lt;nums.length; i++)&#123; while(nums[i]!=nums.length &amp;&amp; nums[i]!=nums[nums[i]])&#123; int temp = nums[nums[i]]; nums[nums[i]] = nums[i]; nums[i] = temp; &#125; &#125; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i] != i) return i; &#125; return nums.length;&#125; #271-encode-and-decode-strings-mediumDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. 12345678910111213141516171819202122232425262728293031public class Codec &#123; // Encodes a list of strings to a single string. public String encode(List&lt;String&gt; strs) &#123; // count#str StringBuilder sb = new StringBuilder(); for(String str : strs)&#123; // append one by one sb.append(str.length() + \"#\" + str); &#125; return sb.toString(); &#125; // Decodes a single string to a list of strings. public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); int i = 0; while(i &lt; s.length())&#123; int j = i; while(s.charAt(j) != '#') j ++; int len = Integer.parseInt(s.substring(i,j)); result.add(s.substring(j+1,j+1+len)); i = j + 1 + len; &#125; return result; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.decode(codec.encode(strs)); num#len1#len2#12 1234567891011121314151617181920212223242526272829303132333435363738// Encodes a list of strings to a single string.public String encode(List&lt;String&gt; strs) &#123; StringBuilder sb = new StringBuilder(); sb.append(strs.size() + \"#\"); for(String str : strs) sb.append(str.length() + \"#\"); for(String str : strs) sb.append(str); return sb.toString();&#125;// Decodes a single string to a list of strings.public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); int head = 0, tail = 0; // find count while(tail&lt;s.length() &amp;&amp; s.charAt(tail)!='#') tail++; int count = Integer.parseInt(s.substring(head,tail)); int[] len = new int[count]; for(int i=0; i&lt;count; i++)&#123; head = tail + 1; tail = head; while(tail&lt;s.length() &amp;&amp; s.charAt(tail)!='#') tail++; len[i] = Integer.parseInt(s.substring(head,tail)); &#125; head = tail + 1; for(int i=0; i&lt;count; i++)&#123; if(head == s.length()) result.add(\"\"); else&#123; result.add(s.substring(head,head+len[i])); head += len[i]; &#125; &#125; return result;&#125; #272-closest-bst-value-ii-hardGiven a non-empty binary search tree and a target value, find k values in the BST that are closest to the target. Note: Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target. Example: 123456789Input: root = [4,2,5,1,3], target = 3.714286, and k = 2 4 / \\ 2 5 / \\1 3Output: [4,3] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) &#123; // use two stack, one for pre one for suc // 12345, 3,7 // =&gt; pres 1,2,3 // =&gt; succ 5,4 List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Stack&lt;Integer&gt; pres = new Stack&lt;&gt;(); Stack&lt;Integer&gt; sucs = new Stack&lt;&gt;(); // notice one of should have equal condition inorderPre(root,target,pres); inorderSuc(root,target,sucs); // then find k while(k-- &gt; 0)&#123; if(pres.isEmpty()) result.add(sucs.pop()); else if(sucs.isEmpty()) result.add(pres.pop()); else if(Math.abs(pres.peek()-target) &lt; Math.abs(sucs.peek()-target)) result.add(pres.pop()); else result.add(sucs.pop()); &#125; return result;&#125;private void inorderPre(TreeNode root, double target, Stack&lt;Integer&gt; pres)&#123; if(root == null) return; inorderPre(root.left, target, pres); // push all smaller pred, choose equal (or sucs equal) if(root.val &gt;= target) return; pres.push(root.val); inorderPre(root.right, target, pres);&#125;private void inorderSuc(TreeNode root, double target, Stack&lt;Integer&gt; sucs)&#123; // reverse inorder if(root == null) return; inorderSuc(root.right, target, sucs); // find all larger suc if(root.val &lt; target) return; sucs.push(root.val); inorderSuc(root.left, target, sucs);&#125; #279-perfect-squares-mediumGiven a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. 1234567891011121314151617public int numSquares(int n) &#123; // use dp check prev sum int[] dp = new int[n+1]; // dp iteration for(int i=1; i&lt;=n; i++)&#123; // for num i, check all squares // curr square + (i-square) int min = Integer.MAX_VALUE; for(int j=1; j*j&lt;=i; j++)&#123; // dp[j*j] is 1 // so population not needed min = Math.min(min, dp[i-j*j] + 1); &#125; dp[i] = min; &#125; return dp[n];&#125; #285-inorder-successor-in-bst-mediumGiven a binary search tree and a node in it, find the in-order successor of that node in the BST. Note: If the given node has no in-order successor in the tree, return null. recursion: 12345678910public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123; if(root == null) return root; // if root &lt;= p, just check right side if(root.val &lt;= p.val) return inorderSuccessor(root.right,p); // if root &gt; p, root is possible result TreeNode result = inorderSuccessor(root.left,p); return result == null? root : result;&#125; iteration: 1234567891011121314public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123; if(root == null) return root; // if root.val &gt; p, it's possible result TreeNode result = null; while(root != null)&#123; if(root.val &gt; p.val)&#123; result = root; root = root.left; &#125;else root = root.right; &#125; return result;&#125; predecessor: 123456789public TreeNode inorderPredecessor(TreeNode root, TreeNode p) &#123; if(root == null) return null; // if root.val &lt; p, possible result if(root.val &gt;= p) return inorderPredecessor(root.left,p); TreeNode result = inorderPredecessor(root.right,p); return result == null ? root : result;&#125; #287-find-duplicate-number-mediumGiven an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: 123Input: [1,3,4,2,2]Output: 2[2,2,2,2] 1234567891011121314public int findDuplicate(int[] nums) &#123; // find entrance of cycle int slow = nums[0], fast = nums[0]; do&#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125;while(slow != fast); int idx1 = nums[0], idx2 = slow; while(idx1 != idx2)&#123; idx1 = nums[idx1]; idx2 = nums[idx2]; &#125; return idx1;&#125; #297-encode-and-decode-binary-tree-hardSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. preorder bfs recursion 12345678910111213141516171819202122232425262728293031323334public class Codec &#123; // use preorder dfs // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); buildString(root,sb); return sb.toString(); &#125; private void buildString(TreeNode root,StringBuilder sb)&#123; if(root == null)&#123; sb.append(\"X\").append(\",\"); return; &#125; sb.append(root.val).append(\",\"); buildString(root.left,sb); buildString(root.right,sb); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.addAll(Arrays.asList(data.split(\",\"))); return buildTree(queue); &#125; private TreeNode buildTree(Queue&lt;String&gt; queue)&#123; String val = queue.poll(); if(val==null || val.equals(\"X\")) return null; TreeNode root = new TreeNode(Integer.parseInt(val)); root.left = buildTree(queue); root.right = buildTree(queue); return root; &#125;&#125; bfs iteration 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; if(root == null) return \"\"; StringBuilder sb = new StringBuilder(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); if(node == null)&#123; sb.append(\"X,\"); continue; &#125; sb.append(node.val+\",\"); queue.offer(node.left); queue.offer(node.right); &#125; return sb.toString(); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if(data==null || data.length()==0) return null; String[] values = data.split(\",\"); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); TreeNode root = new TreeNode(Integer.parseInt(values[0])); queue.offer(root); int idx = 1; while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); if(!values[idx].equals(\"X\"))&#123; node.left = new TreeNode(Integer.parseInt(values[idx])); queue.offer(node.left); &#125; idx++; if(!values[idx].equals(\"X\"))&#123; node.right = new TreeNode(Integer.parseInt(values[idx])); queue.offer(node.right); &#125; idx++; &#125; return root; &#125;&#125; #313-supper-ugly-number-mediumWrite a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4. Note:(1) 1 is a super ugly number for any given primes.(2) The given numbers in primes are in ascending order.(3) 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000.(4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer. 1234567891011121314151617181920212223242526public int nthSuperUglyNumber(int n, int[] primes) &#123; // use idea of ugly number ii // array to save result, first is 1 int[] nums = new int[n]; nums[0] = 1; // array to save index int[] idx = new int[primes.length]; for(int i=1; i&lt;n; i++)&#123; // find min to be curr ugly num int ugly = Integer.MAX_VALUE; for(int j=0; j&lt;idx.length; j++)&#123; // nums[idx for j] * primes[j] int candidate = primes[j] * nums[idx[j]]; ugly = Math.min(ugly,candidate); &#125; // set curr result nums[i] = ugly; // update index for all primes for(int j=0; j&lt;idx.length; j++)&#123; int prev = nums[idx[j]]; if(prev * primes[j] == ugly) idx[j] ++; &#125; &#125; return nums[n-1];&#125; #325-max-size-subarray-sum-equals-k-mediumGiven an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn’t one, return 0 instead. Note:The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range. Example 1: Given nums = [1, -1, 5, -2, 3], k = 3,return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest) Example 2: Given nums = [-2, -1, 2, 1], k = 1,return 2. (because the subarray [-1, 2] sums to 1 and is the longest) 12345678910111213141516public int maxSubArrayLen(int[] nums, int k) &#123; if(nums==null || nums.length==0) return 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int sum = 0, maxLen = 0; for(int i=0; i&lt;nums.length; i++)&#123; sum += nums[i]; if(sum == k) maxLen = i + 1; else if(map.containsKey(sum - k)) maxLen = Math.max(maxLen,i-map.get(sum-k)); if(!map.containsKey(sum)) map.put(sum,i); &#125; return maxLen;&#125; #335-self-crossing-hardYou are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not. Example 1: 1234567Given x = [2, 1, 1, 2],?????? ????????&gt; ?Return true (self crossing) Example 2: 12345678Given x = [1, 2, 3, 4],????????? ????????????????&gt;Return false (not self crossing) Example 3: 123456Given x = [1, 1, 1, 1],?????? ??????&gt;Return true (self crossing) 12345678910111213141516171819202122public boolean isSelfCrossing(int[] x) &#123; // i could cross with i-3, i-4, i-5 if(x==null || x.length&lt;=3) return false; // start from 3 for(int i=3; i&lt;x.length; i++)&#123; // check i &amp; i-3 // 7 4: 7&gt;=5, 6&gt;=4 if(x[i]&gt;=x[i-2] &amp;&amp; x[i-1]&lt;=x[i-3]) return true; // check i &amp; i-4 // 7 3: 7+3&gt;=5, 6==4 if(i&gt;=4 &amp;&amp; x[i]+x[i-4]&gt;=x[i-2] &amp;&amp; x[i-1]==x[i-3]) return true; // check i &amp; i-5 // 7 2: 7+3&gt;=5, 5&gt;=3, 6+2&gt;=4, 6&lt;=4 !(4&gt;=2) if(i&gt;=5 &amp;&amp; x[i]+x[i-4]&gt;=x[i-2] &amp;&amp; x[i-2]&gt;=x[i-4] &amp;&amp; x[i-1]+x[i-5]&gt;=x[i-3] &amp;&amp; x[i-1]&lt;=x[i-3]) return true; &#125; return false;&#125; #350-intersection-of-two-arrays-easyGiven two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. sort O(nlogn) 12345678910111213141516171819public int[] intersect(int[] nums1, int[] nums2) &#123; Arrays.sort(nums1); Arrays.sort(nums2); int idx1 = 0, idx2 = 0; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(idx1 &lt; nums1.length &amp;&amp; idx2 &lt; nums2.length)&#123; if(nums1[idx1] == nums2[idx2])&#123; list.add(nums1[idx1]); idx1++;idx2++; &#125;else if(nums1[idx1] &lt; nums2[idx2]) idx1 ++; else idx2 ++; &#125; int[] result = new int[list.size()]; for(int i=0; i&lt;result.length; i++) result[i] = list.get(i); return result;&#125; map count O(1) 123456789101112131415161718public int[] intersect(int[] nums1, int[] nums2) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); if(nums1.length &gt; nums2.length) return intersect(nums2,nums1); for(int num : nums1) map.put(num,map.getOrDefault(num,0)+1); for(int num : nums2)&#123; if(map.getOrDefault(num,0) != 0)&#123; list.add(num); map.put(num,map.get(num)-1); &#125; &#125; int[] result = new int[list.size()]; for(int i=0; i&lt;result.length; i++) result[i] = list.get(i); return result;&#125; #371-sum-of-two-integers-easyCalculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example:Given a = 1 and b = 2, return 3. Iteration: 12345678910public int getSum(int a, int b) &#123; int sum = a, carry = b; while(carry != 0)&#123; int nextSum = sum ^ carry; int nextCarry = (sum &amp; carry) &lt;&lt; 1; sum = nextSum; carry = nextCarry; &#125; return sum;&#125; Recursion: 1234567public int getSum(int a, int b) &#123; if(b == 0) return a; int sum = a ^ b; int carry = (a &amp; b) &lt;&lt; 1; return getSum(sum,carry);&#125; #373-find-k-pairs-with-smallest-sum-mediumYou are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums. Example 1: 123456Given nums1 = [1,7,11], nums2 = [2,4,6], k = 3Return: [1,2],[1,4],[1,6]The first 3 pairs are returned from the sequence:[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 123456789101112131415161718192021222324public List&lt;int[]&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; List&lt;int[]&gt; result = new ArrayList&lt;&gt;(); if(nums1.length==0 || nums2.length==0) return result; PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;&gt;(k,new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1,int[] o2)&#123; return o1[0] + o1[1] - o2[0] - o2[1]; &#125; &#125;); // populate first array first, curr[2] save index for(int i=0;i&lt;nums1.length &amp;&amp; i&lt;k;i++) heap.offer(new int[]&#123;nums1[i],nums2[0],0&#125;); while(!heap.isEmpty() &amp;&amp; result.size()&lt;k)&#123; int[] curr = heap.poll(); int n1 = curr[0], n2 = curr[1], idx2 = curr[2]; result.add(new int[]&#123;n1,n2&#125;); if(idx2 == nums2.length - 1) continue; heap.offer(new int[]&#123;n1,nums2[idx2+1],idx2+1&#125;); &#125; return result;&#125; #384-shuffle-an-array-mediumShuffle a set of numbers without duplicates. Example: 123456789101112// Init an array with set 1, 2, and 3.int[] nums = &#123;1,2,3&#125;;Solution solution = new Solution(nums);// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.solution.shuffle();// Resets the array back to its original configuration [1,2,3].solution.reset();// Returns the random shuffling of array [1,2,3].solution.shuffle(); 12345678910111213141516171819202122232425262728293031323334class Solution &#123; int[] nums = null; Random random; public Solution(int[] nums) &#123; this.nums = nums; random = new Random(); &#125; /** Resets the array to its original configuration and return it. */ public int[] reset() &#123; return nums; &#125; /** Returns a random shuffling of the array. */ public int[] shuffle() &#123; int[] copy = nums.clone(); // i is at i P = 1/i+1 // i is not at i P = 1-1/i+1 = i/i+1 // i at the other i P = 1/ i; // i at each location 0 to i is 1/i+1 for(int i=1;i&lt;copy.length;i++)&#123; // nextInt(a) a is exclusive int j = random.nextInt(i+1); swap(copy,i,j); &#125; return copy; &#125; private void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; #388-longest-absolute-file-path-mediumSuppose we abstract our file system by a string in the following manner: The string &quot;dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext&quot; represents: 1234dir subdir1 subdir2 file.ext The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string &quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext&quot; represents: 1234567dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.ext The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is &quot;dir/subdir2/subsubdir2/file2.ext&quot;, and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Note: The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a .. Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. 123456789101112131415161718192021222324252627public int lengthLongestPath(String input) &#123; // use stack, // for a level, stack saves only higher level len // if same level exit then pop if(input == null) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(0); // dummy bottom int maxLen = 0; // every \\n =&gt; a folder or a file for(String s : input.split(\"\\n\"))&#123; // define the level // first level -1+1=0, \\t=&gt;1, \\t\\t=&gt;2 int level = s.lastIndexOf(\"\\t\") + 1; // check whether stack has only higher level // l0=&gt;size 1,l1=&gt;size 2,l2=&gt;size 3 while(stack.size() &gt; level+1) // find parent stack.pop(); // push curr level len to stack, remove \\t, add / int len = stack.peek() + s.length() - level + 1; stack.push(len); // if it's a file, compute maxlen if(s.contains(\".\")) maxLen = Math.max(maxLen,len - 1); // remove / &#125; return maxLen;&#125; #406-queue-reconstruction-by-height-mediumSuppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note:The number of people is less than 1,100. Example 12345Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 123456789101112131415161718public int[][] reconstructQueue(int[][] people) &#123; // height decrease, count increase, insert if(people==null || people.length==0 || people[0].length==0) return people; Arrays.sort(people,new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] a,int[] b)&#123; if(a[0] != b[0]) // decrease return b[0] - a[0]; else // increase return a[1] - b[1]; &#125; &#125;); List&lt;int[]&gt; result = new LinkedList&lt;&gt;(); for(int[] p : people) result.add(p[1],p); return result.toArray(new int[people.length][2]);&#125; 419. Battleships in a Board (medium)Given an 2D board, count how many battleships are in it. The battleships are represented with &#39;X&#39;s, empty slots are represented with &#39;.&#39;s. You may assume the following rules: You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships. Example: 123X..X...X...X In the above board there are 2 battleships. Invalid Example: 123...XXXXX...X This is an invalid board that you will not receive - as battleships will always have a cell separating between them. 12345678910111213141516171819public int countBattleships(char[][] board) &#123; // idea only find ship head, left top cell if(board==null || board.length==0 || board[0].length==0) return 0; final int m = board.length, n = board[0].length; int count = 0; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(board[i][j] == '.') continue; if(i&gt;0 &amp;&amp; board[i-1][j] == 'X') continue; if(j&gt;0 &amp;&amp; board[i][j-1] == 'X') continue; count ++; &#125; &#125; return count;&#125; #443-string-compression-easyGiven an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array. Follow up:Could you solve it using only O(1) extra space? Example: 123456789Input:[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]Output:Return 4, and the first 4 characters of the input array should be: [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;].Explanation:Since the character &quot;a&quot; does not repeat, it is not compressed. &quot;bbbbbbbbbbbb&quot; is replaced by &quot;b12&quot;.Notice each digit has it&apos;s own entry in the array. Note: All characters have an ASCII value in [35, 126]. 1 &lt;= len(chars) &lt;= 1000. 12345678910111213141516171819202122public int compress(char[] chars) &#123; if(chars==null || chars.length==0) return 0; // start for result tail, end for curr int start = 0, end = 0; while(end &lt; chars.length)&#123; char curr = chars[end]; int count = 1; // count same char while(end&lt;chars.length-1 &amp;&amp; chars[end]==chars[end+1])&#123; count ++; end ++; &#125; // put curr char down chars[start++] = chars[end++]; // then add count if(count != 1) for(char c : String.valueOf(count).toCharArray()) chars[start++] = c; &#125; return start;&#125; #448-find-all-disappeared-number-easyGiven an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: 12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] 12345678910111213141516public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); // 2 passes // 1 pass to set negative for(int num : nums)&#123; int index = Math.abs(num) - 1; if(nums[index] &gt; 0) nums[index] *= -1; &#125; // second pass find positive index for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i] &gt; 0) result.add(i+1); &#125; return result;&#125; #463-island-perimeter-easyExample: 1234567[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: 123456789101112131415161718192021public int islandPerimeter(int[][] grid) &#123; if(grid==null || grid.length==0 || grid[0].length==0) return 0; final int row = grid.length; final int col = grid[0].length; int count = 0; for(int i=0; i&lt;row; i++)&#123; for(int j=0; j&lt;col; j++)&#123; if(grid[i][j] == 0) continue; // check up and left, if nei is 1, remove edge count += 4; // default 4 added first // -2 : two block double edge remove if(i &gt; 0 &amp;&amp; grid[i-1][j] == 1) count -= 2; if(j &gt; 0 &amp;&amp; grid[i][j-1] == 1) count -= 2; &#125; &#125; return count;&#125; #476-number-complement-easyGiven a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. Example 1: 123Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2: 123Input: 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. 1234567public int findComplement(int num) &#123; // use 11111 - num int n = 1; while(n &lt; num) n = n &lt;&lt; 1 | 1; return n - num;&#125; #500-keyboard-row-easyGiven a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. Example 1: 12Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] Note: You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet. 123456789101112131415161718192021222324public String[] findWords(String[] words) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(words==null || words.length==0) return result.toArray(new String[0]); // build map String[] rows = &#123;\"QWERTYUIOP\",\"ASDFGHJKL\",\"ZXCVBNM\"&#125;; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;rows.length;i++) for(char c : rows[i].toCharArray()) map.put(c,i); // add to result WORDS: for(String word : words)&#123; if(word.equals(\"\")) continue; int idx = map.get(Character.toUpperCase(word.charAt(0))); for(int i=1;i&lt;word.length();i++)&#123; if(map.get(Character.toUpperCase(word.charAt(i))) != idx) continue WORDS; &#125; result.add(word); &#125; return result.toArray(new String[result.size()]);&#125; 123456789101112public String[] findWords(String[] words) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(words==null || words.length==0) return result.toArray(new String[0]); String regex = \"[QWERTYUIOP]*|[ASDFGHJKL]*|[ZXCVBNM]*\"; for(String word : words)&#123; if(word.toUpperCase().matches(regex))&#123; result.add(word); &#125; &#125; return result.toArray(new String[result.size()]);&#125; #516-longest-palindromic-subsequence-mediumGiven a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000. Example 1:Input: 1&quot;bbbab&quot; Output: 14 One possible longest palindromic subsequence is “bbbb”. 12345678910111213141516public int longestPalindromeSubseq(String s) &#123; int[][] dp = new int[s.length()][s.length()]; // row need to bottom up, to make i+1 available for(int i=s.length()-1; i&gt;=0; i--)&#123; dp[i][i] = 1; for(int j=i+1; j&lt;s.length(); j++)&#123; // head + tail + len(head to tail) // 2 + dp[i+1][j-1] if(s.charAt(i) == s.charAt(j)) dp[i][j] = 2 + dp[i+1][j-1]; else // [i-1][j] or [i][j-1] dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]); &#125; &#125; return dp[0][s.length()-1];&#125; #560-subarray-sum-equals-k-mediumGiven an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: 12Input:nums = [1,1,1], k = 2Output: 2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. 1234567891011121314public int subarraySum(int[] nums, int k) &#123; if(nums==null || nums.length==0) return 0; // use map to save curr sum &amp; count Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); // int count = 0, sum = 0; for(int num : nums)&#123; sum += num; count += map.getOrDefault(sum-k,0); map.put(sum,map.getOrDefault(sum,0)+1); &#125; return count;&#125; #604-compressed-string-iterator-easyDesign and implement a data structure for a compressed string iterator. It should support the following operations: next and hasNext. The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string. next() - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.hasNext() - Judge whether there is any letter needs to be uncompressed. Note:Please remember to RESET your class variables declared in StringIterator, as static/class variables are persisted across multiple test cases. Please see here for more details. Example: 12345678910111213StringIterator iterator = new StringIterator(&quot;L1e2t1C1o1d1e1&quot;);iterator.next(); // return &apos;L&apos;iterator.next(); // return &apos;e&apos;iterator.next(); // return &apos;e&apos;iterator.next(); // return &apos;t&apos;iterator.next(); // return &apos;C&apos;iterator.next(); // return &apos;o&apos;iterator.next(); // return &apos;d&apos;iterator.hasNext(); // return trueiterator.next(); // return &apos;e&apos;iterator.hasNext(); // return falseiterator.next(); // return &apos; &apos; 123456789101112131415161718192021222324252627282930313233343536class StringIterator &#123; // use int[2] save char, count // use queue Queue&lt;int[]&gt; queue; public StringIterator(String compressedString) &#123; queue = new LinkedList&lt;&gt;(); int len = compressedString.length(); for(int i=0; i&lt;len;)&#123; int[] pair = new int[2]; pair[0] = compressedString.charAt(i); int j = i + 1; // num is before letters String cnt = \"\"; while(j&lt;len &amp;&amp; compressedString.charAt(j)&lt;'A')&#123; cnt += compressedString.charAt(j); j ++; &#125; pair[1] = Integer.parseInt(cnt); queue.offer(pair); i = j; &#125; &#125; public char next() &#123; if(queue.isEmpty()) return ' '; int[] pair = queue.peek(); if(--pair[1] == 0) queue.poll(); return (char) pair[0]; &#125; public boolean hasNext() &#123; return !queue.isEmpty(); &#125;&#125; #625-minimun-factorization-mediumGiven a positive integer a, find the smallest positive integer b whose multiplication of each digit equals to a. If there is no answer or the answer is not fit in 32-bit signed integer, then return 0. Example 1Input: 148 Output: 168 123456789101112131415161718public int smallestFactorization(int a) &#123; if(a &lt; 9) return a; // try larger first long result = 0, multi = 1; for(int i=9; i&gt;=2; i--)&#123; while(a % i == 0)&#123; a /= i; result += multi * i; if(result &gt; Integer.MAX_VALUE) return 0; multi *= 10; &#125; &#125; if(a != 1) return 0; return (int) result;&#125; #632-smallest-range-hardYou have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the klists. We define the range [a,b] is smaller than range [c,d] if b-a &lt; d-c or a &lt; c if b-a == d-c. Example 1: 123456Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]Output: [20,24]Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24].List 2: [0, 9, 12, 20], 20 is in range [20,24].List 3: [5, 18, 22, 30], 22 is in range [20,24]. 1234567891011121314151617181920212223242526272829303132333435363738public int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123; // use heap similar to merge k sorted list // maintain a max, when poll a min, update result, offer its next if(nums == null || nums.size() == 0) return new int[0]; // use int[3] save: &#123;row,idx,val&#125; PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1,int[] o2)&#123; return o1[2] - o2[2]; &#125; &#125;); int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE; int minRange = Integer.MAX_VALUE; int[] result = new int[2]; // init max and heap use first col for(int row=0; row&lt;nums.size(); row++)&#123; int value = nums.get(row).get(0); max = Math.max(max,value); heap.offer(new int[]&#123;row,0,value&#125;); &#125; // start, condition: heap size while(heap.size() == nums.size())&#123; int[] curr = heap.poll(); // update result if(max - curr[2] &lt; minRange)&#123; minRange = max - curr[2]; result = new int[]&#123;curr[2],max&#125;; &#125; // offer min's next, update max if(curr[1] + 1 &lt; nums.get(curr[0]).size())&#123; int next = nums.get(curr[0]).get(curr[1]+1); max = Math.max(max,next); heap.offer(new int[]&#123;curr[0],curr[1]+1,next&#125;); &#125; &#125; return result;&#125; #809-expressive-word-mediumSometimes people repeat letters to represent extra feeling, such as “hello” -&gt; “heeellooo”, “hi” -&gt; “hiiii”. Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different. A group is extended if that group is length 3 or more, so “e” and “o” would be extended in the first example, and “i” would be extended in the second example. As another example, the groups of “abbcccaaaa” would be “a”, “bb”, “ccc”, and “aaaa”; and “ccc” and “aaaa” are the extended groups of that string. For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups. Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more. Note that we cannot extend a group of size one like “h” to a group of size two like “hh” - all extensions must leave the group extended - ie., at least 3 characters long. Given a list of query words, return the number of words that are stretchy. 12345678Example:Input: S = &quot;heeellooo&quot;words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]Output: 1Explanation: We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.We can&apos;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not extended. 123456789101112131415161718192021222324252627public int expressiveWords(String S, String[] words) &#123; if(S==null || S.length()==0 || words==null || words.length==0) return 0; int count = 0; for(String word : words)&#123; // i for S &lt;= j for word int i = 0, j = 0; while(i &lt; S.length())&#123; // S.char == word.char, keep going if(j&lt;word.length() &amp;&amp; S.charAt(i)==word.charAt(j))&#123; i++; j++; // check S.char is extend? &#125;else if(i&gt;0 &amp;&amp; S.charAt(i)==S.charAt(i-1) &amp;&amp; i&lt;S.length()-1 &amp;&amp; S.charAt(i)==S.charAt(i+1))&#123; i += 2; // check S when j reach word tail &#125;else if(i&gt;1 &amp;&amp; S.charAt(i)==S.charAt(i-1) &amp;&amp; S.charAt(i)==S.charAt(i-2))&#123; i++; &#125;else break; if(i==S.length() &amp;&amp; j==word.length()) count++; &#125; &#125; return count;&#125; #814-binary-tree-pruning-mediumWe are given the head node root of a binary tree, where additionally every node’s value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) 1234567891011public TreeNode pruneTree(TreeNode root) &#123; // can use no helper if(root == null) return root; root.left = pruneTree(root.left); root.right = pruneTree(root.right); // post order if(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==0) return null; return root;&#125; #817-linked-list-components-mediumWe are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1: 123456Input: head: 0-&gt;1-&gt;2-&gt;3G = [0, 1, 3]Output: 2Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components. Example 2: 123456Input: head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4]Output: 2Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. Note: If N is the length of the linked list given by head, 1 &lt;= N &lt;= 10000. The value of each node in the linked list will be in the range[0, N - 1]. 1 &lt;= G.length &lt;= 10000. G is a subset of all values in the linked list. 1234567891011121314151617public int numComponents(ListNode head, int[] G) &#123; // use set, count tail of components Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num : G) set.add(num); int count = 0; while(head != null)&#123; // if contains curr: // 1. this is end // 2. not contain next (tail) if(set.contains(head.val) &amp;&amp; (head.next==null || !set.contains(head.next.val))) count ++; head = head.next; &#125; return count;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jliao011.github.io/categories/leetcode/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-05-27T07:11:14.000Z","updated":"2018-05-27T12:41:27.000Z","comments":true,"path":"2018/05/27/hello-world/","link":"","permalink":"https://jliao011.github.io/2018/05/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}