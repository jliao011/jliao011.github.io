{"meta":{"title":"My Blog","subtitle":null,"description":"Jiafeng Liao's Blog","author":"Jiafeng Liao","url":"https://jliao011.github.io"},"pages":[{"title":"404 Not Found...","date":"2018-05-27T14:29:14.000Z","updated":"2018-05-27T14:29:14.000Z","comments":false,"path":"/404.html","permalink":"https://jliao011.github.io//404.html","excerpt":"","text":""},{"title":"Categories","date":"2018-05-27T11:28:23.000Z","updated":"2018-05-27T09:16:46.000Z","comments":false,"path":"categories/index.html","permalink":"https://jliao011.github.io/categories/index.html","excerpt":"","text":""},{"title":"About Me","date":"2018-06-06T19:39:12.000Z","updated":"2018-06-06T19:39:12.000Z","comments":false,"path":"about/index.html","permalink":"https://jliao011.github.io/about/index.html","excerpt":"","text":"NEW M.S. CS Grad (May 2018) from the University of Texas at Dallas and actively seeking a full-time SOFTWARE ENGINEER position. Summery: Solid computer science foundation from course works and internship (BNSF Railway). Passion in cutting edge technologies and learning new skills. Quick learner and able to understand and pick up new technologies during hands-on projects. Ability to explore vast resources and be a problem solver. Detail-oriented and willing to try various approaches to achieve optimal results. Skill Set: Languages: Java, Python, C/C++, Scala Databases: SQL, JPQL, MySQL, PostgreSQL, MongoDB Back-end skills: Spring Frameworks, Hibernate, JPA, JDBC, ORM, Thymeleaf, RESTful web service, PHP Front-end skills: HTML5/CSS3/JavaScript, jQuery, AJAX, BootStrap, JSON/YAML/XML, Markdown Frameworks: SLF4j/Log4j, Spring Boot/MVC/Data/Security/Mail, Hadoop, Spark, Kafka, Swing Tools &amp; OS: Eclipse, MatLab, MAMP, OpenCV, Mac/Linux Shell script, Windows Manage &amp; Deploy: Git, Maven, Gradle, Heroku Experience:Knowledge in Core Java concepts such as OOP concepts, Collections, Exception handling, Multi-Threading, Concurrency, Socket. Knowledge and hands-on experience in Spring frameworks like Spring Boot, Spring Data, Spring MVC with Thymeleaf template engine, Spring Security and Spring Mail. Understanding of Data Access Layer technologies such as Object Relational Mapping (ORM), Java Persistence Interface (JPA), Data Access Object (DAO) implementation, DB interaction using JPQL or Spring Data repositories. Familiar with RESTful web service, MVC pattern and micro service architecture. Knowledge and experience in Relational Database design (MySQL, PostgreSQL) and familiar with Non-relational Database (MongoDB). Hands-on experience in source code management using Git, application building using Maven, logging framework SFL4j with Log4j and deployment using Heroku. Hands-on experience in front end and data transfer techniques such as HTML5/CSS3/JavaScript, jQuery, BootStrap, AJAX, XML/JSON. Hands-on experience and knowledge in Big Data technologies such as Hadoop, Spark, Kafka, MapReduce. Familiar with Machine Learning concepts such as SVM with slack/dual/kernel, Decision Tree, Random Forest, K-Mean, AdaBoost, Gaussian Mixture Models with EM, Bayesian Network, Neural Network, etc."},{"title":"Repositories","date":"2018-05-27T11:28:23.000Z","updated":"2018-05-27T10:07:31.000Z","comments":false,"path":"repository/index.html","permalink":"https://jliao011.github.io/repository/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-27T11:28:23.000Z","updated":"2018-05-27T09:17:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://jliao011.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Top K Frequent Element","slug":"top-k-frequent-element","date":"2018-07-10T21:13:23.000Z","updated":"2018-07-10T22:42:47.000Z","comments":true,"path":"2018/07/10/top-k-frequent-element/","link":"","permalink":"https://jliao011.github.io/2018/07/10/top-k-frequent-element/","excerpt":"","text":"Leetcode 347. Top K Frequent ElementsGiven a non-empty array of integers, return the k most frequent elements. For example,Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size. Assume n element m distinct element f is largest frequency Method 1. sort Entry:Time O(n + mlogm + klogm) Space O(m + k) 12345678910111213 public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int num : nums)&#123; map.put(num,map.getOrDefault(num,0)+1); &#125;PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; heap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2.getValue() - o1.getValue()); for(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet()) heap.offer(entry); while(k-- &gt; 0) result.add(heap.poll().getKey()); return result; &#125; Method 2. bucket sort:Time O(n + k) = O(n) Space O(n + k) Optimize: if find the max frequency f, Space complexity is O(f + k) 12345678910111213141516171819202122public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int num : nums)&#123; map.put(num,map.getOrDefault(num,0)+1); &#125; List&lt;Integer&gt;[] buckets = new List[nums.length+1]; for(Integer key : map.keySet())&#123; int count = map.get(key); if(buckets[count] == null) buckets[count] = new ArrayList&lt;&gt;(); buckets[count].add(key); &#125; for(int i=buckets.length-1; i&gt;=0 &amp;&amp; k&gt;0; --i)&#123; if(buckets[i] != null) for(int val : buckets[i])&#123; result.add(val); k--; &#125; &#125; return result;&#125; Method 3. build heap in O(m)Time O(n + m + klogk) Space O(m + k) Build map -&gt; build heap from entry collection -&gt; pop top k Method 4. min heap size kTime O(n + k + (m-k)logk + klogk) Space O(m + k) Build map -&gt; build heap size k in O(k) -&gt; iterate over the rest -&gt; pop k result Method 3. tree map:Time O(n + mlogm + klogm ) Space O(m + k) 12345678910111213141516171819202122 public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int num : nums)&#123; map.put(num,map.getOrDefault(num,0)+1); &#125;TreeMap&lt;Integer,List&lt;Integer&gt;&gt; treeMap = new TreeMap&lt;&gt;(); for(int key : map.keySet())&#123; int freq = map.get(key); List&lt;Integer&gt; list = treeMap.get(freq); if(list == null)&#123; list = new ArrayList&lt;&gt;(); treeMap.put(freq,list); &#125; list.add(key); &#125; while(result.size() &lt; k)&#123; // notice (k-- &gt; 0) wrong Map.Entry&lt;Integer,List&lt;Integer&gt;&gt; entry = treeMap.pollLastEntry(); result.addAll(entry.getValue()); &#125; return result; &#125; Leetcode 692. Top K Frequent WordsGiven a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Example 1: 1234Input: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2Output: [&quot;i&quot;, &quot;love&quot;]Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words. Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order. Example 2: 1234Input: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4Output: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]Explanation: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively. Assume n element m distinct element Method 1. sort entry using heap:Time O(n + mlogm + klogm ) Space O(m) 12345678910111213141516171819 public List&lt;String&gt; topKFrequent(String[] words, int k) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for(String word : words) map.put(word,map.getOrDefault(word,0)+1); PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()&#123;@Overridepublic int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) &#123; if(o1.getValue() != o2.getValue()) return o2.getValue() - o1.getValue(); return o1.getKey().compareTo(o2.getKey());&#125; &#125;); for(Map.Entry&lt;String,Integer&gt; entry : map.entrySet()) heap.offer(entry); while(k-- &gt; 0) result.add(heap.poll().getKey()); return result; &#125; Method 2. better heap (use min heap instead of max heap):Time O(n + mlogk + klogk) Space O(m + k) 1234567891011121314151617181920212223 public List&lt;String&gt; topKFrequent(String[] words, int k) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for(String word : words) map.put(word,map.getOrDefault(word,0)+1); PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()&#123;@Overridepublic int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) &#123; if(o1.getValue() != o2.getValue()) return o1.getValue() - o2.getValue(); return o2.getKey().compareTo(o1.getKey());&#125; &#125;); for(Map.Entry&lt;String,Integer&gt; entry : map.entrySet())&#123; heap.offer(entry); if(heap.size() &gt; k) heap.poll(); &#125; while(!heap.isEmpty()) result.add(heap.poll().getKey()); Collections.reverse(result); return result; &#125; Method 3. bucket sort:Time O(n + m + nlogn) worst Space O(n + m) 12345678910111213141516171819202122public List&lt;String&gt; topKFrequent(String[] words, int k) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for(String word : words) map.put(word,map.getOrDefault(word,0)+1); List&lt;String&gt;[] buckets = new List[words.length+1]; for(String key : map.keySet())&#123; int freq = map.get(key); if(buckets[freq] == null) buckets[freq] = new ArrayList&lt;&gt;(); buckets[freq].add(key); &#125; for(int i=buckets.length-1; i&gt;=0 &amp;&amp; result.size()&lt;k; --i)&#123; List&lt;String&gt; list = buckets[i]; if(list != null)&#123; Collections.sort(list); for(int j=0; j&lt;list.size() &amp;&amp; result.size()&lt;k; ++j) result.add(list.get(j)); &#125; &#125; return result;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://jliao011.github.io/categories/algorithm/"}],"tags":[{"name":"sort","slug":"sort","permalink":"https://jliao011.github.io/tags/sort/"}]},{"title":"Top k largest(smallest) in n elements","slug":"top-k","date":"2018-07-09T03:43:52.000Z","updated":"2018-07-10T23:02:28.000Z","comments":true,"path":"2018/07/08/top-k/","link":"","permalink":"https://jliao011.github.io/2018/07/08/top-k/","excerpt":"","text":"QuestionGiven an unsorted array of length N, find top k largest (smallest) elements. k&lt;&lt;N. Methodsmethod 1. sorting:Sort the array, pick first k elements. Time complexity O(NlogN). Since N is large so it’s not efficient enough. Time O(NlogN), Space O(k) 1234567public static int[] topK(int[] nums, int k) &#123; int[] result = new int[k]; Arrays.sort(nums); for (int i = 0; i &lt; k; ++i) result[i] = nums[nums.length - 1 - i]; return result;&#125; method 2. k bubble sort:Run bubble sort for k times. Since bubble sort could move the largest (smallest) element to one end of the array, run the outer loop for k times could find the top k largest or smallest element. Each inner loop the time complexity is O(N), and run for k loops, so the total time complexity is O(kN). Compare to method 1, if k is less than logN then this method is better. Time O(kN), Space O(k) 123456789101112131415public static int[] topK(int[] nums, int k) &#123; int[] result = new int[k]; for (int i = 0; i &lt; k; ++i) &#123; // k loops for (int j = nums.length - 1; j &gt; 0; --j) &#123; if (nums[j] &gt; nums[j - 1]) &#123; // swap int temp = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; k; ++i) result[i] = nums[i]; return result;&#125; method 3. arbitrary k temp result:Build a temporary result (find largest k) Store first k element in a list. Find the smallest element in this list O(k) Traverse the rest element O(N-k), if it’s larger than the smallest element in first k, remove the previous smallest, add the current, and find the smallest again O(k) Return the result, Time complexity: O((N-k)k), if output is sorted: O((N-k)k + klogk). Space O(k). 12345678910111213141516171819202122232425public static int[] topK(int[] nums, int k) &#123; int[] result = new int[k]; int min = Integer.MAX_VALUE, minIdx = 0; for (int i = 0; i &lt; k; ++i) &#123; result[i] = nums[i]; if (nums[i] &lt; min) &#123; min = nums[i]; minIdx = i; &#125; &#125; for (int i = k; i &lt; nums.length; ++i) &#123; if (nums[i] &gt; min) &#123; result[minIdx] = nums[i]; min = nums[i]; &#125; for (int j = 0; j &lt; k; ++j) &#123; if (result[j] &lt; min) &#123; min = result[j]; minIdx = j; &#125; &#125; &#125; Arrays.sort(result); return result;&#125; method 4. max heap to find top k: Build heap from collection takes O(N), explain later. Poll from the max heap k times, each time takes O(logN) Return the result, Time O(N + klogN), Space O(N). If k &lt; N/logN, then the runtime is proximately O(N). Time complexity of heap:In java PriorityQueue class, the heap initialized from a collection: 123456789private void initFromCollection(Collection&lt;? extends E&gt; c) &#123; initElementsFromCollection(c); heapify();&#125;private void heapify() &#123; for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]);&#125; siftDown method takes logn time, seems the time complexity is O(n/2 * logn). But for a heap tree, assume the depth is h, total number of node n = 2^h-1, number of leaves 2^(h-1), approximately n/2 nodes, since when doing the heapify, leaves are not considered, the siftDown is called from its above level, which has 2^(h-2)= n/4 nodes. At this level, if every node is sifted down, the total call is 1 * n/4. Above this level, there are n/8 nodes, and each node would be sifted down at most 2 levels, so total call is 2 * n/8……… So while doing the heapify function, the total call is 1*n/4 + 2*n/8 + 3*n/16 + ... + logn*n/2^(logn+1) = n*(1/4+2/8+3/16+...+h/2^(h-1)) &lt;= 2n, so the time complexity is O(n). If insert into heap one by one, the time complexity should be O(nlogn). Implementation: Java PriorityQueue doesn’t allow to init like new PriorityQueue&lt;&gt;(Collection,Comparator) 1234567891011public static int[] topK(int[] nums, int k) &#123; int[] result = new int[k]; List&lt;Integer&gt; collection = new ArrayList&lt;&gt;(); for (int num : nums) collection.add(num); // cannot init using another comparator, so return min K PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(collection); for (int i = 0; i &lt; k; ++i) result[i] = heap.poll(); return result;&#125; visualization references: https://www.quora.com/Does-Javas-PriorityQueue-constructor-with-a-collection-build-a-heap-in-linear-time https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity https://www.geeksforgeeks.org/time-complexity-of-building-a-heap/ method 5. min heap to find max top k: Init a min heap using first k element in time O(k) Traverse the rest in time O(n-k) If element is less than top of min heap, ignore. O(1) If element is larger than top of min heap, poll the top and offer current. O(logk) Finally element in the min heap are max top k. Time complexity O(k + (n-k)logk). Compared to method 4, which could reach O(n), this method is larger than O(n). 1234567891011121314151617public static int[] topK(int[] nums, int k) &#123; int[] result = new int[k]; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; k; ++i) list.add(nums[i]); // min heap to find top k PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(list); for (int i = k; i &lt; nums.length; ++i) &#123; if (nums[i] &gt; heap.peek()) &#123; heap.poll(); heap.offer(nums[i]); &#125; &#125; for (int i = 0; i &lt; k; ++i) result[i] = heap.poll(); return result;&#125; Another method using heap: (if cannot use size k collection to build max heap when find min k) Init a max heap Add element to heap, if size larger than k, pop Time O(nlogk) Space O(k) 12345678910111213public static int[] minK(int[] nums, int k) &#123; int[] result = new int[k]; // max heap to find min k PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k, Collections.reverseOrder()); for (int i = 0; i &lt; nums.length; ++i) &#123; heap.offer(nums[i]); if (heap.size() &gt; k) heap.poll(); &#125; for (int i = k - 1; i &gt;= 0; --i) result[i] = heap.poll(); return result;&#125; method 6. quick select: Use quick select method to find the kth largest element, then right side of kth element are all larger than k. Time complexity O(n). If sorted result, then Time complexity is O(n + klogk). 1234567891011121314151617181920212223242526272829303132333435public static int[] topK(int[] nums, int k) &#123; int[] result = new int[k]; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int pivot = partition(nums, left, right); if (pivot == k - 1) break; else if (pivot &lt; k - 1) left = pivot + 1; else right = pivot - 1; &#125; for (int i = 0; i &lt; k; ++i) result[i] = nums[i]; Arrays.sort(result); return result;&#125;private static int partition(int[] nums, int left, int right) &#123; int mid = left + (right - left) / 2; swap(nums, mid, right); int pivot = left - 1; for (int i = left; i &lt; right; ++i) &#123; if (nums[i] &gt;= nums[right]) swap(nums, ++pivot, i); &#125; swap(nums, ++pivot, right); return pivot;&#125;private static void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; Problems: There are total n people, allocate k of n to place A, and the rest to place B. Given a int[2] like [300,500], represent that the relocation fee to A is 300 and to B is 500. Calculate the min cost for allocation. This could be a problem of find min k question. Said tuple = [300,500] is the cost for one person. Then tuple[0] is the fee to A, tuple[1] is the fee to B. Assume allocate this person to A, the cost is tuple[0] == 300, then the difference tuple[0] - tuple[1] is how much the cost increase if we move this person from B to A. If it’s negative means that keeps this person in A will decrease the cost. If we sorted the input list based on the difference (o1,o2) -&gt;((o1[1]-o1[2])-(o2[1]-o2[2])), we could get the result. Assume we put arbitrary k people to A, then how to minimize the cost? We move people from A to B, whose cost decrease tuple[0]-tuple[1] is the largest. After we find the first k min tuple, they should at A, the rest at B. Sort: time complexity O(nlogn) space O(1) 123456789public static int minCost(int[][] person, int k) &#123; int cost = 0; Arrays.sort(person, (o1, o2) -&gt; ((o1[0] - o1[1]) - (o2[0] - o2[1]))); for (int i = 0; i &lt; k; ++i) cost += person[i][0]; for (int i = k; i &lt; person.length; ++i) cost += person[i][1]; return cost;&#125; Max heap to get min k: Assume put k person to A, then check rest n-k person, if the cost drops larger, move it to A, poll the top move to B. Time complexity: build max heap size k O(klogk) from scratch, check and poll top O((n-k)logk) Total is O(nlogk) If could build max heap from collection, time is O(k), and traverse rest n-k is O((n-k)logk), total is O(k + (n-k)logk) will be better. 123456789101112131415161718192021222324252627public static int minCost(int[][] person, int k) &#123; int cost = 0; PriorityQueue&lt;int[]&gt; maxHeap = new PriorityQueue&lt;&gt;(k, new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; return (o2[0] - o2[1]) - (o1[0] - o1[1]); &#125; &#125;); for (int[] p : person) &#123; if (maxHeap.size() &lt; k) &#123; // allocate first k to A maxHeap.offer(p); cost += p[0]; &#125; else &#123; // for rest in B cost += p[1]; // to B first int[] top = maxHeap.peek(); if (p[0] - p[1] &lt; top[0] - top[1]) &#123; // cost decrease if move top to B cost += -top[0] + top[1]; maxHeap.poll(); maxHeap.offer(p); cost += p[0] - p[1]; &#125; &#125; &#125; return cost;&#125; References:http://www.ardendertat.com/2011/05/30/my-favorite-interview-question/ https://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://jliao011.github.io/categories/algorithm/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://jliao011.github.io/tags/heap/"}]},{"title":"Greatest Common Divisor","slug":"gcd","date":"2018-06-25T07:59:52.000Z","updated":"2018-07-10T03:29:36.000Z","comments":true,"path":"2018/06/25/gcd/","link":"","permalink":"https://jliao011.github.io/2018/06/25/gcd/","excerpt":"","text":"GCD of 2 integerrecursive call: put smaller number first 12345public int gcd(int a, int b)&#123; if (a == 0) return b; return gcd(b % a, a);&#125; example: gcd(12,18)=&gt; gcd(6,12)=&gt;gcd(0,6)=&gt;6 gcd(8,2)=&gt;gcd(2,8)=&gt;gcd(0,2)=&gt;2 GCD of an int array123gcd(a, b, c) = gcd(a, gcd(b, c)) = gcd(gcd(a, b), c) = gcd(gcd(a, c), b) assume valid input, no 0s 123456public int gcd(int[] nums) &#123; int result = nums[0]; for (int i = 1; i &lt; nums.length; ++i) result = gcd(result, nums[i]); return result;&#125; Question:can reach: Given 2 points (x1,y1), (x2,y2), determine whether point1 can move to point2. Assume Rules: (x1,y1) =&gt; (x1+y1,y1) or (x1,y1) =&gt; (x1,y1+x1) first thought (TLE) 1234567public boolean canReach(int x1,int y1,int x2,int y2) &#123; if(x1 &gt; x2 || y1 &gt; y2) return false; if(x1 == x2 &amp;&amp; y1 == y2) return true; return canReach(x1+y1, y1, x2, y2) || canReach(x1, y1+x1, x2, y2);&#125; from point2 to point1 would be better 1234567public boolean canReach(int x1,int y1,int x2,int y2) &#123; if(x1 &gt; x2 || y1 &gt; y2) return false; if(x1 == x2 &amp;&amp; y1 == y2) return true; return canReach(x1, y1, x2-y2, y2) || canReach(x1, y1, x2, y2-x2);&#125; optimize in path 123456789101112131415public boolean canReach(int x1, int y1, int x2, int y2) &#123; if (x1 &gt; x2 || y1 &gt; y2) return false; if (x1 == x2 &amp;&amp; y1 == y2) return true; if (x1 == x2 || y1 == y2) &#123; if (x1 == x2 &amp;&amp; (y2 - y1) % x1 == 0) return true; else if (y1 == y2 &amp;&amp; (x2 - x1) % y1 == 0) return true; else return false; &#125; return canReach(x1, y1, x2 - y2, y2) || canReach(x1, y1, x2, y2 - x2);&#125; GCD According to the definition of Greatest Common Divisior, if m is any integer, then gcd(a + m * b, b) = gcd(a, b). Therefore, the gcd of (a + b, b), (a, a + b), (a - b, b) and (a, a - b) will be the same as the gcd of (a, b). Therefore, in order to move to the target point, the gcd of the target point should be equal to the gcd of the starting point. 123public boolean canReach(int x1, int y1, int x2, int y2) &#123; return gcd(x1, y1)== gcd(x2, y2); &#125; Leetcode 149. Max points on a line Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a point. * class Point &#123; * int x; * int y; * Point() &#123; x = 0; y = 0; &#125; * Point(int a, int b) &#123; x = a; y = b; &#125; * &#125; */class Solution &#123; public int maxPoints(Point[] points) &#123; // use O(n^2) to find all pair, store slope as key if(points == null) return 0; int result = 0; // map: slope as key, count as val Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); // loop over all points for(int i=0; i&lt;points.length; ++i)&#123; // check all lines with i and j // find max point on a line except i and overlap int max = 0, overlap = 0; map.clear(); for(int j=i+1; j&lt;points.length; ++j)&#123; // x,y pair as slope int x = points[j].x - points[i].x; int y = points[j].y - points[i].y; if(x == 0 &amp;&amp; y == 0)&#123; // points overlap overlap ++; continue; &#125; int gcd = getGCD(x,y); // vertical and horizontal covered x /= gcd; y /= gcd; String key = x + \",\" + y; if(map.containsKey(key)) map.put(key,map.get(key)+1); else map.put(key,1); // max for one start point max = Math.max(max,map.get(key)); &#125; // start point + other point on line + same as start result = Math.max(result,max+overlap+1); &#125; return result; &#125; private int getGCD(int a,int b)&#123; return a == 0 ? b : getGCD(b%a,a); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://jliao011.github.io/categories/algorithm/"}],"tags":[]},{"title":"Java Stack vs Heap","slug":"java-stack-vs-heap","date":"2018-06-24T01:29:46.000Z","updated":"2018-07-15T21:52:52.000Z","comments":true,"path":"2018/06/23/java-stack-vs-heap/","link":"","permalink":"https://jliao011.github.io/2018/06/23/java-stack-vs-heap/","excerpt":"","text":"What Is Java Stack?A Java stack is part of your computer’s memory where temporary variables, which are created by all functions you do, are stored. It is used to execute a thread and may have certain short-lived values as well as references to other objects. It uses LIFO data structure, or last in first out. What does this mean? When a method is invoked, it creates a new block in the stack for that particular method. The new block will have all the local values, as well as references to other objects that are being used by the method. When the method ends, the new block will be erased and will be available for use by the next method. The objects you find here are only accessible to that particular function and will not live beyond it. This makes it very easy to keep track of the stack, where the latest reserved block is also the first to be freed. The variables created for the method are directly stored in the memory, allowing for fast access. The memory size of a Java stack is generally much less than in a Java heap space because when a method ends, all the variables created on the stack are erased forever. What Is Java Heap?Java objects are in an area, which is called the heap. It is created when the program is run, and its size may decrease or increase as your program runs. It can easily become full, and when it does, garbage collection is initiated. This is when objects that are no longer used are deleted to make way for new objects. Unlike in a Java stack where memory allocation is done when your program is compiled, in a heap it is allocated as your program is run. Accessing variables placed here is a bit slower compared to a stack’s direct and fast access. Heap is likened to a global memory pool. A method or function will use the heap for memory allocation if you need the data or variables to live longer than the method or function in question. The objects you find here are accessible to all the functions. Also, there is no specific order in reserving blocks in a heap. You can allocate blocks at any time, and then you can free it when you wish. As you can imagine, it is much more complex to keep track of the parts that are free and can be allocated, but it can also be divided into two generations or sub-areas. These sub-areas are called the young space (or nursery) and the old space. The young space is typically earmarked for the memory allocation for new objects. When the young space becomes full, garbage collection happens. Short-lived or temporary objects typically use the young space. This help makes garbage collection faster when compared to a heap without any divisions. When to use?Where is it stored? Variables that are allocated on the stack are accessible directly from memory, and as such, these can run very fast. Accessing objects on the heap, on the other hand, takes more time. When does the allocation happen? On the stack, memory allocation happens when the program is compiled. Meanwhile, on the heap, it begins when the program is run. When do you use stack? Stack can only be used for local variables that use up small amounts of memory. The good news is that memory allocation and management is not going to be your problem and access to these objects is very fast. It does suffer from size limitations and the fact that you cannot resize variables on the stack. When do you use heap? You use the heap to allocate memory if there are variables that you need to be accessed globally, as opposed to just being available only to the methods and functions that created it. Heap is also good when you have a need for a lot of memory since it has no limit on memory size. You can also resize the variables on the heap. Difference between Java Heap Space and Stack MemoryBased on the above explanations, we can easily conclude following differences between Heap and Stack memory. Heap memory is used by all the parts of the application whereas stack memory is used only by one thread of execution. Whenever an object is created, it’s always stored in the Heap space and stack memory contains the reference to it. Stack memory only contains local primitive variables and reference variables to objects in heap space. (Always pass by value in stack) Objects stored in the heap are globally accessible whereas stack memory can’t be accessed by other threads. Memory management in stack is done in LIFO manner whereas it’s more complex in Heap memory because it’s used globally. Heap memory is divided into Young-Generation, Old-Generation etc, more details at Java Garbage Collection. Stack memory is short-lived whereas heap memory lives from the start till the end of application execution. We can use -Xms and -Xmx JVM option to define the startup size and maximum size of heap memory. We can use -Xss to define the stack memory size. When stack memory is full, Java runtime throws java.lang.StackOverFlowError whereas if heap memory is full, it throws java.lang.OutOfMemoryError: Java Heap Space error. Stack memory size is very less when compared to Heap memory. Because of simplicity in memory allocation (LIFO), stack memory is very fast when compared to heap memory. Referencehttps://dzone.com/articles/stack-vs-heap-understanding-java-memory-allocation https://www.journaldev.com/4098/java-heap-space-vs-stack-memory","categories":[{"name":"foundation","slug":"foundation","permalink":"https://jliao011.github.io/categories/foundation/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jliao011.github.io/tags/java/"}]},{"title":"What happens when you type an URL in the browser and press enter?","slug":"url-flow","date":"2018-06-24T01:13:20.000Z","updated":"2018-06-24T01:18:00.000Z","comments":true,"path":"2018/06/23/url-flow/","link":"","permalink":"https://jliao011.github.io/2018/06/23/url-flow/","excerpt":"","text":"1. You type maps.google.com into the address bar of your browser.2. The browser checks the cache for a DNS record to find the corresponding IP address of maps.google.com.DNS(Domain Name System) is a database that maintains the name of the website (URL) and the particular IP address it links to. Every single URL on the internet has a unique IP address assigned to it. The IP address belongs to the computer which hosts the server of the website we are requesting to access. DNS is a list of URLs and their IP addresses just like how a phone book is a list of names and their corresponding phone numbers. The main purpose of DNS is human-friendly navigation. You can easily access a website by typing the correct IP address for it on your browser but imagine having to remember different sets of numbers for all the websites we regularly access? Therefore, it is easier to remember the name of the website using an URL and let DNS do the work for us with mapping it to the correct IP. In order to find the DNS record, the browser checks four caches. ● First, it checks the browser cache. The browser maintains a repository of DNS records for a fixed duration for websites you have previously visited. So, it is the first place to run a DNS query. ● Second, the browser checks the OS cache. If it is not found in the browser cache, the browser would make a system call (i.e. gethostname on Windows) to your underlying computer OS to fetch the record since the OS also maintains a cache of DNS records. ● Third, it checks the router cache. If it’s not found on your computer, the browser would communicate with the router that maintains its’ own cache of DNS records. ● Fourth, it checks the ISP(Internet Service Provider) cache. If all steps fail, the browser would move on to the ISP. Your ISP maintains its’ own DNS server which includes a cache of DNS records which the browser would check with the last hope of finding your requested URL. 3. If the requested URL is not in the cache, ISP’s DNS server initiates a DNS query to find the IP address of the server that hosts maps.google.com.As mentioned earlier, in order for my computer to connect with the server that hosts maps.google.com, I need the IP address of maps.google.com. The purpose of a DNS query is to search multiple DNS servers on the internet until it finds the correct IP address for the website. This type of search is called a recursive search since the search will continue repeatedly from DNS server to DNS server until it either finds the IP address we need or returns an error response saying it was unable to find it. In this situation, we would call the ISP’s DNS server a DNS recursor whose responsibility is to find the proper IP address of the intended domain name by asking other DNS servers on the internet for an answer. The other DNS servers are called name servers since they perform a DNS search based on the domain architecture of the website domain name. Many website URLs we encounter today contain a third-level domain, a second-level domain, and a top-level domain. Each of these levels contains their own name server which is queried during the DNS lookup process. For maps.google.com, first, the DNS recursor will contact the root name server. The root name server will redirect it to .com domain name server. .com name server will redirect it to google.com name server. google.com name server will find the matching IP address for maps.google.com in its’ DNS records and return it to your DNS recursor which will send it back to your browser. These requests are sent using small data packets which contain information such as the content of the request and the IP address it is destined for (IP address of the DNS recursor). These packets travel through multiple networking equipment between the client and the server before it reaches the correct DNS server. This equipment use routing tables to figure out which way is the fastest possible way for the packet to reach its’ destination. If these packets get lost you’ll get a request failed error. Otherwise, they will reach the correct DNS server, grab the correct IP address, and come back to your browser. 4. Browser initiates a TCP connection with the server.Once the browser receives the correct IP address it will build a connection with the server that matches IP address to transfer information. Browsers use internet protocols to build such connections. There are a number of different internet protocols which can be used but TCP is the most common protocol used for any type of HTTP request. In order to transfer data packets between your computer(client) and the server, it is important to have a TCP connection established. This connection is established using a process called the TCP/IP three-way handshake. This is a three step process where the client and the server exchange SYN(synchronize) and ACK(acknowledge) messages to establish a connection. Client machine sends a SYN packet to the server over the internet asking if it is open for new connections. If the server has open ports that can accept and initiate new connections, it’ll respond with an ACKnowledgment of the SYN packet using a SYN/ACK packet. The client will receive the SYN/ACK packet from the server and will acknowledge it by sending an ACK packet. Then a TCP connection is established for data transmission! 5. The browser sends an HTTP request to the web server.Once the TCP connection is established, it is time to start transferring data! The browser will send a GET request asking for maps.google.com web page. If you’re entering credentials or submitting a form this could be a POST request. This request will also contain additional information such as browser identification (User-Agent header), types of requests that it will accept (Acceptheader), and connection headers asking it to keep the TCP connection alive for additional requests. It will also pass information taken from cookies the browser has in store for this domain. Sample GET request (Headers are highlighted): 6. The server handles the request and sends back a response.The server contains a web server (i.e Apache, IIS) which receives the request from the browser and passes it to a request handler to read and generate a response. The request handler is a program (written in ASP.NET, PHP, Ruby, etc.) that reads the request, its’ headers, and cookies to check what is being requested and also update the information on the server if needed. Then it will assemble a response in a particular format (JSON, XML, HTML). 7. The server sends out an HTTP response.The server response contains the web page you requested as well as the status code, compression type (Content-Encoding), how to cache the page (Cache-Control), any cookies to set, privacy information, etc. Example HTTP server response: If you look at the above response the first line shows a status code. This is quite important as it tells us the status of the response. There are five types of statuses detailed using a numerical code. ● 1xx indicates an informational message only ● 2xx indicates success of some kind ● 3xx redirects the client to another URL ● 4xx indicates an error on the client’s part ● 5xx indicates an error on the server’s part So, if you encountered an error you can take a look at the HTTP response to check what type of status code you have received. 8. The browser displays the HTML content (for HTML responses which is the most common).The browser displays the HTML content in phases. First, it will render the bare bone HTML skeleton. Then it will check the HTML tags and sends out GET requests for additional elements on the web page, such as images, CSS stylesheets, JavaScript files etc. These static files are cached by the browser so it doesn’t have to fetch them again the next time you visit the page. At the end, you’ll see maps.google.com appearing on your browser. 9. Client interaction with serverOnce a html page is loaded, there are several ways a user can interact with the server. For example, he call fill out a login form to sign in to the website. This also follows all the steps listed above, the only difference is that the HTTP request this time would be a POST instead of GET and along with that request, browser will send the form data to the server for processing (username and password in this case).Once server authenticates the user, it will send the proper HTML content(may be user’s profile) back to the browser and thus user will see that new webpage after his login request is processed. 10. AJAX queriesAnother form of client interaction with server is through AJAX(Asynchronous JavaScript And XML) requests. This is an asynchronous GET/POST request to which server can send a response back in a variety of ways - json, xml, html etc. AJAX requests doesn’t hinder the current view of the webpage and work in the background. Because of this, one can dynamically modify the content of a webpage by calling an AJAX request and updating the web elements using Javascript. Synchronous request: A synchronous request blocks the client until operation completes. In such case, javascript engine of the browser is blocked. Asynchronous request: An asynchronous request doesn’t block the client i.e. browser is responsive. At that time, user can perform another operations also. In such case, javascript engine of the browser is not blocked. References:https://medium.com/@maneesha.wijesinghe1/what-happens-when-you-type-an-url-in-the-browser-and-press-enter-bb0aa2449c1a http://edusagar.com/articles/view/70/What-happens-when-you-type-a-URL-in-browser","categories":[{"name":"foundation","slug":"foundation","permalink":"https://jliao011.github.io/categories/foundation/"}],"tags":[{"name":"web","slug":"web","permalink":"https://jliao011.github.io/tags/web/"}]},{"title":"Sorting Algorithms","slug":"sorting","date":"2018-06-23T08:02:38.000Z","updated":"2018-06-24T00:20:20.000Z","comments":true,"path":"2018/06/23/sorting/","link":"","permalink":"https://jliao011.github.io/2018/06/23/sorting/","excerpt":"","text":"ImplementationsSelection Sort generally performs worse than the similar insertion sort. The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right. 1234567891011121314151617public int[] selectionSort(int[] array) &#123; if (array == null || array.length == 0) return new int[0]; for (int i = 0; i &lt; array.length; ++i) &#123; int minIdx = i; for (int j = i + 1; j &lt; array.length; ++j) &#123; if (array[j] &lt; array[minIdx]) minIdx = j; &#125; if (minIdx != i) &#123; int temp = array[i]; array[i] = array[minIdx]; array[minIdx] = temp; &#125; &#125; return array;&#125; Insertion Sort Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Efficient for (quite) small data sets, much like other quadratic sorting algorithms More efficient in practice than most other simple quadratic algorithms such as selection sort or bubble sort efficient for data sets that are already substantially sorted, the time complexity is O(nk) when each element in the input is no more than k places away from its sorted position stable Array based 12345678910111213141516public int[] insertionSort(int[] array) &#123; if (array == null || array.length == 0) return new int[0]; int curr = 0; while (curr &lt; array.length) &#123; int idx = curr; while (idx &gt; 0 &amp;&amp; array[idx] &lt; array[idx - 1]) &#123; int temp = array[idx]; array[idx] = array[idx - 1]; array[idx - 1] = temp; idx--; &#125; curr++; &#125; return array;&#125; LinkedList based 1234567891011121314151617public ListNode insertionSortList(ListNode head) &#123; ListNode dummy = new ListNode(0); ListNode prev = dummy, curr = head, next = null; while(curr != null)&#123; // save curr next first next = curr.next; while(prev.next != null &amp;&amp; prev.next.val &lt; curr.val) prev = prev.next; // insert curr after prev curr.next = prev.next; prev.next = curr; curr = next; // reset prev prev = dummy; &#125; return dummy.next;&#125; Bubble Sort insertion sort, generally run faster than bubble sort. 123456789101112131415public static int[] bubbleSort(int[] array) &#123; if (array == null || array.length == 0) return new int[0]; // total n-1 loop, each loop find a curr largest for (int i = 0; i &lt; array.length - 1; ++i) &#123; for (int j = 0; j &lt; array.length - 1 - i; ++j) &#123; if (array[j] &gt; array[j + 1]) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; return array;&#125; Merge Sort Quick Sort","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://jliao011.github.io/categories/algorithm/"}],"tags":[{"name":"sort","slug":"sort","permalink":"https://jliao011.github.io/tags/sort/"}]},{"title":"Implementation of Trie","slug":"trie","date":"2018-06-12T07:27:22.000Z","updated":"2018-07-10T05:53:48.000Z","comments":true,"path":"2018/06/12/trie/","link":"","permalink":"https://jliao011.github.io/2018/06/12/trie/","excerpt":"","text":"Implement using HashMap insert (iteration, recursion) search (iteration, recursion) startWith (iteration, recursion) delete 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190public class Trie &#123; /** * use HashMap to save Character and child node * use isEnd to indicate whether it's end of a word */ private class TrieNode &#123; Map&lt;Character, TrieNode&gt; children; boolean isEnd; public TrieNode() &#123; children = new HashMap&lt;&gt;(); isEnd = false; &#125; &#125; private final static Logger logger = LoggerFactory.getLogger(Trie.class); private final TrieNode root; public Trie() &#123; this.root = new TrieNode(); &#125; /** * Insert a word iteratively */ public void insert(String word) &#123; if (word == null || word.length() == 0) return; TrieNode curr = root; for (char c : word.toCharArray()) &#123; TrieNode child = curr.children.get(c); // current character not exist if (child == null) &#123; child = new TrieNode(); curr.children.put(c, child); &#125; curr = child; &#125; // mark current node end of word curr.isEnd = true; &#125; /** * Insert a word recursively */ public void insertRecursive(String word) &#123; if (word == null || word.length() == 0) return; this.insertRecursive(this.root, word, 0); &#125; private void insertRecursive(TrieNode curr, String word, int idx) &#123; if (idx == word.length()) &#123; curr.isEnd = true; return; &#125; char c = word.charAt(idx); TrieNode child = curr.children.get(c); // current char not exist, create new node if (child == null) &#123; child = new TrieNode(); curr.children.put(c, child); &#125; insertRecursive(child, word, idx + 1); &#125; /** * Search a word in trie iteratively * @return whether exist */ public boolean search(String word) &#123; if (word == null || word.length() == 0) return false; TrieNode curr = root; for (char c : word.toCharArray()) &#123; TrieNode child = curr.children.get(c); if (child == null) return false; curr = child; &#125; // check wether reach end of a word return curr.isEnd; &#125; /** * Search a word in trie recursively * @return whether exist */ public boolean searchRecursive(String word) &#123; if (word == null || word.length() == 0) return false; return searchRecursive(this.root, word, 0); &#125; private boolean searchRecursive(TrieNode curr, String word, int idx) &#123; if (idx == word.length()) &#123; return curr.isEnd; &#125; char c = word.charAt(idx); TrieNode child = curr.children.get(c); if (child == null) return false; return searchRecursive(child, word, idx + 1); &#125; /** * Search if prefix word exist */ public boolean startWith(String word) &#123; if (word == null) return false; TrieNode curr = root; for (char c : word.toCharArray()) &#123; TrieNode child = curr.children.get(c); if (child == null) return false; curr = child; &#125; return true; &#125; /** * Search if prefix word exist recursively */ public boolean startWithRecursive(String word) &#123; if (word == null) return false; return startWithRecursive(root, word, 0); &#125; private boolean startWithRecursive(TrieNode curr, String word, int idx) &#123; if (idx == word.length()) return true; char c = word.charAt(idx); TrieNode child = curr.children.get(c); if (child == null) return false; return startWithRecursive(child, word, idx + 1); &#125; /** * Delete a word in the trie * remove a parent as well if there is no child */ public void delete(String word) &#123; if (word == null || word.length() == 0) return; delete(this.root, word, 0); &#125; /** * @return whether parent node should be deleted */ private boolean delete(TrieNode curr, String word, int idx) &#123; if (idx == word.length()) &#123; // still have sub tree if (!curr.isEnd) return false; // set to false if curr has other children curr.isEnd = false; // if no child, delete parent return curr.children.size() == 0; &#125; char c = word.charAt(idx); TrieNode child = curr.children.get(c); // such word not exist if (child == null) return false; boolean shouldDeleteChild = delete(child, word, idx + 1); if (shouldDeleteChild) &#123; curr.children.remove(c); // remove as well if no child return curr.children.size() == 0; &#125; return false; &#125; public static void test() &#123; Trie trie = new Trie(); List&lt;String&gt; dict = Arrays.asList(\"abc\", \"abgl\", \"abcd\", \"cdef\"); for (String word : dict) trie.insert(word); for (String word : dict) logger.info(\"Search for &#123;&#125;: &#123;&#125;\", word, trie.search(\"abc\")); for (String word : dict) &#123; trie.delete(word); &#125; &#125;&#125; Leetcode 211. Add and Search WordDesign a data structure that supports the following two operations: 12void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example: 1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true Note:You may assume that all words are consist of lowercase letters a-z. Use map: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class WordDictionary &#123; class TrieNode&#123; Map&lt;Character,TrieNode&gt; children; boolean isEnd; TrieNode()&#123; children = new HashMap&lt;&gt;(); isEnd = false; &#125; &#125; private TrieNode root; /** Initialize your data structure here. */ public WordDictionary() &#123; root = new TrieNode(); &#125; /** Adds a word into the data structure. */ public void addWord(String word) &#123; if(word == null || word.length() == 0) return; TrieNode curr = root; for(char c : word.toCharArray())&#123; TrieNode child = curr.children.get(c); if(child == null)&#123; child = new TrieNode(); curr.children.put(c,child); &#125; curr = child; &#125; curr.isEnd = true; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word) &#123; if(word == null || word.length() == 0) return false; return search(root,word,0); &#125; public boolean search(TrieNode curr,String word,int idx)&#123; if(idx == word.length()) return curr.isEnd; char c = word.charAt(idx); if(c != '.')&#123; TrieNode child = curr.children.get(c); if(child == null) return false; return search(child,word,idx+1); &#125;else&#123; for(char wildcard : curr.children.keySet())&#123; TrieNode child = curr.children.get(wildcard); if(search(child,word,idx+1)) return true; &#125; return false; &#125; &#125;&#125; Use int[26]: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class WordDictionary &#123; class TrieNode&#123; TrieNode[] children; boolean isEnd; TrieNode()&#123; children = new TrieNode[26]; isEnd = false; &#125; &#125; private TrieNode root; /** Initialize your data structure here. */ public WordDictionary() &#123; root = new TrieNode(); &#125; /** Adds a word into the data structure. */ public void addWord(String word) &#123; if(word == null || word.length() == 0) return; TrieNode curr = root; for(char c : word.toCharArray())&#123; TrieNode child = curr.children[c - 'a']; if(child == null)&#123; child = new TrieNode(); curr.children[c - 'a'] = child; &#125; curr = child; &#125; curr.isEnd = true; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word) &#123; if(word == null || word.length() == 0) return false; return search(root,word,0); &#125; public boolean search(TrieNode curr,String word,int idx)&#123; if(idx == word.length()) return curr.isEnd; char c = word.charAt(idx); if(c != '.')&#123; TrieNode child = curr.children[c - 'a']; if(child == null) return false; return search(child,word,idx+1); &#125;else&#123; for(int i=0; i&lt;26; i++)&#123; TrieNode child = curr.children[i]; if(child!=null &amp;&amp; search(child,word,idx+1)) return true; &#125; return false; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://jliao011.github.io/categories/algorithm/"}],"tags":[{"name":"trie","slug":"trie","permalink":"https://jliao011.github.io/tags/trie/"},{"name":"data structure","slug":"data-structure","permalink":"https://jliao011.github.io/tags/data-structure/"}]},{"title":"The 7 Software “-ilities” You Need To Know","slug":"software-ilities","date":"2018-06-04T09:31:54.000Z","updated":"2018-06-04T21:17:15.000Z","comments":true,"path":"2018/06/04/software-ilities/","link":"","permalink":"https://jliao011.github.io/2018/06/04/software-ilities/","excerpt":"","text":"Original Article: The 7 Software “-ilities” You Need To Know In the world of software architecture there are many “-ilities” you must take into consideration with every project. Prioritizing them is necessary because the client will optimistically ask that you do all of them. To help you out, here is a quick list outlining my top 7 default “-ilities” in the order that I prioritize them: 1. UsabilitySoftware usability can be described as how effectively end users can use, learn, or control the system. Some questions to ask yourself to determine usability might be: Is there a UI metaphor that I am using to help users adapt? (for example, the ‘desktop’ is a metaphor) Are the most common operations streamlined to be performed quickly? Can new users quickly adapt to the software without help? (is it intuitive?) Do validation and error messages make sense? 2. Maintainability ( or Flexibility / Testibility)The definition of maintainability [for me] implies how brittle the code is to change. As a result, I tie the terms flexibility and testability into the overall maintainability of a project. Does the entire team understand the code base or does knowledge islands exist? Is the code throughly regression tested? Can modifications to the project be done in a timely manner? 3. ScalabilityScalability is the ability for your program to gracefully meet the demand of stress caused by increased usage. In short, ensuring your program doesn’t slow or bust when pounded by more users than you originally anticipated. What is your current peak load that you can handle? How many database records can create until critical operations slow down? Is the primary scaling strategy to “scale up” or to “scale out” — that is, to upgrade the nodes in a fixed topology, or to add nodes? 4. Availability (or Reliability)How long the system is up and running and the Mean Time Between Failure (MTBF) is known as the availability of a program. How long does the system need to run without failure? What is the acceptable length of time for the system to be down? Can down times be scheduled? 5. ExtensibilityAre there points in the system where changes can be made with (or without) program changes? Can the database schema flex to accommodate change? Does the system allow Inversion of Control (IoC)? Can end users extend the system (scripts, user defined fields, etc)? Can 3rd party developers leverage your system? 6. SecurityI shouldn’t need to go into this one but to be thorough I like this definition of security: the measure of system’s ability to resist unauthorized attempts at usage or behavior modification, while still providing service to legitimate users. Does the system need user or role based security? Does code access security need to occur? What operations need to be secured? How will users be administered? 7. PortabilityPortability is the ability for your application to run on numerous platforms. This is can include actual application hosting, viewing, or data portability. Can the data be migrated to other systems? For web applications, which browsers does your web app support? Which operating systems does your program run on?","categories":[{"name":"foundation","slug":"foundation","permalink":"https://jliao011.github.io/categories/foundation/"}],"tags":[{"name":"software","slug":"software","permalink":"https://jliao011.github.io/tags/software/"}]},{"title":"Restful Web Service Related","slug":"restful-web-service","date":"2018-06-04T09:03:59.000Z","updated":"2018-06-24T01:18:31.000Z","comments":true,"path":"2018/06/04/restful-web-service/","link":"","permalink":"https://jliao011.github.io/2018/06/04/restful-web-service/","excerpt":"","text":"Advantages of REST Separation between the client and the server: the REST protocol totally separates the user interface from the server and the data storage. This has some advantages when making developments. For example, it improves the portability of the interface to other types of platforms, it increases the scalability of the projects, and allows the different components of the developments to be evolved independently. Visibility, reliability and scalability. The separation between client and server has one evident advantage, and that is that each development team can scale the product without too much problem. They can migrate to other servers or make all kinds of changes in the database, provided the data from each request is sent correctly. The separation makes it easier to have the front and the back on different servers, and this makes the apps more flexible to work with. The REST API is always independent of the type of platform or languages: the REST API always adapts to the type of syntax or platforms being used, which gives considerable freedom when changing or testing new environments within the development. With a REST API you can have PHP, Java, Python or Node.js servers. The only thing is that it is indispensable that the responses to the requests should always take place in the language used for the information exchange, normally XML or JSON.","categories":[{"name":"foundation","slug":"foundation","permalink":"https://jliao011.github.io/categories/foundation/"}],"tags":[{"name":"web","slug":"web","permalink":"https://jliao011.github.io/tags/web/"},{"name":"rest","slug":"rest","permalink":"https://jliao011.github.io/tags/rest/"}]},{"title":"Hexo Blog Usage","slug":"hexo-usage","date":"2018-06-02T23:38:03.000Z","updated":"2018-06-08T04:47:51.000Z","comments":true,"path":"2018/06/02/hexo-usage/","link":"","permalink":"https://jliao011.github.io/2018/06/02/hexo-usage/","excerpt":"","text":"Usage:Create Post:1$ hexo new [post-name] Then a new markdown file will create at: source/_posts/post-name.md Modify header:Use this specific post as an example, the header should like: Notice space required after : 12345678---title: Hexo Blog Usage // your article namedate: 2018-06-02 18:38:03 // created timecategories: project // categories folder it belongstags: [hexo,deploy] // name tags for this articletoc: true // enable the Table Of Contentcomments: true // allow comments--- Then you could add your content below this header. Deploy:Run the server locally: 123$ hexo serveror $ hexo s Starts a local server. By default, this is at http://localhost:4000/. Clean the blog: 1$ hexo clean Cleans the cache file (db.json) and generated files (public). Generate views: 123$ hexo generateor$ hexo g Generates static files. Deploy: 1$ hexo deploy Deploys your website. Google AnalyticsAdd tracking id to your config User, session and visit analysis. This is the Global Site Tag (gtag.js) tracking code for this property. Copy and paste this code as the first item into the of every webpage you want to track. If you already have a Global Site Tag on your page, simply add the config line from the snippet below to your existing Global Site Tag. 123456789&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;&lt;script async src=&quot;https://www.googletagmanager.com/gtag/js?id=UA-119871741-1&quot;&gt;&lt;/script&gt;&lt;script&gt; window.dataLayer = window.dataLayer || []; function gtag()&#123;dataLayer.push(arguments);&#125; gtag(&apos;js&apos;, new Date()); gtag(&apos;config&apos;, &apos;UA-119871741-1&apos;);&lt;/script&gt; Or simply add the track id into config file. VerificationVerify your page on Google Search Console Use your Google Analytics tracking id for verification. Or use google-site-verification meta tag Copy the meta tag below, and paste it into your site’s home page. It should go in the section, before the first section. 1&lt;meta name=&quot;google-site-verification&quot; content=&quot;Q8ZJjFeuFLdQt5A3JEUX1a0PKcngzJNKeU2D5Y24yXA&quot; /&gt; Submit hexo generated sitemap.xml file Use Search Console","categories":[{"name":"project","slug":"project","permalink":"https://jliao011.github.io/categories/project/"}],"tags":[{"name":"deploy","slug":"deploy","permalink":"https://jliao011.github.io/tags/deploy/"},{"name":"hexo","slug":"hexo","permalink":"https://jliao011.github.io/tags/hexo/"}]},{"title":"Flight GateWay Spring Boot App","slug":"flight-gateway","date":"2018-06-02T22:31:15.000Z","updated":"2018-06-05T00:55:52.000Z","comments":true,"path":"2018/06/02/flight-gateway/","link":"","permalink":"https://jliao011.github.io/2018/06/02/flight-gateway/","excerpt":"","text":"Flight GateWayFlight GateWay App url Heroku ConcernApp shut down when idleWhen an app on Heroku has only one web dyno and that dyno doesn’t receive any traffic in 1 hour, the dyno goes to sleep. 12345678What is dyno idling?Apps that have only 1 web dyno will be idled out after a period of inactivity.The web dyno will be shut down. When a request comes in to an idled app yourweb dyno will be automatically spun back up, causing a few second delay forthis first request. Subsequent requests will perform normally.Apps that have more than 1 web dyno are never idled out. Workers dynos arenever idled out. DynoAccounts are given a base of 550 hours each month in which your Free dynos can run. 12345678$ heroku ps -a &lt;app name&gt;Free dyno hours quota remaining this month: 984h 53m (98%)For more information on dyno sleeping and how to upgrade, see:https://devcenter.heroku.com/articles/dyno-sleeping=== web (Free): java -Dserver.port=$PORT $JAVA_OPTS -jar target/GateWay-0.0.1-SNAPSHOT.jar (1)web.1: up 2018/06/04 01:46:32 -0500 (~ 27m ago) Solution6 Easy Ways to Prevent Your Heroku Node App From Sleeping I used the kaffeine to ping my app every 30 seconds with 6 hours sleep every day. Since I set spring.jpa.hibernate.ddl-auto=create-drop so every time when the app restart the database will be dropped and created again. Deploying with GitInstall:1$ brew install heroku/brew/heroku Verify:12$ heroku --versionheroku/7.0.86 darwin-x64 node-v10.1.0 Login:12345$ heroku loginEnter your Heroku credentials.Email: adam@example.comPassword (typing will be hidden):Authentication successful. Create app:1234$ cd [app repository]$ heroku createCreating app... done, ⬢ sleepy-meadow-81798https://sleepy-meadow-81798.herokuapp.com/ | https://git.heroku.com/sleepy-meadow-81798.git Git init if no git repository:12345$ cd myapp$ git initInitialized empty Git repository in .git/$ git add .$ git commit -m \"My first commit\" Check remote:12345$ git remote -vheroku https://git.heroku.com/flightgateway.git (fetch)heroku https://git.heroku.com/flightgateway.git (push)origin https://github.com/jliao011/gate-way-app.git (fetch)origin https://github.com/jliao011/gate-way-app.git (push) For existing app, add remote:1$ heroku git:remote -a [app name] App rename:1234$ git remote rm heroku$ heroku git:remote -a newnameor$ heroku apps:rename newname Change Git remote:1$ git remote set-url origin https://github.com/USERNAME/REPOSITORY.git Update git repository and push123456$ git add .$ git commit$ git pushto git repository$ git push herokuto heroku repository When push to heroku, it will detect the app and build automatically. Then use $ heroku open to open the app url after the database configuration. If your app is linked with your Github url, once updates are pushed to the origin url, the heroku git repository will be updated automatically, then the app will restart. App restart:1$ heroku restart -a [app name] JawsDB MySQL add-onThere is no need to modify spring boot app configurations like this: 1234spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=$&#123;JDBC_DATABASE_URL&#125;spring.datasource.username=$&#123;JDBC_DATABASE_USERNAME&#125;spring.datasource.password=$&#123;JDBC_DATABASE_PASSWORD&#125; Create the add-on:12$ heroku addons:create jawsdb-----&gt; Adding jawsdb to sharp-mountain-4005... done, v18 (free) Get the database url here:12$ heroku config:get JAWSDB_URLmysql://username:password@hostname:port/default_schema Open the dashboard:All information about: Host, Username, Password, Port, Database, and Password Reset 1$ heroku addons:open jawsdb Configure the url:1$ heroku config:set DATABASE_URL='mysql://username:password@hostname:port/default_schema' Solve warning:1WARN: Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. To fix it, append a useSSL=false at the end of the MySQL connection string : 1$ heroku config:set JAWSDB_URL='mysql://username:password@hostname:port/default_schema?useSSL=false' To remove a config var: 1$ heroku config:unset GITHUB_USERNAME Logging: Coralogix add-onAdd a free version Coralogix add-on to display log dashboard 1$ heroku addons:create coralogix:free Or simply use heroku: 1$ heroku logs","categories":[{"name":"project","slug":"project","permalink":"https://jliao011.github.io/categories/project/"}],"tags":[{"name":"web","slug":"web","permalink":"https://jliao011.github.io/tags/web/"},{"name":"deploy","slug":"deploy","permalink":"https://jliao011.github.io/tags/deploy/"},{"name":"spring","slug":"spring","permalink":"https://jliao011.github.io/tags/spring/"}]},{"title":"LeetCode Solutions 601 - 800","slug":"leetcode-601-800","date":"2018-05-27T07:31:15.000Z","updated":"2018-07-13T05:30:35.000Z","comments":true,"path":"2018/05/27/leetcode-601-800/","link":"","permalink":"https://jliao011.github.io/2018/05/27/leetcode-601-800/","excerpt":"","text":"601 ~ 700 701 ~ 800 #604-compressed-string-iterator-easy #625-minimun-factorization-medium #632-smallest-range-hard #604-compressed-string-iterator-easyDesign and implement a data structure for a compressed string iterator. It should support the following operations: next and hasNext. The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string. next() - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.hasNext() - Judge whether there is any letter needs to be uncompressed. Note:Please remember to RESET your class variables declared in StringIterator, as static/class variables are persisted across multiple test cases. Please see here for more details. Example: 12345678910111213StringIterator iterator = new StringIterator(&quot;L1e2t1C1o1d1e1&quot;);iterator.next(); // return &apos;L&apos;iterator.next(); // return &apos;e&apos;iterator.next(); // return &apos;e&apos;iterator.next(); // return &apos;t&apos;iterator.next(); // return &apos;C&apos;iterator.next(); // return &apos;o&apos;iterator.next(); // return &apos;d&apos;iterator.hasNext(); // return trueiterator.next(); // return &apos;e&apos;iterator.hasNext(); // return falseiterator.next(); // return &apos; &apos; 123456789101112131415161718192021222324252627282930313233343536class StringIterator &#123; // use int[2] save char, count // use queue Queue&lt;int[]&gt; queue; public StringIterator(String compressedString) &#123; queue = new LinkedList&lt;&gt;(); int len = compressedString.length(); for(int i=0; i&lt;len;)&#123; int[] pair = new int[2]; pair[0] = compressedString.charAt(i); int j = i + 1; // num is before letters String cnt = \"\"; while(j&lt;len &amp;&amp; compressedString.charAt(j)&lt;'A')&#123; cnt += compressedString.charAt(j); j ++; &#125; pair[1] = Integer.parseInt(cnt); queue.offer(pair); i = j; &#125; &#125; public char next() &#123; if(queue.isEmpty()) return ' '; int[] pair = queue.peek(); if(--pair[1] == 0) queue.poll(); return (char) pair[0]; &#125; public boolean hasNext() &#123; return !queue.isEmpty(); &#125;&#125; #625-minimun-factorization-mediumGiven a positive integer a, find the smallest positive integer b whose multiplication of each digit equals to a. If there is no answer or the answer is not fit in 32-bit signed integer, then return 0. Example 1Input: 148 Output: 168 123456789101112131415161718public int smallestFactorization(int a) &#123; if(a &lt; 9) return a; // try larger first long result = 0, multi = 1; for(int i=9; i&gt;=2; i--)&#123; while(a % i == 0)&#123; a /= i; result += multi * i; if(result &gt; Integer.MAX_VALUE) return 0; multi *= 10; &#125; &#125; if(a != 1) return 0; return (int) result;&#125; #632-smallest-range-hardYou have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the klists. We define the range [a,b] is smaller than range [c,d] if b-a &lt; d-c or a &lt; c if b-a == d-c. Example 1: 123456Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]Output: [20,24]Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24].List 2: [0, 9, 12, 20], 20 is in range [20,24].List 3: [5, 18, 22, 30], 22 is in range [20,24]. 1234567891011121314151617181920212223242526272829303132333435363738public int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123; // use heap similar to merge k sorted list // maintain a max, when poll a min, update result, offer its next if(nums == null || nums.size() == 0) return new int[0]; // use int[3] save: &#123;row,idx,val&#125; PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1,int[] o2)&#123; return o1[2] - o2[2]; &#125; &#125;); int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE; int minRange = Integer.MAX_VALUE; int[] result = new int[2]; // init max and heap use first col for(int row=0; row&lt;nums.size(); row++)&#123; int value = nums.get(row).get(0); max = Math.max(max,value); heap.offer(new int[]&#123;row,0,value&#125;); &#125; // start, condition: heap size while(heap.size() == nums.size())&#123; int[] curr = heap.poll(); // update result if(max - curr[2] &lt; minRange)&#123; minRange = max - curr[2]; result = new int[]&#123;curr[2],max&#125;; &#125; // offer min's next, update max if(curr[1] + 1 &lt; nums.get(curr[0]).size())&#123; int next = nums.get(curr[0]).get(curr[1]+1); max = Math.max(max,next); heap.offer(new int[]&#123;curr[0],curr[1]+1,next&#125;); &#125; &#125; return result;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jliao011.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode Solutions 401 - 600","slug":"leetcode-401-600","date":"2018-05-27T07:31:15.000Z","updated":"2018-07-13T05:28:57.000Z","comments":true,"path":"2018/05/27/leetcode-401-600/","link":"","permalink":"https://jliao011.github.io/2018/05/27/leetcode-401-600/","excerpt":"","text":"401 ~ 500 501 ~ 600 #503-next-greater-element-ii-medium #406-queue-reconstruction-by-height-medium #516-longest-palindromic-subsequence-medium #419-battleships-in-a-board-medium #443-string-compression-easy #448-find-all-disappeared-number-easy #556-next-greater-element-iii-medium #560-subarray-sum-equals-k-medium #463-island-perimeter-easy #476-number-complement-easy #496-next-greater-element-i-easy #500-keyboard-row-easy #406-queue-reconstruction-by-height-mediumSuppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note:The number of people is less than 1,100. Example 12345Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 123456789101112131415161718public int[][] reconstructQueue(int[][] people) &#123; // height decrease, count increase, insert if(people==null || people.length==0 || people[0].length==0) return people; Arrays.sort(people,new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] a,int[] b)&#123; if(a[0] != b[0]) // decrease return b[0] - a[0]; else // increase return a[1] - b[1]; &#125; &#125;); List&lt;int[]&gt; result = new LinkedList&lt;&gt;(); for(int[] p : people) result.add(p[1],p); return result.toArray(new int[people.length][2]);&#125; 419. Battleships in a Board (medium)Given an 2D board, count how many battleships are in it. The battleships are represented with &#39;X&#39;s, empty slots are represented with &#39;.&#39;s. You may assume the following rules: You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships. Example: 123X..X...X...X In the above board there are 2 battleships. Invalid Example: 123...XXXXX...X This is an invalid board that you will not receive - as battleships will always have a cell separating between them. 12345678910111213141516171819public int countBattleships(char[][] board) &#123; // idea only find ship head, left top cell if(board==null || board.length==0 || board[0].length==0) return 0; final int m = board.length, n = board[0].length; int count = 0; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(board[i][j] == '.') continue; if(i&gt;0 &amp;&amp; board[i-1][j] == 'X') continue; if(j&gt;0 &amp;&amp; board[i][j-1] == 'X') continue; count ++; &#125; &#125; return count;&#125; #443-string-compression-easyGiven an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array. Follow up:Could you solve it using only O(1) extra space? Example: 123456789Input:[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]Output:Return 4, and the first 4 characters of the input array should be: [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;].Explanation:Since the character &quot;a&quot; does not repeat, it is not compressed. &quot;bbbbbbbbbbbb&quot; is replaced by &quot;b12&quot;.Notice each digit has it&apos;s own entry in the array. Note: All characters have an ASCII value in [35, 126]. 1 &lt;= len(chars) &lt;= 1000. 12345678910111213141516171819202122public int compress(char[] chars) &#123; if(chars==null || chars.length==0) return 0; // start for result tail, end for curr int start = 0, end = 0; while(end &lt; chars.length)&#123; char curr = chars[end]; int count = 1; // count same char while(end&lt;chars.length-1 &amp;&amp; chars[end]==chars[end+1])&#123; count ++; end ++; &#125; // put curr char down chars[start++] = chars[end++]; // then add count if(count != 1) for(char c : String.valueOf(count).toCharArray()) chars[start++] = c; &#125; return start;&#125; #448-find-all-disappeared-number-easyGiven an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: 12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] 12345678910111213141516public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); // 2 passes // 1 pass to set negative for(int num : nums)&#123; int index = Math.abs(num) - 1; if(nums[index] &gt; 0) nums[index] *= -1; &#125; // second pass find positive index for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i] &gt; 0) result.add(i+1); &#125; return result;&#125; #463-island-perimeter-easyExample: 1234567[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: 123456789101112131415161718192021public int islandPerimeter(int[][] grid) &#123; if(grid==null || grid.length==0 || grid[0].length==0) return 0; final int row = grid.length; final int col = grid[0].length; int count = 0; for(int i=0; i&lt;row; i++)&#123; for(int j=0; j&lt;col; j++)&#123; if(grid[i][j] == 0) continue; // check up and left, if nei is 1, remove edge count += 4; // default 4 added first // -2 : two block double edge remove if(i &gt; 0 &amp;&amp; grid[i-1][j] == 1) count -= 2; if(j &gt; 0 &amp;&amp; grid[i][j-1] == 1) count -= 2; &#125; &#125; return count;&#125; #476-number-complement-easyGiven a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. Example 1: 123Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2: 123Input: 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. 1234567public int findComplement(int num) &#123; // use 11111 - num int n = 1; while(n &lt; num) n = n &lt;&lt; 1 | 1; return n - num;&#125; #500-keyboard-row-easyGiven a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. Example 1: 12Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] Note: You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet. 123456789101112131415161718192021222324public String[] findWords(String[] words) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(words==null || words.length==0) return result.toArray(new String[0]); // build map String[] rows = &#123;\"QWERTYUIOP\",\"ASDFGHJKL\",\"ZXCVBNM\"&#125;; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;rows.length;i++) for(char c : rows[i].toCharArray()) map.put(c,i); // add to result WORDS: for(String word : words)&#123; if(word.equals(\"\")) continue; int idx = map.get(Character.toUpperCase(word.charAt(0))); for(int i=1;i&lt;word.length();i++)&#123; if(map.get(Character.toUpperCase(word.charAt(i))) != idx) continue WORDS; &#125; result.add(word); &#125; return result.toArray(new String[result.size()]);&#125; 123456789101112public String[] findWords(String[] words) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(words==null || words.length==0) return result.toArray(new String[0]); String regex = \"[QWERTYUIOP]*|[ASDFGHJKL]*|[ZXCVBNM]*\"; for(String word : words)&#123; if(word.toUpperCase().matches(regex))&#123; result.add(word); &#125; &#125; return result.toArray(new String[result.size()]);&#125; #496-next-greater-element-i-easyYou are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1‘s elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number. Example 1: 123456Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. 1. brute force 2. stack 123456789101112131415161718public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; // if decreasing, keep pushing stack] // if increase, find result, pop and put Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int num : nums2)&#123; while(!stack.isEmpty() &amp;&amp; num &gt; stack.peek())&#123; map.put(stack.pop(),num); &#125; stack.push(num); &#125; while(!stack.isEmpty()) map.put(stack.pop(),-1); int[] result = new int[nums1.length]; for(int i=0; i&lt;result.length; ++i) result[i] = map.get(nums1[i]); return result;&#125; #503-next-greater-element-ii-medium]Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number. Example 1: 12345Input: [1,2,1]Output: [2,-1,2]Explanation: The first 1&apos;s next greater number is 2; The number 2 can&apos;t find next greater number; The second 1&apos;s next greater number needs to search circularly, which is also 2. iterate twice for circular arrays 123456789101112public int[] nextGreaterElements(int[] nums) &#123; int n = nums.length; int[] result = new int[n]; Arrays.fill(result,-1); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();// index for(int i=0; i&lt;n*2; ++i)&#123; while(!stack.isEmpty() &amp;&amp; nums[i%n]&gt;nums[stack.peek()]) result[stack.pop()] = nums[i%n]; stack.push(i % n); &#125; return result;&#125; #516-longest-palindromic-subsequence-mediumGiven a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000. Example 1:Input: 1&quot;bbbab&quot; Output: 14 One possible longest palindromic subsequence is “bbbb”. 12345678910111213141516public int longestPalindromeSubseq(String s) &#123; int[][] dp = new int[s.length()][s.length()]; // row need to bottom up, to make i+1 available for(int i=s.length()-1; i&gt;=0; i--)&#123; dp[i][i] = 1; for(int j=i+1; j&lt;s.length(); j++)&#123; // head + tail + len(head to tail) // 2 + dp[i+1][j-1] if(s.charAt(i) == s.charAt(j)) dp[i][j] = 2 + dp[i+1][j-1]; else // [i-1][j] or [i][j-1] dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]); &#125; &#125; return dp[0][s.length()-1];&#125; #556-next-greater-element-iii-mediumGiven a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer nand is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. #31-next-permutation-medium Example 1: 12Input: 12Output: 21 12345678910111213141516171819202122232425262728293031323334public int nextGreaterElement(int n) &#123; //123987421, similar to #31-next-permutation-medium char[] num = String.valueOf(n).toCharArray(); int idx1 = num.length - 2; while(idx1 &gt;=0 &amp;&amp; num[idx1] &gt;= num[idx1+1]) idx1 --; if(idx1 &lt; 0) return -1; int idx2 = num.length - 1; while(num[idx2] &lt;= num[idx1]) idx2 --; swap(num,idx1,idx2); reverse(num,idx1+1,num.length-1); String s = new String(num); // handle overflow String threshold = String.valueOf(Integer.MAX_VALUE); // string compare consider length first if(s.length() &gt;= threshold.length() &amp;&amp; s.compareTo(threshold) &gt; 0) return -1; return Integer.parseInt(s); &#125;private void swap(char[] num,int i,int j)&#123; char temp = num[i]; num[i] = num[j]; num[j] = temp;&#125;private void reverse(char[] num,int i,int j)&#123; while(i &lt; j)&#123; swap(num,i,j); i++; j--; &#125;&#125; #560-subarray-sum-equals-k-mediumGiven an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: 12Input:nums = [1,1,1], k = 2Output: 2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. 1234567891011121314public int subarraySum(int[] nums, int k) &#123; if(nums==null || nums.length==0) return 0; // use map to save curr sum &amp; count Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); // int count = 0, sum = 0; for(int num : nums)&#123; sum += num; count += map.getOrDefault(sum-k,0); map.put(sum,map.getOrDefault(sum,0)+1); &#125; return count;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jliao011.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode Solutions 801 - 1000","slug":"leetcode-801-1000","date":"2018-05-27T07:31:15.000Z","updated":"2018-07-13T05:32:00.000Z","comments":true,"path":"2018/05/27/leetcode-801-1000/","link":"","permalink":"https://jliao011.github.io/2018/05/27/leetcode-801-1000/","excerpt":"","text":"801 ~ 900 901 ~ 1000 #809-expressive-word-medium #814-binary-tree-pruning-medium #817-linked-list-components-medium #855-exam-room-medium #856-score-of-parentheses-medium #862-shortest-subarray-with-sum-at-least-k-hard #863-all-nodes-distance-k-in-binary-tree-medium #864-random-pick-with-blacklist-hard #809-expressive-word-mediumSometimes people repeat letters to represent extra feeling, such as “hello” -&gt; “heeellooo”, “hi” -&gt; “hiiii”. Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different. A group is extended if that group is length 3 or more, so “e” and “o” would be extended in the first example, and “i” would be extended in the second example. As another example, the groups of “abbcccaaaa” would be “a”, “bb”, “ccc”, and “aaaa”; and “ccc” and “aaaa” are the extended groups of that string. For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups. Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more. Note that we cannot extend a group of size one like “h” to a group of size two like “hh” - all extensions must leave the group extended - ie., at least 3 characters long. Given a list of query words, return the number of words that are stretchy. 12345678Example:Input: S = &quot;heeellooo&quot;words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]Output: 1Explanation: We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.We can&apos;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not extended. 123456789101112131415161718192021222324252627public int expressiveWords(String S, String[] words) &#123; if(S==null || S.length()==0 || words==null || words.length==0) return 0; int count = 0; for(String word : words)&#123; // i for S &lt;= j for word int i = 0, j = 0; while(i &lt; S.length())&#123; // S.char == word.char, keep going if(j&lt;word.length() &amp;&amp; S.charAt(i)==word.charAt(j))&#123; i++; j++; // check S.char is extend? &#125;else if(i&gt;0 &amp;&amp; S.charAt(i)==S.charAt(i-1) &amp;&amp; i&lt;S.length()-1 &amp;&amp; S.charAt(i)==S.charAt(i+1))&#123; i += 2; // check S when j reach word tail &#125;else if(i&gt;1 &amp;&amp; S.charAt(i)==S.charAt(i-1) &amp;&amp; S.charAt(i)==S.charAt(i-2))&#123; i++; &#125;else break; if(i==S.length() &amp;&amp; j==word.length()) count++; &#125; &#125; return count;&#125; #814-binary-tree-pruning-mediumWe are given the head node root of a binary tree, where additionally every node’s value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) 1234567891011public TreeNode pruneTree(TreeNode root) &#123; // can use no helper if(root == null) return root; root.left = pruneTree(root.left); root.right = pruneTree(root.right); // post order if(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==0) return null; return root;&#125; #817-linked-list-components-mediumWe are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1: 123456Input: head: 0-&gt;1-&gt;2-&gt;3G = [0, 1, 3]Output: 2Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components. Example 2: 123456Input: head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4]Output: 2Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. Note: If N is the length of the linked list given by head, 1 &lt;= N &lt;= 10000. The value of each node in the linked list will be in the range[0, N - 1]. 1 &lt;= G.length &lt;= 10000. G is a subset of all values in the linked list. 1234567891011121314151617public int numComponents(ListNode head, int[] G) &#123; // use set, count tail of components Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num : G) set.add(num); int count = 0; while(head != null)&#123; // if contains curr: // 1. this is end // 2. not contain next (tail) if(set.contains(head.val) &amp;&amp; (head.next==null || !set.contains(head.next.val))) count ++; head = head.next; &#125; return count;&#125; #855-exam-room-mediumIn an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. (Also, if no one is in the room, then the student sits at seat number 0.) Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room. It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p. Example 1: 12345678910Input: [&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]Output: [null,0,9,4,2,null,5]Explanation:ExamRoom(10) -&gt; nullseat() -&gt; 0, no one is in the room, then the student sits at seat number 0.seat() -&gt; 9, the student sits at the last seat number 9.seat() -&gt; 4, the student sits at the last seat number 4.seat() -&gt; 2, the student sits at the last seat number 2.leave(4) -&gt; nullseat() -&gt; 5, the student sits at the last seat number 5. 1234567891011121314151617181920212223242526272829303132333435363738class ExamRoom &#123; int N; TreeSet&lt;Integer&gt; set; // use TreeSet to maintain increasing idx // idx = left + maxDist / 2; public ExamRoom(int N) &#123; this.N = N; this.set = new TreeSet&lt;&gt;(); &#125; public int seat() &#123; int idx = 0; // this way handles seat at 0 if(set.size() &gt; 0)&#123; int maxDist = set.first(); // deal with first interval int prev = -1; for(int student : set)&#123; // iteration in order if(prev != -1)&#123; int dist = (student - prev) / 2; if(dist &gt; maxDist)&#123; maxDist = dist; idx = prev + maxDist; &#125; &#125; prev = student; &#125; // deal with last interval if(N - 1 - set.last() &gt; maxDist) idx = N - 1; &#125; set.add(idx); return idx; &#125; public void leave(int p) &#123; set.remove(p); &#125;&#125; #856-score-of-parentheses-mediumGiven a balanced parentheses string S, compute the score of the string based on the following rule: () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string. Example 4: 12Input: &quot;(()(()))&quot;Output: 6 12345678910111213141516171819202122232425public int scoreOfParentheses(String S) &#123; // assume S is balanced if(S==null || S.length()==0) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(char c : S.toCharArray())&#123; if(c == '(') // use 0 mark ( stack.push(0); else&#123; int temp = 0; // sum in same level while(stack.peek()!=0) temp += stack.pop(); stack.pop(); // pop the 0 // if temp is 0, push 1, else push 2*temp stack.push(Math.max(2*temp,1)); &#125; &#125; // 0 level sum int result = 0; while(!stack.isEmpty()) result += stack.pop(); return result;&#125; space O(1): maintain level 1234567891011public int scoreOfParentheses(String S) &#123; int level = 0, result = 0; for(int i=0; i&lt;S.length(); ++i)&#123; // maintain level level += S.charAt(i)=='(' ? 1:-1; // add when find (), only () could add to result if(S.charAt(i) == '(' &amp;&amp; S.charAt(i+1) == ')') result += 1 &lt;&lt; (level-1); &#125; return result;&#125; #862-shortest-subarray-with-sum-at-least-k-hardReturn the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1. Example 1: 12Input: A = [1], K = 1Output: 1 Example 2: 12Input: A = [1,2], K = 4Output: -1 Example 3: 12Input: A = [2,-1,2], K = 3Output: 3 12345678910111213141516171819202122public int shortestSubarray(int[] A, int K) &#123; if(A == null || A.length == 0) return -1; int[] sums = new int[A.length + 1]; // accumulated array for(int i=0; i&lt;A.length; ++i) sums[i+1] = sums[i] + A[i]; int minLen = A.length + 1; Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); for(int i=0; i&lt;sums.length; ++i)&#123; // sliding window, if only increasing then this case while(!deque.isEmpty() &amp;&amp; sums[i] - sums[deque.peekFirst()] &gt;= K) minLen = Math.min(minLen,i - deque.pollFirst()); // if i+1 negative value in A, sums will decrease at i // keep the deque increasing // smaller sum with larger idx could be result instead of large sum with small idx while(!deque.isEmpty() &amp;&amp; sums[i] &lt;= sums[deque.peekLast()]) deque.pollLast(); deque.offerLast(i); &#125; return minLen &gt; A.length ? -1 : minLen;&#125; #863-all-nodes-distance-k-in-binary-tree-mediumWe are given a binary tree (with root node root), a target node, and an integer value K. Return a list of the values of all nodes that have a distance K from the target node. The answer can be returned in any order. Example 1: 12345678Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2Output: [7,4,1]Explanation: The nodes that are a distance 2 from the target node (with value 5)have values 7, 4, and 1.Note that the inputs &quot;root&quot; and &quot;target&quot; are actually TreeNodes.The descriptions of the inputs above are just serializations of these objects. Note: The given tree is non-empty. Each node in the tree has unique values 0 &lt;= node.val &lt;= 500. The target node is a node in the tree. 0 &lt;= K &lt;= 1000. geeks for geeks reference Undirected graph bfs: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; // use BFS, treat as undirected graph // nei of a node: left, right, parent List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(root == null || target == null) return result; // build parentMap Map&lt;TreeNode,TreeNode&gt; parentMap = new HashMap&lt;&gt;(); findParent(root,null,parentMap); // init bfs Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); queue.offer(target); int dist = 0; while(!queue.isEmpty())&#123; if(dist == K)&#123; while(!queue.isEmpty()) result.add(queue.poll().val); return result; &#125; // level order int size = queue.size(); for(int i=0; i&lt;size; ++i)&#123; TreeNode curr = queue.poll(); visited.add(curr); // add left, right, parent if(curr.left != null &amp;&amp; !visited.contains(curr.left)) queue.offer(curr.left); if(curr.right != null &amp;&amp; !visited.contains(curr.right)) queue.offer(curr.right); TreeNode parent = parentMap.get(curr); if(parent != null &amp;&amp; !visited.contains(parent)) queue.offer(parent); &#125; dist ++; &#125; return result;&#125;private void findParent(TreeNode root,TreeNode parent,Map&lt;TreeNode,TreeNode&gt; parentMap)&#123; if(root == null) return; // child -&gt; parent if(parent != null) parentMap.put(root,parent); findParent(root.left,root,parentMap); findParent(root.right,root,parentMap);&#125; DFS consider subtree and ancestor: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; // dfs 2 cases: // first: subtree of target node // second: ancestor or other subtree List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); getDist(root,target,K,result); return result;&#125;// for first case, no target found return -1, // return 0 when find target, then backtrack increase dist// backward get K, or search in the other subtree private int getDist(TreeNode root,TreeNode target,int K,List&lt;Integer&gt; result)&#123; if(root == null) return -1; if(root == target)&#123; // search subtree then search second case findSubTree(root,K,result); return 0; &#125; int leftDist = getDist(root.left,target,K,result); // target in left subtree if(leftDist != -1)&#123; if(leftDist + 1 == K) result.add(root.val); else // search right subtree findSubTree(root.right,K-2-leftDist,result); return 1 + leftDist; &#125; int rightDist = getDist(root.right,target,K,result); if(rightDist != -1)&#123; if(rightDist + 1 == K) result.add(root.val); else findSubTree(root.left,K-2-rightDist,result); return 1 + rightDist; &#125; return -1;&#125;// for case search in target subtreeprivate void findSubTree(TreeNode root,int K,List&lt;Integer&gt; result)&#123; if(root == null) return; if(K == 0)&#123; result.add(root.val); return; &#125; findSubTree(root.left,K-1,result); findSubTree(root.right,K-1,result);&#125; #864-random-pick-with-blacklist-hardGiven a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B. Optimize it such that it minimizes the call to system’s Math.random(). Note: 1 &lt;= N &lt;= 1000000000 0 &lt;= B.length &lt; min(100000, N) [0, N) does NOT include N. See interval notation). 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; Map&lt;Integer,Integer&gt; map; Set&lt;Integer&gt; blackSet; Random random; int range; public Solution(int N, int[] blacklist) &#123; // B black num, N total, N-B valid // map black num [0,N-B] to valid num [N-B,N] // [0,N-B)[N-B,N) this.blackSet = new HashSet&lt;&gt;(); this.map = new HashMap&lt;&gt;(); this.random = new Random(); int B = blacklist.length; // save black num after N-B for(int num : blacklist)&#123; if(num &gt;= N-B) blackSet.add(num); &#125; int val = N - B; // map black num before N-B for(int num : blacklist)&#123; if(num &lt; N - B)&#123; while(blackSet.contains(val)) val ++; map.put(num,val++);// notice ++ &#125; &#125; this.range = N - B; &#125; public int pick() &#123; int key = this.random.nextInt(range); // if contains in black map, return val // otherwise valid, return directly return map.getOrDefault(key,key); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jliao011.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode Solutions 201 - 400","slug":"leetcode-201-400","date":"2018-05-27T07:31:15.000Z","updated":"2018-07-13T05:27:01.000Z","comments":true,"path":"2018/05/27/leetcode-201-400/","link":"","permalink":"https://jliao011.github.io/2018/05/27/leetcode-201-400/","excerpt":"","text":"201 ~ 300 301 ~ 400 #201-bitwise-and-of-numbers-range-medium #204-count-primes-easy #207-course-schedule-medium #210-course-schedule-ii-medium #211-add-and-search-word-medium #313-supper-ugly-number-medium #217-contains-duplicate-easy #219-contains-duplicate-ii-easy #220-contains-duplicate-iii-medium #223-rectangle-area-medium #325-max-size-subarray-sum-equals-k-medium #228-summary-ranges-medium #229-majority-element-ii-medium #235-lca-of-a-bst-easy #335-self-crossing-hard #236-lca-of-a-binary-tree-medium #241-different-ways-to-add-parentheses-medium #243-shortest-word-distance-easy #244-shortest-word-distance-ii-medium #245-shortest-word-distance-iii-medium #347-top-k-frequent-elements-medium #248-strobogrammatic-number-iii-hard #350-intersection-of-two-arrays-easy #253-meeting-rooms-ii-medium #263-ugly-number-easy #268-missing-number-easy #271-encode-and-decode-strings-medium #371-sum-of-two-integers-easy #272-closest-bst-value-ii-hard #373-find-k-pairs-with-smallest-sum-medium #378-k-th-smallest-element-in-a-sorted-matrix-medium #279-perfect-squares-medium #384-shuffle-an-array-medium #285-inorder-successor-in-bst-medium #287-find-duplicate-number-medium #388-longest-absolute-file-path-medium #295-find-median-from-data-stream-hard #297-encode-and-decode-binary-tree-hard #300-longest-increasing-subsequence-medium #201-bitwise-and-of-numbers-range-mediumGiven a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. For example, given the range [5, 7], you should return 4. 123456789101112131415public int rangeBitwiseAnd(int m, int n) &#123; // right shift, all tail digits are 0 // until m == n, this is the head // append 0 tail to head if(m == 0) // 0 &amp; x == 0 return 0; int tailLen = 0; while(m != n)&#123; m &gt;&gt;= 1; n &gt;&gt;= 1; tailLen ++; &#125; return m &lt;&lt; tailLen;&#125; #204-count-primes-easyDescription: Count the number of prime numbers less than a non-negative number, n. 1234567891011121314151617public int countPrimes(int n) &#123; if(n &lt; 1) return 0; // indicate whether prime boolean[] prime = new boolean[n]; Arrays.fill(prime,true); int count = 0; for(int i=2; i&lt;n; i++)&#123; if(prime[i])&#123; count ++; for(int j=2; i*j&lt;n; j++)&#123; prime[i * j] = false; &#125; &#125; &#125; return count;&#125; #207-course-schedule-mediumThere are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: 1234Input: 2, [[1,0]] Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. 1234567891011121314151617181920212223242526272829303132333435public boolean canFinish(int numCourses, int[][] prerequisites) &#123; // detect cycle // use adjacency list, assume input valid List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); for(int i=0; i&lt;numCourses; i++) graph.add(new ArrayList&lt;&gt;()); for(int[] prerequisite : prerequisites)&#123; graph.get(prerequisite[0]).add(prerequisite[1]); &#125; // track visited node Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); // track along a path for one start Set&lt;Integer&gt; path = new HashSet&lt;&gt;(); for(int i=0; i&lt;numCourses; i++)&#123; if(hasCycle(graph,visited,path,i)) return false; &#125; return true;&#125;private boolean hasCycle(List&lt;List&lt;Integer&gt;&gt; graph,Set&lt;Integer&gt; visited,Set&lt;Integer&gt; path,int node)&#123; // visited in path, cycle if(path.contains(node)) return true; // no need to visit if(visited.contains(node)) return false; visited.add(node); // set visited path.add(node); // add to path for(int child : graph.get(node))&#123; if(hasCycle(graph,visited,path,child)) return true; &#125; path.remove(node); // path finish, remove return false;&#125; #210-course-schedule-ii-mediumtopological sort a directed graph dfs with check cycle: 12345678910111213141516171819202122232425262728293031323334353637383940public int[] findOrder(int numCourses, int[][] prerequisites) &#123; // dfs topological, stack result // no outcome node bottom, no income top List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); // graph save cout come edge for(int i=0; i&lt;numCourses; i++) graph.add(new ArrayList&lt;&gt;()); for(int[] p : prerequisites) graph.get(p[1]).add(p[0]); // check path, and visited (in result) // use stack to save visited node boolean[] path = new boolean[numCourses]; boolean[] visited = new boolean[numCourses]; Stack&lt;Integer&gt; order = new Stack&lt;&gt;(); // start dfs for(int i=0; i&lt;numCourses; i++)&#123; if(hasCycle(graph,order,visited,path,i)) return new int[0]; &#125; int[] result = new int[numCourses]; int idx = 0; while(!order.isEmpty()) result[idx++] = order.pop(); return result;&#125;private boolean hasCycle(List&lt;List&lt;Integer&gt;&gt; graph,Stack&lt;Integer&gt; order,boolean[] visited,boolean[] path,int curr)&#123; if(visited[curr]) return false; if(path[curr]) return true; path[curr] = true; for(int child : graph.get(curr))&#123; if(hasCycle(graph,order,visited,path,child)) return true; &#125; path[curr] = false; visited[curr] = true; order.push(curr); return false;&#125; BFS: ADJ list save outcome, then count income 1234567891011121314151617181920212223242526272829303132333435public int[] findOrder(int numCourses, int[][] prerequisites) &#123; // topological output: no income node firse, this case no pre // check degree 0 node (no prerequisites), add to queue, // adj list save out edge [0,1] =&gt; 1 -&gt; 0, when save 1 : 0 List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); // graph saved is node and outcome // but countPre save income number int[] countPre = new int[numCourses]; for(int i=0; i&lt;numCourses; i++) graph.add(new LinkedList&lt;&gt;()); for(int[] p : prerequisites)&#123; graph.get(p[1]).add(p[0]); // save outcome countPre[p[0]]++; // count income (pre) &#125; // init queue, find course with no pre int[] order = new int[numCourses]; int idx = 0; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i=0; i&lt;countPre.length; i++)&#123; if(countPre[i] == 0) queue.offer(i); &#125; // start bfs while(!queue.isEmpty())&#123; int curr = queue.poll(); order[idx++] = curr; // no income(pre) for(int child : graph.get(curr))&#123; // for all outcome node, income -- countPre[child]--; if(countPre[child] == 0) queue.offer(child); &#125; &#125; return idx == numCourses ? order : new int[0];&#125; #211-add-and-search-word-mediumDesign a data structure that supports the following two operations: 12void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example: 1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true Note:You may assume that all words are consist of lowercase letters a-z. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class WordDictionary &#123; class TrieNode&#123; TrieNode[] children; boolean isEnd; TrieNode()&#123; children = new TrieNode[26]; isEnd = false; &#125; &#125; private TrieNode root; /** Initialize your data structure here. */ public WordDictionary() &#123; root = new TrieNode(); &#125; /** Adds a word into the data structure. */ public void addWord(String word) &#123; if(word == null || word.length() == 0) return; TrieNode curr = root; for(char c : word.toCharArray())&#123; TrieNode child = curr.children[c - 'a']; if(child == null)&#123; child = new TrieNode(); curr.children[c - 'a'] = child; &#125; curr = child; &#125; curr.isEnd = true; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word) &#123; if(word == null || word.length() == 0) return false; return search(root,word,0); &#125; public boolean search(TrieNode curr,String word,int idx)&#123; if(idx == word.length()) return curr.isEnd; char c = word.charAt(idx); if(c != '.')&#123; TrieNode child = curr.children[c - 'a']; if(child == null) return false; return search(child,word,idx+1); &#125;else&#123; for(int i=0; i&lt;26; i++)&#123; TrieNode child = curr.children[i]; if(child!=null &amp;&amp; search(child,word,idx+1)) return true; &#125; return false; &#125; &#125;&#125; #217-contains-duplicate-easyGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Use HashSet: time O(n), space O(n) Use Sort: time O(nlgn), space O(1) #219-contains-duplicate-ii-easyGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. 123456789public boolean containsNearbyDuplicate(int[] nums, int k) &#123; if(k&lt;=0) return false; Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(i-k&gt;0) visited.remove(nums[i-k-1]); if(!visited.add(nums[i])) return true; &#125; return false;&#125; #220-contains-duplicate-iii-mediumGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. Use TreeSet 1234567891011121314151617181920212223242526public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; // abs(nums[i] - nums[j]) &lt;= t // abs(i - j) &lt;= k // O(n log k) if(nums==null || nums.length==0 || t&lt;0 || k&lt;0) return false; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for(int i=0; i&lt;nums.length; i++)&#123; // maintance a window if(i - k &gt; 0) set.remove(nums[i - k - 1]); // floor: greatest less or equal to // ceiling: smallest greater or equal to // NOTICE: overflow Integer left = set.ceiling(Integer.MIN_VALUE + t &lt; nums[i] ? nums[i] - t : Integer.MIN_VALUE); Integer right = set.floor(Integer.MAX_VALUE - t &gt; nums[i] ? nums[i] + t : Integer.MAX_VALUE); if(left != null &amp;&amp; left &lt;= nums[i] || right != null &amp;&amp; right &gt;= nums[i]) return true; // add set set.add(nums[i]); &#125; return false;&#125; #223-rectangle-area-mediumFind the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. Assume that the total area is never beyond the maximum possible value of int. 12345678910111213141516171819202122232425262728293031public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; // FIND INTERSECTION // x axis: A---C E---F int X = 0; if(C-A&gt;G-E &amp;&amp; E&gt;=A &amp;&amp; G&lt;=C) X = G - E; else if(C-A&lt;=G-E &amp;&amp; A&gt;=E &amp;&amp; C&lt;=G) X = C - A; // after above 2, low priority else if(G&gt;A &amp;&amp; E&lt;A) X = G - A; else if(E&lt;C &amp;&amp; G&gt;C) X = C - E; // y axis: B---D F---H int Y = 0; // check include relation first if(D-B&gt;H-F &amp;&amp; F&gt;=B &amp;&amp; H&lt;=D) Y = H - F; else if(D-B&lt;=H-F &amp;&amp; B&gt;=F &amp;&amp; D&lt;=H) Y = D - B; else if(H&gt;B &amp;&amp; F&lt;B) Y = H - B; else if(F&lt;D &amp;&amp; H&gt;D) Y = D - F; // compute int area1 = (C-A) * (D-B); int area2 = (G-E) * (H-F); int area3 = X * Y; return area1 + area2 - area3;&#125; #227-basic-calculator-ii-mediumImplement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero. Example 1: 12Input: &quot;3+2*2&quot;Output: 7 Example 2: 12Input: &quot; 3/2 &quot;Output: 1 Example 3: 12Input: &quot; 3+5 / 2 &quot;Output: 5 1234567891011121314151617181920212223242526public int calculate(String s) &#123; if(s == null || s.length() == 0) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); char sign = '+'; // for first number; int num = 0; for(int i=0; i&lt;s.length(); ++i)&#123; if(Character.isDigit(s.charAt(i))) num = num * 10 + s.charAt(i) - '0'; // when to add prev val // cannot use else if if(!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != ' ' || i == s.length()-1)&#123; switch(sign)&#123; case '+': stack.push(num); break; case '-': stack.push(-num); break; case '*': stack.push(stack.pop()*num); break; case '/': stack.push(stack.pop()/num); break; &#125; sign = s.charAt(i); num = 0; &#125; &#125; while(!stack.isEmpty()) num += stack.pop(); return num;&#125; #228-summary-ranges-mediumGiven a sorted integer array without duplicates, return the summary of its ranges. Example 1: 12Input: [0,1,2,4,5,7]Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;] Example 2: 12Input: [0,2,3,4,6,8,9]Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;] 1234567891011121314151617181920212223public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(nums==null || nums.length==0) return result; Integer head = null; StringBuilder sb = new StringBuilder(); for(int i=0; i&lt;nums.length; i++)&#123; if(head == null) head = nums[i]; if(i&lt;nums.length-1 &amp;&amp; nums[i]+1==nums[i+1]) continue; else&#123; // last one or new range sb.append(head); // notice one num if(head != nums[i]) sb.append(\"-&gt;\"+nums[i]); result.add(sb.toString()); sb.setLength(0); head = null; &#125; &#125; return result;&#125; 12345678910111213141516public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(nums==null || nums.length==0) return result; for(int head=0; head&lt;nums.length; head++)&#123; int tail = head; while(tail&lt;nums.length-1 &amp;&amp; nums[tail]+1==nums[tail+1]) tail ++; if(head != tail) result.add(nums[head] + \"-&gt;\" + nums[tail]); else result.add(nums[head] + \"\"); head = tail; &#125; return result;&#125; #229-majority-element-ii-mediumGiven an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space. Check existence first!! 1234567891011121314151617181920212223242526272829303132333435363738public List&lt;Integer&gt; majorityElement(int[] nums) &#123; // majority vote List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(nums == null || nums.length == 0) return result; int major1 = 0, major2 = 0, cnt1 = 0, cnt2 = 0; for(int num : nums)&#123; // order matters if(major1 == num) cnt1 ++; else if(major2 == num) cnt2 ++; else if(cnt1 == 0)&#123; major1 = num; cnt1 ++; &#125;else if(cnt2 == 0)&#123; major2 = num; cnt2 ++; &#125;else&#123; cnt1 --; cnt2 --; &#125; &#125; // 2nd pass, cnt accurance cnt1 = cnt2 = 0; for(int num : nums)&#123; if(major1 == num) cnt1 ++; else if(major2 == num) cnt2 ++; &#125; // add to result if(cnt1 &gt; nums.length / 3) result.add(major1); if(cnt2 &gt; nums.length / 3) result.add(major2); return result;&#125; #235-lca-of-a-bst-easyGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. 123456789 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null) return null; if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right,p,q); if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left,p,q); return root;&#125; #236-lca-of-a-binay-tree-mediumGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” 1234567891011public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null) return right; if(right == null) return left; return root; &#125; #239-sliding-window-maxmum-hardGiven an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 123456789101112131415161718192021222324// use deque maintains max at headpublic int[] maxSlidingWindow(int[] nums, int k) &#123; if(nums==null || nums.length==0) return new int[0]; int[] result = new int[nums.length - k + 1]; Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); for(int i=0;i&lt;k-1;i++) inQueue(deque,nums[i]); for(int i=k-1;i&lt;nums.length;i++)&#123; inQueue(deque,nums[i]); result[i-k+1] = deque.peekFirst(); outQueue(deque,nums[i-k+1]); &#125; return result;&#125;private void inQueue(Deque&lt;Integer&gt; deque,int num)&#123; while(!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;num) deque.pollLast(); deque.offerLast(num);&#125;private void outQueue(Deque&lt;Integer&gt; deque,int num)&#123; if(deque.peekFirst() == num) deque.pollFirst();&#125; #241-different-ways-to-add-parentheses-mediumGiven a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1 Input: &quot;2-1-1&quot;. 12((2-1)-1) = 0(2-(1-1)) = 2 Output: [0, 2] Example 2 Input: &quot;2*3-4*5&quot; 12345(2*(3-(4*5))) = -34((2*3)-(4*5)) = -14((2*(3-4))*5) = -10(2*((3-4)*5)) = -10(((2*3)-4)*5) = 10 Output: [-34, -14, -10, -10, 10] 12345678910111213141516171819202122232425262728293031323334353637public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; // use recursion List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int i=0;i&lt;input.length();i++)&#123; char c = input.charAt(i); // divide input to two part if(c=='+' || c=='-' || c=='*')&#123; String left = input.substring(0,i); String right = input.substring(i+1); List&lt;Integer&gt; list1 = diffWaysToCompute(left); List&lt;Integer&gt; list2 = diffWaysToCompute(right); // combine to subset for(int num1 : list1)&#123; for(int num2 : list2)&#123; int temp = 0; switch(c)&#123; case '+': temp = num1 + num2; break; case '-': temp = num1 - num2; break; case '*': temp = num1 * num2; break; &#125; // one possible result result.add(temp); &#125; &#125; &#125; &#125; // case theres no operator in input if(result.size() == 0) result.add(Integer.parseInt(input)); return result;&#125; add memory and optimization 1234567891011121314151617181920212223242526272829303132333435363738394041424344public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); return dfs(input,map,0,input.length());&#125;private List&lt;Integer&gt; dfs(String input,Map&lt;String,List&lt;Integer&gt;&gt; map,int start,int end)&#123; // use recursion // if this expression is saved String expression = input.substring(start,end); if(map.containsKey(expression)) return map.get(expression); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int i=start;i&lt;end;i++)&#123; char c = input.charAt(i); // divide input to two part if(c=='+' || c=='-' || c=='*')&#123; List&lt;Integer&gt; list1 = dfs(input,map,start,i); List&lt;Integer&gt; list2 = dfs(input,map,i+1,end); // combine to subset for(int num1 : list1)&#123; for(int num2 : list2)&#123; int temp = 0; switch(c)&#123; case '+': temp = num1 + num2; break; case '-': temp = num1 - num2; break; case '*': temp = num1 * num2; break; &#125; // one possible result result.add(temp); &#125; &#125; &#125; &#125; // case theres no operator in input if(result.size() == 0) result.add(Integer.parseInt(expression)); map.put(expression,result); return result; &#125; #243-shortest-word-distance-easyGiven a list of words and two words word1 and word2, return the shortest distance between these two words in the list. For example,Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]. Given word1 = “coding”, word2 = “practice”, return 3.Given word1 = &quot;makes&quot;, word2 = &quot;coding&quot;, return 1. Note:You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. 123456789101112131415public int shortestDistance(String[] words, String word1, String word2) &#123; if(words==null || words.length==0) return 0; int idx1 = -1, idx2 = -1, min = words.length; for(int i=0;i&lt;words.length;i++)&#123; if(words[i].equals(word1)) idx1 = i; else if(words[i].equals(word2)) idx2 = i; // need to check whether idx are set if(idx1!=-1 &amp;&amp; idx2!=-1) min = Math.min(min,Math.abs(idx1-idx2)); &#125; return min;&#125; #244-shortest-word-distance-ii-mediumThis is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it? Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list. For example,Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]. Given word1 = “coding”, word2 = “practice”, return 3.Given word1 = &quot;makes&quot;, word2 = &quot;coding&quot;, return 1. Note:You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. 123456789101112131415161718192021222324252627class WordDistance &#123; Map&lt;String,List&lt;Integer&gt;&gt; map; public WordDistance(String[] words) &#123; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;words.length;i++)&#123; if(!map.containsKey(words[i])) map.put(words[i],new ArrayList&lt;&gt;()); map.get(words[i]).add(i); &#125; &#125; public int shortest(String word1, String word2) &#123; List&lt;Integer&gt; l1 = map.get(word1); List&lt;Integer&gt; l2 = map.get(word2); int min = Integer.MAX_VALUE; int idx1 = 0, idx2 = 0; // utilize two pointer to optimize while(idx1&lt;l1.size() &amp;&amp; idx2&lt;l2.size())&#123; min = Math.min(min,Math.abs(l1.get(idx1)-l2.get(idx2))); if(l1.get(idx1) &lt; l2.get(idx2)) idx1++; else idx2++; &#125; return min; &#125;&#125; #245-shortest-word-distance-iii-mediumThis is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2. Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. word1 and word2 may be the same and they represent two individual words in the list. For example,Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]. Given word1 = “makes”, word2 = “coding”, return 1.Given word1 = &quot;makes&quot;, word2 = &quot;makes&quot;, return 3. Note:You may assume word1 and word2 are both in the list. 1234567891011121314151617181920public int shortestWordDistance(String[] words, String word1, String word2) &#123; if(words==null || words.length==0) return 0; int min = words.length; int idx1 = -1, idx2 = -1; for(int i=0; i&lt;words.length; i++)&#123; if(words[i].equals(word1)) idx1 = i; if(words[i].equals(word2))&#123; if(word1.equals(word2)) // set idx1 to prev idx2 idx1 = idx2; idx2 = i; &#125; if(idx1 != -1 &amp;&amp; idx2 != -1)&#123; min = Math.min(min,Math.abs(idx1-idx2)); &#125; &#125; return min;&#125; quicker 12345678910111213141516171819202122232425262728public int shortestWordDistance(String[] words, String word1, String word2) &#123; if(words==null || words.length==0) return 0; int min = words.length; int idx1 = -1, idx2 = -1; if(word1.equals(word2))&#123; for(int i=0;i&lt;words.length;i++)&#123; if(words[i].equals(word1))&#123; if(idx1 == -1) idx1 = i; else&#123; min = Math.min(min,i-idx1); idx1 = i; &#125; &#125; &#125; &#125;else&#123; for(int i=0;i&lt;words.length;i++)&#123; if(words[i].equals(word1)) idx1 = i; else if(words[i].equals(word2)) idx2 = i; if(idx1!=-1 &amp;&amp; idx2!=-1) min = Math.min(min,Math.abs(idx1-idx2)); &#125; &#125; return min;&#125; #248-strobogrammatic-number-iii-hardA strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to count the total strobogrammatic numbers that exist in the range of low &lt;= num &lt;= high. Example: 123Input: low = &quot;50&quot;, high = &quot;100&quot;Output: 3 Explanation: 69, 88, and 96 are three strobogrammatic numbers. Note:Because the range might be a large number, the low and high numbers are represented as string. 12345678910111213141516171819202122232425262728293031323334public int strobogrammaticInRange(String low, String high) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i=low.length(); i&lt;=high.length(); i++)&#123; list.addAll(findStrobogrammatic(i)); &#125; int count = 0; for(String s : list)&#123; if(s.length()==low.length() &amp;&amp; s.compareTo(low)&lt;0 || s.length()==high.length() &amp;&amp; s.compareTo(high)&gt;0) continue; count ++; &#125; return count;&#125;public List&lt;String&gt; findStrobogrammatic(int n) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(n % 2 == 0) result = Arrays.asList(\"\"); else result = Arrays.asList(\"0\",\"1\",\"8\"); for(int i=(n%2)+2; i&lt;=n; i+=2)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(String s : result)&#123; if(i != n) list.add(\"0\" + s + \"0\"); list.add(\"1\" + s + \"1\"); list.add(\"8\" + s + \"8\"); list.add(\"6\" + s + \"9\"); list.add(\"9\" + s + \"6\"); &#125; result = list; &#125; return result;&#125; #253-meeting-rooms-ii-mediumGiven an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si &lt; ei), find the minimum number of conference rooms required. Example 1: 12Input: [[0, 30],[5, 10],[15, 20]]Output: 2 Example 2: 12Input: [[7,10],[2,4]]Output: 1 12345678910111213141516171819202122public int minMeetingRooms(Interval[] intervals) &#123; // seperate array of start and end then sort if(intervals == null || intervals.length == 0) return 0; int[] starts = new int[intervals.length]; int[] ends = new int[intervals.length]; for(int i=0; i&lt;intervals.length; i++)&#123; starts[i] = intervals[i].start; ends[i] = intervals[i].end; &#125; Arrays.sort(starts); Arrays.sort(ends); // if start &lt; end add room, else update end int count = 0, end = 0; for(int i=0; i&lt;starts.length; i++)&#123; if(starts[i] &lt; ends[end]) count ++; else end ++; &#125; return count;&#125; Greedy: 123456789101112131415161718192021222324 public int minMeetingRooms(Interval[] intervals) &#123; // greedy, sort on start first // then use heap on end time to track rooms if(intervals == null || intervals.length == 0) return 0; // sort start time and init end sorted heap Arrays.sort(intervals,(o1,o2)-&gt;o1.start-o2.start); PriorityQueue&lt;Interval&gt; heap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o1.end-o2.end);// start heap.offer(intervals[0]);Interval prev = intervals[0], curr = null;for (int i = 1; i &lt; intervals.length; i++) &#123; // find min end room, cannot use peek prev = heap.poll(); curr = intervals[i]; // can put in this min end room, update end time if(curr.start &gt;= prev.end) prev.end = curr.end; else // sign a new room heap.offer(curr); heap.offer(prev);&#125;return heap.size(); &#125; count max schedules 123456789101112131415public int maxSchedules(Interval[] intervals) &#123; if(intervals == null || intervals.length == 0) return 0; // sort on end time Arrays.sort(intervals, (o1,o2)-&gt;o1.end-o2.end); int count = 0; Interval prev = null; for(int i=0; i&lt;intervals.length; i++) &#123; if(prev == null || intervals[i].start&gt;=prev.end) &#123; count ++; prev = intervals[i]; &#125; &#125; return count;&#125; #263-ugly-number-easyWrite a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note: 1 is typically treated as an ugly number. Input is within the 32-bit signed integer range. 12345678910public boolean isUgly(int num) &#123; if(num == 0) return false; if(num == 1) return true; while(num % 2 == 0) num /= 2; while(num % 3 == 0) num /= 3; while(num % 5 == 0) num /= 5; return num == 1;&#125; #264-ugly-number-ii-mediumWrite a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly number, and n does not exceed 1690. The idea of this solution is from this page:http://www.geeksforgeeks.org/ugly-numbers/ 123456789101112131415161718public int nthUglyNumber(int n) &#123; // pointer for multi of 2,3,5 int i2 = 0, i3 = 0, i5 = 0; // dp int[] dp = new int[n]; dp[0] = 1; for(int i=1; i&lt;n; i++)&#123; int ugly = Math.min(dp[i5]*5, Math.min(dp[i2]*2, dp[i3]*3)); dp[i] = ugly; // check to increase pointer if(dp[i2]*2 == ugly) i2++; if(dp[i3]*3 == ugly) i3++; if(dp[i5]*5 == ugly) i5++; &#125; return dp[n-1];&#125; #268-missing-number-easyGiven an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: 12Input: [3,0,1]Output: 2 Example 2: 12Input: [9,6,4,2,3,5,7,0,1]Output: 8 1234567891011121314public int missingNumber(int[] nums) &#123; for(int i=0; i&lt;nums.length; i++)&#123; while(nums[i]!=nums.length &amp;&amp; nums[i]!=nums[nums[i]])&#123; int temp = nums[nums[i]]; nums[nums[i]] = nums[i]; nums[i] = temp; &#125; &#125; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i] != i) return i; &#125; return nums.length;&#125; #271-encode-and-decode-strings-mediumDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. 12345678910111213141516171819202122232425262728293031public class Codec &#123; // Encodes a list of strings to a single string. public String encode(List&lt;String&gt; strs) &#123; // count#str StringBuilder sb = new StringBuilder(); for(String str : strs)&#123; // append one by one sb.append(str.length() + \"#\" + str); &#125; return sb.toString(); &#125; // Decodes a single string to a list of strings. public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); int i = 0; while(i &lt; s.length())&#123; int j = i; while(s.charAt(j) != '#') j ++; int len = Integer.parseInt(s.substring(i,j)); result.add(s.substring(j+1,j+1+len)); i = j + 1 + len; &#125; return result; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.decode(codec.encode(strs)); num#len1#len2#12 1234567891011121314151617181920212223242526272829303132333435363738// Encodes a list of strings to a single string.public String encode(List&lt;String&gt; strs) &#123; StringBuilder sb = new StringBuilder(); sb.append(strs.size() + \"#\"); for(String str : strs) sb.append(str.length() + \"#\"); for(String str : strs) sb.append(str); return sb.toString();&#125;// Decodes a single string to a list of strings.public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); int head = 0, tail = 0; // find count while(tail&lt;s.length() &amp;&amp; s.charAt(tail)!='#') tail++; int count = Integer.parseInt(s.substring(head,tail)); int[] len = new int[count]; for(int i=0; i&lt;count; i++)&#123; head = tail + 1; tail = head; while(tail&lt;s.length() &amp;&amp; s.charAt(tail)!='#') tail++; len[i] = Integer.parseInt(s.substring(head,tail)); &#125; head = tail + 1; for(int i=0; i&lt;count; i++)&#123; if(head == s.length()) result.add(\"\"); else&#123; result.add(s.substring(head,head+len[i])); head += len[i]; &#125; &#125; return result;&#125; #272-closest-bst-value-ii-hardGiven a non-empty binary search tree and a target value, find k values in the BST that are closest to the target. Note: Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target. Example: 123456789Input: root = [4,2,5,1,3], target = 3.714286, and k = 2 4 / \\ 2 5 / \\1 3Output: [4,3] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) &#123; // use two stack, one for pre one for suc // 12345, 3,7 // =&gt; pres 1,2,3 // =&gt; succ 5,4 List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Stack&lt;Integer&gt; pres = new Stack&lt;&gt;(); Stack&lt;Integer&gt; sucs = new Stack&lt;&gt;(); // notice one of should have equal condition inorderPre(root,target,pres); inorderSuc(root,target,sucs); // then find k while(k-- &gt; 0)&#123; if(pres.isEmpty()) result.add(sucs.pop()); else if(sucs.isEmpty()) result.add(pres.pop()); else if(Math.abs(pres.peek()-target) &lt; Math.abs(sucs.peek()-target)) result.add(pres.pop()); else result.add(sucs.pop()); &#125; return result;&#125;private void inorderPre(TreeNode root, double target, Stack&lt;Integer&gt; pres)&#123; if(root == null) return; inorderPre(root.left, target, pres); // push all smaller pred, choose equal (or sucs equal) if(root.val &gt;= target) return; pres.push(root.val); inorderPre(root.right, target, pres);&#125;private void inorderSuc(TreeNode root, double target, Stack&lt;Integer&gt; sucs)&#123; // reverse inorder if(root == null) return; inorderSuc(root.right, target, sucs); // find all larger suc if(root.val &lt; target) return; sucs.push(root.val); inorderSuc(root.left, target, sucs);&#125; #279-perfect-squares-mediumGiven a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. 1234567891011121314151617public int numSquares(int n) &#123; // use dp check prev sum int[] dp = new int[n+1]; // dp iteration for(int i=1; i&lt;=n; i++)&#123; // for num i, check all squares // curr square + (i-square) int min = Integer.MAX_VALUE; for(int j=1; j*j&lt;=i; j++)&#123; // dp[j*j] is 1 // so population not needed min = Math.min(min, dp[i-j*j] + 1); &#125; dp[i] = min; &#125; return dp[n];&#125; #285-inorder-successor-in-bst-mediumGiven a binary search tree and a node in it, find the in-order successor of that node in the BST. Note: If the given node has no in-order successor in the tree, return null. recursion: 12345678910public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123; if(root == null) return root; // if root &lt;= p, just check right side if(root.val &lt;= p.val) return inorderSuccessor(root.right,p); // if root &gt; p, root is possible result TreeNode result = inorderSuccessor(root.left,p); return result == null? root : result;&#125; iteration: 1234567891011121314public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123; if(root == null) return root; // if root.val &gt; p, it's possible result TreeNode result = null; while(root != null)&#123; if(root.val &gt; p.val)&#123; result = root; root = root.left; &#125;else root = root.right; &#125; return result;&#125; predecessor: 123456789public TreeNode inorderPredecessor(TreeNode root, TreeNode p) &#123; if(root == null) return null; // if root.val &lt; p, possible result if(root.val &gt;= p) return inorderPredecessor(root.left,p); TreeNode result = inorderPredecessor(root.right,p); return result == null ? root : result;&#125; #287-find-duplicate-number-mediumGiven an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: 123Input: [1,3,4,2,2]Output: 2[2,2,2,2] 1234567891011121314public int findDuplicate(int[] nums) &#123; // find entrance of cycle int slow = nums[0], fast = nums[0]; do&#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125;while(slow != fast); int idx1 = nums[0], idx2 = slow; while(idx1 != idx2)&#123; idx1 = nums[idx1]; idx2 = nums[idx2]; &#125; return idx1;&#125; #295-find-median-from-data-stream-hardMedian is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. Example: 12345addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2 1234567891011121314151617181920212223242526class MedianFinder &#123; // use two heap (min &amp; max) PriorityQueue&lt;Long&gt; minHeap, maxHeap; /** initialize your data structure here. */ public MedianFinder() &#123; minHeap = new PriorityQueue&lt;&gt;(); maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); &#125; public void addNum(int num) &#123; // left max heap, right min heap // every time add to left, maxHeap.offer((long)num); minHeap.offer(maxHeap.poll()); // keep max heap larger if(maxHeap.size() &lt; minHeap.size()) maxHeap.offer(minHeap.poll()); &#125; public double findMedian() &#123; if(minHeap.size() == maxHeap.size()) return (double)(minHeap.peek() + maxHeap.peek()) / 2; return (double)maxHeap.peek(); &#125;&#125; #297-encode-and-decode-binary-tree-hardSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. preorder bfs recursion 12345678910111213141516171819202122232425262728293031323334public class Codec &#123; // use preorder dfs // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); buildString(root,sb); return sb.toString(); &#125; private void buildString(TreeNode root,StringBuilder sb)&#123; if(root == null)&#123; sb.append(\"X\").append(\",\"); return; &#125; sb.append(root.val).append(\",\"); buildString(root.left,sb); buildString(root.right,sb); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.addAll(Arrays.asList(data.split(\",\"))); return buildTree(queue); &#125; private TreeNode buildTree(Queue&lt;String&gt; queue)&#123; String val = queue.poll(); if(val==null || val.equals(\"X\")) return null; TreeNode root = new TreeNode(Integer.parseInt(val)); root.left = buildTree(queue); root.right = buildTree(queue); return root; &#125;&#125; bfs iteration 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; if(root == null) return \"\"; StringBuilder sb = new StringBuilder(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); if(node == null)&#123; sb.append(\"X,\"); continue; &#125; sb.append(node.val+\",\"); queue.offer(node.left); queue.offer(node.right); &#125; return sb.toString(); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if(data==null || data.length()==0) return null; String[] values = data.split(\",\"); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); TreeNode root = new TreeNode(Integer.parseInt(values[0])); queue.offer(root); int idx = 1; while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); if(!values[idx].equals(\"X\"))&#123; node.left = new TreeNode(Integer.parseInt(values[idx])); queue.offer(node.left); &#125; idx++; if(!values[idx].equals(\"X\"))&#123; node.right = new TreeNode(Integer.parseInt(values[idx])); queue.offer(node.right); &#125; idx++; &#125; return root; &#125;&#125; #300-longest-increasing-subsequence-mediumGiven an unsorted array of integers, find the length of longest increasing subsequence. Example: 123Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. n^2 dp: 1234567891011121314public int lengthOfLIS(int[] nums) &#123; int[] dp = new int[nums.length]; int result = 0; for(int i=0; i&lt;nums.length; i++)&#123; int maxLen = 0; for(int j=0; j&lt;i; j++)&#123; if(nums[i] &gt; nums[j]) maxLen = Math.max(maxLen,dp[j]); &#125; dp[i] = maxLen + 1; result = Math.max(result,dp[i]); &#125; return result;&#125; binary search dp: 1234567891011121314151617181920public int lengthOfLIS(int[] nums) &#123; int[] dp = new int[nums.length]; // maintain an increasing dp array // use maxLen as tail int maxLen = 0; for(int num : nums)&#123; int left = 0, right = maxLen; while(left &lt; right)&#123; int mid = left + (right - left)/2; if(dp[mid] &lt; num) left = mid + 1; else right = mid; &#125; dp[left] = num; if(left == maxLen) maxLen ++; &#125; return maxLen;&#125; #313-supper-ugly-number-mediumWrite a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4. Note:(1) 1 is a super ugly number for any given primes.(2) The given numbers in primes are in ascending order.(3) 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000.(4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer. 1234567891011121314151617181920212223242526public int nthSuperUglyNumber(int n, int[] primes) &#123; // use idea of ugly number ii // array to save result, first is 1 int[] nums = new int[n]; nums[0] = 1; // array to save index int[] idx = new int[primes.length]; for(int i=1; i&lt;n; i++)&#123; // find min to be curr ugly num int ugly = Integer.MAX_VALUE; for(int j=0; j&lt;idx.length; j++)&#123; // nums[idx for j] * primes[j] int candidate = primes[j] * nums[idx[j]]; ugly = Math.min(ugly,candidate); &#125; // set curr result nums[i] = ugly; // update index for all primes for(int j=0; j&lt;idx.length; j++)&#123; int prev = nums[idx[j]]; if(prev * primes[j] == ugly) idx[j] ++; &#125; &#125; return nums[n-1];&#125; #325-max-size-subarray-sum-equals-k-mediumGiven an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn’t one, return 0 instead. Note:The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range. Example 1: Given nums = [1, -1, 5, -2, 3], k = 3,return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest) Example 2: Given nums = [-2, -1, 2, 1], k = 1,return 2. (because the subarray [-1, 2] sums to 1 and is the longest) 12345678910111213141516public int maxSubArrayLen(int[] nums, int k) &#123; if(nums==null || nums.length==0) return 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int sum = 0, maxLen = 0; for(int i=0; i&lt;nums.length; i++)&#123; sum += nums[i]; if(sum == k) maxLen = i + 1; else if(map.containsKey(sum - k)) maxLen = Math.max(maxLen,i-map.get(sum-k)); if(!map.containsKey(sum)) map.put(sum,i); &#125; return maxLen;&#125; #335-self-crossing-hardYou are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not. Example 1: 1234567Given x = [2, 1, 1, 2],?????? ????????&gt; ?Return true (self crossing) Example 2: 12345678Given x = [1, 2, 3, 4],????????? ????????????????&gt;Return false (not self crossing) Example 3: 123456Given x = [1, 1, 1, 1],?????? ??????&gt;Return true (self crossing) 12345678910111213141516171819202122public boolean isSelfCrossing(int[] x) &#123; // i could cross with i-3, i-4, i-5 if(x==null || x.length&lt;=3) return false; // start from 3 for(int i=3; i&lt;x.length; i++)&#123; // check i &amp; i-3 // 7 4: 7&gt;=5, 6&gt;=4 if(x[i]&gt;=x[i-2] &amp;&amp; x[i-1]&lt;=x[i-3]) return true; // check i &amp; i-4 // 7 3: 7+3&gt;=5, 6==4 if(i&gt;=4 &amp;&amp; x[i]+x[i-4]&gt;=x[i-2] &amp;&amp; x[i-1]==x[i-3]) return true; // check i &amp; i-5 // 7 2: 7+3&gt;=5, 5&gt;=3, 6+2&gt;=4, 6&lt;=4 !(4&gt;=2) if(i&gt;=5 &amp;&amp; x[i]+x[i-4]&gt;=x[i-2] &amp;&amp; x[i-2]&gt;=x[i-4] &amp;&amp; x[i-1]+x[i-5]&gt;=x[i-3] &amp;&amp; x[i-1]&lt;=x[i-3]) return true; &#125; return false;&#125; #350-intersection-of-two-arrays-easyGiven two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. sort O(nlogn) 12345678910111213141516171819public int[] intersect(int[] nums1, int[] nums2) &#123; Arrays.sort(nums1); Arrays.sort(nums2); int idx1 = 0, idx2 = 0; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(idx1 &lt; nums1.length &amp;&amp; idx2 &lt; nums2.length)&#123; if(nums1[idx1] == nums2[idx2])&#123; list.add(nums1[idx1]); idx1++;idx2++; &#125;else if(nums1[idx1] &lt; nums2[idx2]) idx1 ++; else idx2 ++; &#125; int[] result = new int[list.size()]; for(int i=0; i&lt;result.length; i++) result[i] = list.get(i); return result;&#125; map count O(1) 123456789101112131415161718public int[] intersect(int[] nums1, int[] nums2) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); if(nums1.length &gt; nums2.length) return intersect(nums2,nums1); for(int num : nums1) map.put(num,map.getOrDefault(num,0)+1); for(int num : nums2)&#123; if(map.getOrDefault(num,0) != 0)&#123; list.add(num); map.put(num,map.get(num)-1); &#125; &#125; int[] result = new int[list.size()]; for(int i=0; i&lt;result.length; i++) result[i] = list.get(i); return result;&#125; #371-sum-of-two-integers-easyCalculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example:Given a = 1 and b = 2, return 3. Iteration: 12345678910public int getSum(int a, int b) &#123; int sum = a, carry = b; while(carry != 0)&#123; int nextSum = sum ^ carry; int nextCarry = (sum &amp; carry) &lt;&lt; 1; sum = nextSum; carry = nextCarry; &#125; return sum;&#125; Recursion: 1234567public int getSum(int a, int b) &#123; if(b == 0) return a; int sum = a ^ b; int carry = (a &amp; b) &lt;&lt; 1; return getSum(sum,carry);&#125; #373-find-k-pairs-with-smallest-sum-mediumYou are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums. Example 1: 123456Given nums1 = [1,7,11], nums2 = [2,4,6], k = 3Return: [1,2],[1,4],[1,6]The first 3 pairs are returned from the sequence:[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 123456789101112131415161718192021222324public List&lt;int[]&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; List&lt;int[]&gt; result = new ArrayList&lt;&gt;(); if(nums1.length==0 || nums2.length==0) return result; PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;&gt;(k,new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1,int[] o2)&#123; return o1[0] + o1[1] - o2[0] - o2[1]; &#125; &#125;); // populate first array first, curr[2] save index for(int i=0;i&lt;nums1.length &amp;&amp; i&lt;k;i++) heap.offer(new int[]&#123;nums1[i],nums2[0],0&#125;); while(!heap.isEmpty() &amp;&amp; result.size()&lt;k)&#123; int[] curr = heap.poll(); int n1 = curr[0], n2 = curr[1], idx2 = curr[2]; result.add(new int[]&#123;n1,n2&#125;); if(idx2 == nums2.length - 1) continue; heap.offer(new int[]&#123;n1,nums2[idx2+1],idx2+1&#125;); &#125; return result;&#125; #378-k-th-smallest-element-in-a-sorted-matrix-mediumGiven a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: 12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. Could use Dijkstra Use heap init with row 123456789101112131415161718192021public int kthSmallest(int[][] matrix, int k) &#123; // similar to #373 if(matrix==null || matrix.length==0 || matrix[0].length==0) return -1; int m = matrix.length, n = matrix[0].length; // use [val,i,j] to save cell PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o1[0]-o2[0]); // init heap with first row, space O(c) for(int j=0; j&lt;n; ++j) heap.offer(new int[]&#123;matrix[0][j],0,j&#125;); // push cell below int[] curr = null; while(k &gt; 0 &amp;&amp; !heap.isEmpty())&#123; curr = heap.poll(); k--; int val = curr[0], i = curr[1], j = curr[2]; if(i + 1 &lt; m) heap.offer(new int[]&#123;matrix[i+1][j],i+1,j&#125;); &#125; return curr[0];&#125; if k th distinct: 1234567891011121314151617181920212223public int kthSmallest(int[][] matrix, int k) &#123; // similar to #373 if(matrix==null || matrix.length==0 || matrix[0].length==0) return -1; int m = matrix.length, n = matrix[0].length; // use [val,i,j] to save cell PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o1[0]-o2[0]); // init heap with first row, space O(c) for(int j=0; j&lt;n; ++j) heap.offer(new int[]&#123;matrix[0][j],0,j&#125;); // push cell below int[] curr = null, prev = null; while(k &gt; 0 &amp;&amp; !heap.isEmpty())&#123; curr = heap.poll(); if(prev==null || prev!=null &amp;&amp; curr[0]!=prev[0]) k--; prev = curr; int val = curr[0], i = curr[1], j = curr[2]; if(i + 1 &lt; m) heap.offer(new int[]&#123;matrix[i+1][j],i+1,j&#125;); &#125; return curr[0];&#125; Binary Search: 123456789101112131415161718192021public int kthSmallest(int[][] matrix, int k) &#123; if(matrix==null || matrix.length==0 || matrix[0].length==0) return 0; int row = matrix.length, col = matrix[0].length; int low = matrix[0][0], high = matrix[row-1][col-1]; while(low &lt; high)&#123; int mid = low + (high - low)/2; int count = 0; // count smallest num for(int i=0;i&lt;row;i++)&#123; int j = col - 1; while(j&gt;=0 &amp;&amp; matrix[i][j] &gt; mid) j --; count += j + 1; // count &lt;= mid &#125; if(count &lt; k) // mid too small low = mid + 1; else high = mid; &#125; return low;&#125; #384-shuffle-an-array-mediumShuffle a set of numbers without duplicates. Example: 123456789101112// Init an array with set 1, 2, and 3.int[] nums = &#123;1,2,3&#125;;Solution solution = new Solution(nums);// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.solution.shuffle();// Resets the array back to its original configuration [1,2,3].solution.reset();// Returns the random shuffling of array [1,2,3].solution.shuffle(); 12345678910111213141516171819202122232425262728293031323334class Solution &#123; int[] nums = null; Random random; public Solution(int[] nums) &#123; this.nums = nums; random = new Random(); &#125; /** Resets the array to its original configuration and return it. */ public int[] reset() &#123; return nums; &#125; /** Returns a random shuffling of the array. */ public int[] shuffle() &#123; int[] copy = nums.clone(); // i is at i P = 1/i+1 // i is not at i P = 1-1/i+1 = i/i+1 // i at the other i P = 1/ i; // i at each location 0 to i is 1/i+1 for(int i=1;i&lt;copy.length;i++)&#123; // nextInt(a) a is exclusive int j = random.nextInt(i+1); swap(copy,i,j); &#125; return copy; &#125; private void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; #388-longest-absolute-file-path-mediumSuppose we abstract our file system by a string in the following manner: The string &quot;dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext&quot; represents: 1234dir subdir1 subdir2 file.ext The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string &quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext&quot; represents: 1234567dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.ext The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is &quot;dir/subdir2/subsubdir2/file2.ext&quot;, and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Note: The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a .. Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. 123456789101112131415161718192021222324252627public int lengthLongestPath(String input) &#123; // use stack, // for a level, stack saves only higher level len // if same level exit then pop if(input == null) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(0); // dummy bottom int maxLen = 0; // every \\n =&gt; a folder or a file for(String s : input.split(\"\\n\"))&#123; // define the level // first level -1+1=0, \\t=&gt;1, \\t\\t=&gt;2 int level = s.lastIndexOf(\"\\t\") + 1; // check whether stack has only higher level // l0=&gt;size 1,l1=&gt;size 2,l2=&gt;size 3 while(stack.size() &gt; level+1) // find parent stack.pop(); // push curr level len to stack, remove \\t, add / int len = stack.peek() + s.length() - level + 1; stack.push(len); // if it's a file, compute maxlen if(s.contains(\".\")) maxLen = Math.max(maxLen,len - 1); // remove / &#125; return maxLen;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jliao011.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode Solutions 1 - 200","slug":"leetcode-1-200","date":"2018-05-27T07:31:15.000Z","updated":"2018-07-15T04:45:21.000Z","comments":true,"path":"2018/05/27/leetcode-1-200/","link":"","permalink":"https://jliao011.github.io/2018/05/27/leetcode-1-200/","excerpt":"","text":"1 ~ 100 101 ~ 200 #101-symmetric-tree-easy #102-level-order-traversal-medium #3-longest-substring-without-repeating-characters-medium #103-zigzag-level-order-traversal-medium #105-construct-tree-preorder-inorder-medium #106-construct-tree-inorder-postorder-medium #109-sorted-list-to-bst-medium #10-regular-expression-match-hard #110-balanced-binary-tree-easy #111-min-depth-of-binary-tree-easy #112-path-sum-easy #113-path-sum-ii-medium #114-flatten-binary-tree-to-linked-list-medium #115-distinct-subsequences-hard #116-populating-next-right-pointer-medium #117-populating-next-right-pointer-ii-medium #118-pascals-triangle-easy #29-divide-two-integers-medium #120-triangle-medium #22-generate-parentheses-medium #25-reverse-nodes-in-k-group-hard #126-word-ladder-ii-hard #127-word-ladder-medium #128-longest-consecutive-sequence-hard #130-surrounded-regions #31-next-permutation-medium #32-longest-valid-parentheses-hard #33-search-in-rotated-sorted-array-medium #133-clone-graph-medium #136-single-number-easy #38-count-and-say-easy #41-first-missing-positive-hard #141-linked-list-cycle-easy #42-trapping-rain-water-hard #142-linked-list-cycle-ii-medium #146-lru-cache-hard #149-max-points-on-a-line-hard #151-reverse-words-in-a-string-medium #156-binary-tree-upside-down-medium #159-longest-substring-with-at-most-2-distince-characters-hard #160-intersection-of-two-linked-list-easy #61-rotate-list-medium #62-unique-paths-medium #63-unique-paths-ii-medium #163-missing-ranges-medium #64-minimum-path-sum-medium #165-compare-version-numbers-medium #66-plus-one-easy #67-add-binary-easy #169-majority-element-easy #70-climbing-stairs-easy #71-simplify-path-medium #72-edit-distance-hard #73-set-matrix-zeros-medium #74-search-a-2d-matrix-medium #75-sort-colors-medium #76-minimun-window-substring-hard #77-combinations-medium #78-subsets-medium #79-word-search-medium #80-remove-duplicates-from-sorted-array-ii-medium #81-search-in-rotated-sorted-array-ii-medium #82-remove-duplicates-from-sorted-list-ii-medium #83-remove-duplicates-from-sorted-list-easy #84-largest-rectangle-in-histogram-hard #86-partition-list-medium #87-scramble-string-hard #88-merge-sorted-array-easy #89-gray-code-medium #90-subsets-ii-medium #92-reverse-linked-list-ii-medium #93-restore-ip-addresses-medium #94-binary-tree-inorder-traversal-medium #95-unique-bst-ii-medium #96-unique-bst-medium #97-interleaving-string-hard #98-validate-binary-search-tree-medium #100-same-tree-easy #3-longest-substring-without-repeating-characters-mediumGiven a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 12345678910111213public static int lengthOfLongestSubstringDistinct(String s) &#123; int maxLen = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // save character, index for (int head = 0, tail = 0; tail &lt; s.length(); tail++) &#123; // if duplicated, move head if (map.containsKey(s.charAt(tail))) // head cannot move back e.g. abbbbbba head = Math.max(head, map.get(s.charAt(tail)) + 1); map.put(s.charAt(tail), tail); maxLen = Math.max(maxLen, tail - head + 1); &#125; return maxLen;&#125; 12345678910public static int lengthOfLongestSubstringDistinctOPT(String s) &#123; int maxLen = 0; int[] bin = new int[26]; // case only alphabet, save index for (int head = 0, tail = 0; tail &lt; s.length(); tail++) &#123; head = Math.max(head, bin[s.charAt(tail) - 'a']); // maybe 0 bin[s.charAt(tail) - 'a'] = tail + 1; // save same's next maxLen = Math.max(maxLen, tail - head + 1); &#125; return maxLen;&#125; #10-regular-expression-match-hardGiven an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;. 12&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. 123456789101112131415161718192021222324252627282930313233 public boolean isMatch(String s, String p) &#123;if (s == null || p == null) return false;boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];dp[0][0] = true;// initial the first linefor (int j = 1; j &lt;= p.length(); j++) &#123; if (p.charAt(j - 1) == '*') dp[0][j] = dp[0][j - 2];&#125;// dp conditions:// (1) p.char == . || p.char == s.char// (2) p.char == *:// 1. treat as 0 : check i, j-2// 2. if p[j-1] == s.char || .: check i-1,jfor (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 1; j &lt;= p.length(); j++) &#123; if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) dp[i][j] = dp[i - 1][j - 1]; else if (p.charAt(j - 1) == '*') &#123; // check * is 0 dp[i][j] = dp[i][j - 2]; if (dp[i][j]) continue; // if p.prev equal or . if (p.charAt(j - 2) == s.charAt(i - 1) || p.charAt(j - 2) == '.') &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125;&#125;return dp[s.length()][p.length()]; &#125; #22-generate-parentheses-mediumGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 12345678910111213141516171819202122232425public List&lt;String&gt; generateParenthesis(int n) &#123; // utilizing backtracking List&lt;String&gt; result = new ArrayList&lt;&gt;(); backtrack(result,new StringBuilder(),0,0,n); return result;&#125;private void backtrack(List&lt;String&gt; result,StringBuilder temp,int left,int right,int n)&#123; if(temp.length() == n * 2)&#123; result.add(temp.toString()); return; &#125; int len = temp.length(); // append ( if(left &lt; n)&#123; temp.append('('); backtrack(result,temp,left+1,right,n); temp.setLength(len); &#125; // append ) if(right &lt; left)&#123; temp.append(')'); backtrack(result,temp,left,right+1,n); temp.setLength(len); &#125;&#125; #25-reverse-nodes-in-k-group-hardGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 12345678910111213141516171819202122232425262728293031public ListNode reverseKGroup(ListNode head, int k) &#123; // constant memory, cannot use recursion (dummy) if(head==null || k==1) return head; ListNode dummy = new ListNode(0), prev = dummy, tail = dummy, next = null, curr = null; prev.next = head; while(true)&#123; // find group first, k th node int count = 0; while(count&lt;k &amp;&amp; tail!=null)&#123; count ++; tail = tail.next; &#125; // less than k break if(tail == null) break; // reverse prev to curr // D -&gt; 1 -&gt; 2 -&gt; 3(T) -&gt; N // move 1 after 3: D 2 3 1 N head = prev.next; for(int i=0;i&lt;k-1;i++)&#123; next = prev.next; // save 1 prev.next = next.next; // assign head next.next = tail.next; // assign tail tail.next = next; &#125; prev = head; tail = head; &#125; return dummy.next;&#125; #29-divide-two-integers-mediumGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. 12345678910111213141516171819202122232425262728public int divide(int dividend, int divisor) &#123; if(divisor == 0) return Integer.MAX_VALUE; if(dividend == 0) return 0; if(divisor == 1) return dividend; if(divisor == -1) return dividend == Integer.MIN_VALUE? Integer.MAX_VALUE : -dividend; int sign = 1; if(dividend &lt; 0 ^ divisor &lt;0) sign = -1; long ldividend = Math.abs((long)dividend); // notice long inside long ldivisor = Math.abs((long)divisor); int result = 0; while(ldividend &gt;= ldivisor)&#123; long temp = ldivisor, multi = 1; while(temp &lt;&lt; 1 &lt; ldividend)&#123; temp &lt;&lt;= 1; multi &lt;&lt;= 1; &#125; ldividend -= temp; result += multi; &#125; return sign==1? result : -result;&#125; #31-next-permutation-mediumImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 12345678910111213141516171819202122232425public void nextPermutation(int[] nums) &#123; int head = nums.length - 2; while(head &gt;= 0 &amp;&amp; nums[head] &gt;= nums[head+1]) head --; if(head &gt;= 0)&#123; int tail = nums.length - 1; while(nums[tail] &lt;= nums[head]) tail --; swap(nums,head,tail); &#125; // if head == -1, just reverse reverse(nums,head+1,nums.length-1);&#125;private void reverse(int[] nums,int i,int j)&#123; while(i &lt; j)&#123; swap(nums,i,j); i++; j--; &#125;&#125;private void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; #32-longest-valid-parentheses-hardGiven a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. For &quot;(()&quot;, the longest valid parentheses substring is &quot;()&quot;, which has length = 2. Another example is &quot;)()())&quot;, where the longest valid parentheses substring is &quot;()()&quot;, which has length = 4. 1234567891011121314151617181920public int longestValidParentheses(String s) &#123; if(s==null || s.length()==0) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(-1); // for first pair if () int maxLen = 0; for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i) == '(') stack.push(i); else&#123; stack.pop(); if(stack.isEmpty())&#123; stack.push(i); // first not valid &#125;else&#123; maxLen = Math.max(maxLen,i-stack.peek()); &#125; &#125; &#125; return maxLen;&#125; #33-search-in-rotated-sorted-array-mediumSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1: 12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2: 12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 1234567891011121314151617181920212223242526public int search(int[] nums, int target) &#123; if(nums==null || nums.length==0) return -1; int left = 0, right = nums.length - 1; while(left &lt;= right)&#123; int mid = left + (right-left)/2; if(nums[mid] == target) return mid; // left half not rotate if(nums[left] &lt;= nums[mid])&#123; // mid in not rotate part if(nums[left]&lt;=target &amp;&amp; target&lt;nums[mid]) right = mid - 1; // mid in rotate part else left = mid + 1; // right half not rotate &#125;else&#123; // mid in not rotate part if(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right]) left = mid + 1; // mid in rotate part else right = mid -1; &#125; &#125; return -1;&#125; 36. Valid Sudoku (medium)Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character &#39;.&#39;. A partially filled sudoku which is valid. Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. 123456789101112131415161718192021222324252627public boolean isValidSudoku(char[][] board) &#123; if(board==null || board.length!=9 || board[0].length!=9) return false; Set&lt;Character&gt; rowSet = new HashSet&lt;&gt;(); Set&lt;Character&gt; colSet = new HashSet&lt;&gt;(); Set&lt;Character&gt; cubSet = new HashSet&lt;&gt;(); // check row, col, cube for(int row=0;row&lt;9;row++)&#123; rowSet.clear(); colSet.clear(); cubSet.clear(); for(int col=0;col&lt;9;col++)&#123; // left to right if(board[row][col]!='.' &amp;&amp; !rowSet.add(board[row][col])) return false; // up to down if(board[col][row]!='.' &amp;&amp; !colSet.add(board[col][row])) return false; // map to a cube int cubeRow = 3 * (row / 3) + col / 3; int cubeCol = 3 * (row % 3) + col % 3; if(board[cubeRow][cubeCol]!='.' &amp;&amp; !cubSet.add(board[cubeRow][cubeCol])) return false; &#125; &#125; return true;&#125; 37. Sudoku Solver (hard)Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character &#39;.&#39;. You may assume that there will be only one unique solution. A sudoku puzzle… …and its solution numbers marked in red. 123456789101112131415161718192021222324252627282930313233public void solveSudoku(char[][] board) &#123; if(board==null || board.length!=9 || board[0].length!=9) return; solver(board);&#125;private boolean solver(char[][] board)&#123; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; if(board[i][j] != '.') continue; for(char c='1';c&lt;='9';c++)&#123; if(isValid(board,i,j,c))&#123; board[i][j] = c; if(solver(board)) return true; board[i][j] = '.'; &#125; &#125; return false; &#125; &#125; return true;&#125;private boolean isValid(char[][] board,int i,int j,char c)&#123; for(int k=0;k&lt;9;k++)&#123; if(board[i][k] == c) return false; if(board[k][j] == c) return false; int row = 3 * (i / 3) + k / 3; int col = 3 * (j / 3) + k % 3; if(board[row][col] == c) return false; &#125; return true;&#125; #38-count-and-say-easyThe count-and-say sequence is the sequence of integers with the first five terms as following: 123451. 12. 113. 214. 12115. 111221 1 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211. Given an integer n, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string. Example 1: 12Input: 1Output: &quot;1&quot; Example 2: 12Input: 4Output: &quot;1211&quot; 123456789101112131415161718192021public String countAndSay(int n) &#123; if(n == 1) return \"1\"; String result = \"1\"; for(int i=2;i&lt;=n;i++)&#123; int idx = 0; StringBuilder sb = new StringBuilder(); while(idx &lt; result.length())&#123; char curr = result.charAt(idx); int count = 1; while(idx&lt;result.length()-1 &amp;&amp; result.charAt(idx)==result.charAt(idx+1))&#123; idx ++; count ++; &#125; sb.append(count).append(curr); idx ++; &#125; result = sb.toString(); &#125; return result;&#125; 39. Combination Sum (medium)Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: 1234[ [7], [2, 2, 3]] 12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; // use backtracking List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,candidates,new ArrayList&lt;&gt;(),target,0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] candidates,List&lt;Integer&gt; temp,int target,int idx)&#123; if(target &lt; 0) return; if(target == 0)&#123; // should build a new list result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=idx;i&lt;candidates.length;i++)&#123; temp.add(candidates[i]); // item repeatly used, should call i backtrack(result,candidates,temp,target-candidates[i],i); // remove after recursion temp.remove(temp.size()-1); &#125;&#125; 40. Combination Sum II (medium)Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is: 123456[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; // backtracking, duplicate element, use once List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(candidates); // to skip duplicate backtrack(result,candidates,new ArrayList&lt;&gt;(),target,0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] candidates,List&lt;Integer&gt; temp,int target,int idx)&#123; if(target &lt; 0) return; if(target == 0)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=idx;i&lt;candidates.length;i++)&#123; // here i &gt; idx not 0. to avoid duplicate // since same adjacent same element, so need sorting if(i&gt;idx &amp;&amp; candidates[i]==candidates[i-1]) continue; temp.add(candidates[i]); backtrack(result,candidates,temp,target-candidates[i],i+1); temp.remove(temp.size()-1); &#125;&#125; #41-first-missing-positive-hardGiven an unsorted integer array, find the first missing positive integer. For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 1234567891011121314151617public int firstMissingPositive(int[] nums) &#123; // swap pos num to corresponding index for(int i=0;i&lt;nums.length;i++)&#123; // use nums[i]-1 as index, cannot have cycle while(nums[i]&gt;0 &amp;&amp; nums[i]&lt;=nums.length &amp;&amp; nums[i]!=nums[nums[i]-1])&#123; int temp = nums[nums[i]-1]; nums[nums[i]-1] = nums[i]; nums[i] = temp; &#125; &#125; // traverse find nums[i]-1 != i for(int i=0;i&lt;nums.length;i++) if(nums[i] != i + 1) return i + 1; // beyond the bound return nums.length + 1;&#125; #42-trapping-rain-water-hardGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example,Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. DP approach O(n) &amp; O(n) 123456789101112131415161718192021222324public int trap(int[] height) &#123; // use dp 3 pass if(height.length == 0) return 0; // first pass find left max int[] left = new int[height.length]; int leftMax = height[0]; for(int i=0;i&lt;height.length;i++)&#123; leftMax = Math.max(leftMax,height[i]); left[i] = leftMax; &#125; // second pass find right max int[] right = new int[height.length]; int rightMax = height[height.length-1]; for(int i=height.length-1;i&gt;=0;i--)&#123; rightMax = Math.max(rightMax,height[i]); right[i] = rightMax; &#125; // third pass find water each idx int result = 0; for(int i=0;i&lt;height.length;i++) result += Math.min(left[i],right[i]) - height[i]; return result;&#125; Stack approach O(n) &amp; O(n) 12345678910111213141516171819202122public int trap(int[] height) &#123; // stack approaching if(height.length == 0) return 0; // use stack to save index Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int result = 0; for(int i=0;i&lt;height.length;i++)&#123; // if larger than prev while(!stack.isEmpty() &amp;&amp; height[i]&gt;height[stack.peek()])&#123; int currIdx = stack.pop(); if(stack.isEmpty()) break; // compare prev height and i height int h = Math.min(height[stack.peek()],height[i]) - height[currIdx]; int w = i - stack.peek() - 1; result += h * w; &#125; stack.push(i); &#125; return result;&#125; Two pointer approach O(n) &amp; O(1) 12345678910111213141516171819202122232425public int trap(int[] height) &#123; // two pointer if(height.length == 0) return 0; // left &amp; right max, int left = 0, right = height.length - 1; int leftMax = height[left], rightMax = height[right]; int result = 0; // stop when left&gt;right, should be &lt;= while(left &lt;= right)&#123; // case left ++ if(leftMax &lt; rightMax)&#123; if(height[left] &lt; leftMax) result += leftMax - height[left]; leftMax = Math.max(leftMax,height[left]); left ++; &#125;else&#123; // case right -- if(height[right] &lt; rightMax) result += rightMax - height[right]; rightMax = Math.max(rightMax,height[right]); right --; &#125; &#125; return result;&#125; 43. Multiply Strings (medium)Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2. Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. 1234567891011121314151617181920212223242526272829public String multiply(String num1, String num2) &#123; if(num1==null || num1.length()==0) return \"\"; if(num2==null || num2.length()==0) return \"\"; if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\"; int m = num1.length(), n = num2.length(); // num1 * num2 max len = m + n int[] result = new int[m+n]; // i bit * j bit head is at i+j for(int i=m-1;i&gt;=0;i--)&#123; for(int j=n-1;j&gt;=0;j--)&#123; int n1 = num1.charAt(i) - '0'; int n2 = num2.charAt(j) - '0'; int sum = n1 * n2 + result[i+j+1]; // one digit result[i+j+1] = sum % 10; // ten digit result[i+j] += sum / 10; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;result.length;i++)&#123; if(!(sb.length()==0 &amp;&amp; result[i]==0)) sb.append(result[i]); &#125; return sb.toString();&#125; 44. Wildcard Matching (hard)Implement wildcard pattern matching with support for &#39;?&#39; and &#39;*&#39;. 12345678910111213141516&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;*&quot;) → trueisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;ab&quot;, &quot;?*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false Similar method to regular expression match, DP approach 123456789101112131415161718192021222324public boolean isMatch(String s, String p) &#123; if(s==null || p==null) return false; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; // go through first row, * could match \"\" // first col is false, dont match \"\" for(int j=1;j&lt;=p.length();j++) if(p.charAt(j-1) == '*') dp[0][j] = dp[0][j-1]; // case 1: p.char==(s.char, ?) =&gt; dp[i][j] = dp[i-1][j-1] // case 2: p.char==* =&gt; * is \"\" dp[i][j] = dp[i][j-1] // =&gt; * is not \"\" dp[i][j] = dp[i-1][j]; for(int i=1;i&lt;=s.length();i++)&#123; for(int j=1;j&lt;=p.length();j++)&#123; if(p.charAt(j-1)==s.charAt(i-1) || p.charAt(j-1)=='?') dp[i][j] = dp[i-1][j-1]; else if(p.charAt(j-1) == '*') // * is sequence and * is blank dp[i][j] = dp[i-1][j] || dp[i][j-1]; &#125; &#125; return dp[s.length()][p.length()];&#125; 46. Permutations (distinct)(medium)Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations: 12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Backtracking add to temp 1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // use backtracking, remember to use visited List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,nums,new ArrayList&lt;&gt;(),new boolean[nums.length]); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,List&lt;Integer&gt; temp,boolean[] visited)&#123; if(temp.size() == nums.length)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; // check visited, i from 0 to n for(int i=0;i&lt;nums.length;i++)&#123; if(visited[i]) continue; visited[i] = true; temp.add(nums[i]); backtrack(result,nums,temp,visited); // reset when return to here visited[i] = false; temp.remove(temp.size()-1); &#125;&#125; Backtracking swap (quicker) 1234567891011121314151617181920212223242526public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,nums,0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,int idx)&#123; if(idx == nums.length)&#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for(int num: nums) temp.add(num); result.add(temp); return; &#125; for(int i=idx;i&lt;nums.length;i++)&#123; swap(nums,idx,i); // swap every position with idx backtrack(result,nums,idx+1); // swap back when return here swap(nums,idx,i); &#125;&#125;private void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; 47. Permutations II (duplicates)(medium)Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations: 12345[ [1,1,2], [1,2,1], [2,1,1]] 1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); // need sorting to remove duplicate Arrays.sort(nums); backtrack(result,nums,new ArrayList&lt;&gt;(),new boolean[nums.length]); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,List&lt;Integer&gt; temp,boolean[] used)&#123; if(temp.size() == nums.length)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; // both !used[i-1] and used[i-1] work if(used[i] || i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!used[i-1]) continue; used[i] = true; temp.add(nums[i]); backtrack(result,nums,temp,used); used[i] = false; temp.remove(temp.size()-1); &#125;&#125; 48. Rotate Image (medium)Rotate the image by 90 degrees (clockwise). Note:You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. clockwise: upside down first, then symmetry anti-clockwise: left right first, then symmetry 1234567891011121314151617181920212223242526public void rotate(int[][] matrix) &#123; if(matrix.length==0 || matrix[0].length==0) return; if(matrix.length != matrix[0].length) return; // upside down int n = matrix.length; for(int col=0;col&lt;n;col++)&#123; int up = 0, down = n-1; while(up &lt; down)&#123; int temp = matrix[up][col]; matrix[up][col] = matrix[down][col]; matrix[down][col] = temp; up ++; down --; &#125; &#125; // symmetry for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125;&#125; 49. Group Anagrams (medium)Given an array of strings, group anagrams together. For example, given: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Return: 12345[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lower-case. HashMap, return 123456789101112131415161718public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; // using hashtable // key is sorted str List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); if(strs.length == 0) return result; for(String str: strs)&#123; char[] c = str.toCharArray(); Arrays.sort(c); String key = new String(c); if(!map.containsKey(key)) map.put(key,new ArrayList&lt;&gt;()); map.get(key).add(str); &#125; // map.keySet() map.values() return new ArrayList&lt;&gt;(map.values());&#125; 50. Pow(x,n) (medium)recursion 12345678910111213141516public double myPow(double x, int n) &#123; if(n == 0) return 1; if(n &lt; 0)&#123; // deal with int.min // +2 could remain even or odd if(n == Integer.MIN_VALUE) n+=2; n = -n; x = 1 / x; &#125; if(n % 2 == 0) return myPow(x*x,n/2); else return x * myPow(x*x,n/2);&#125; iteration 1234567891011121314151617181920public double myPow(double x, int n) &#123; if(n == 0) return 1; if(n &lt; 0)&#123; // deal with int.min // +2 could remain even or odd if(n == Integer.MIN_VALUE) n+=2; n = -n; x = 1 / x; &#125; double result = 1; while(n &gt; 0)&#123; if((n &amp; 1) == 1) // n is odd result *= x; x *= x; n &gt;&gt;= 1; &#125; return result;&#125; 51. N-Queens (hard)backtracking The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively. For example,There exist two distinct solutions to the 4-queens puzzle: 1234567891011[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); // construct blank board char[][] board = new char[n][n]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) board[i][j] = '.'; // backtracking backtrack(result,board,0); return result; &#125;private void backtrack(List&lt;List&lt;String&gt;&gt; result,char[][] board,int col)&#123; if(col == board.length)&#123; result.add(build(board)); return; &#125; // for each row, try each col, only one loop need for(int row=0;row&lt;board.length;row++)&#123; if(isValid(board,row,col))&#123; board[row][col] = 'Q'; backtrack(result,board,col+1); board[row][col] = '.'; &#125; &#125;&#125;private boolean isValid(char[][] board,int row,int col)&#123; int n = board.length; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(board[i][j] == '.') continue; // in same row, same col, same diagnal if(i==row || j==col || Math.abs(i-row)==Math.abs(j-col)) return false; &#125; &#125; return true;&#125;private List&lt;String&gt; build(char[][] board)&#123; // build board to a result instance int n = board.length; List&lt;String&gt; rows = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++) rows.add(String.valueOf(board[i])); return rows;&#125; 52. N-Queens II (hard)Now, instead outputting board configurations, return the total number of distinct solutions. 123456789101112131415161718192021222324252627282930313233343536public int totalNQueens(int n) &#123; // only check valid cases // use 4 boolean arrays to mark: // 1. traverse each row, no check same row // 2. same col occupied // 3. 45 diagnal occupied: y=x+b =&gt; b=y-x constant // 4. 135 diagnal occupied y=-x+b =&gt; b=y+x constant // board has 2n-1 diagnals each case int[] result = new int[1]; boolean[] cols = new boolean[n]; // for col boolean[] diag1 = new boolean[2*n-1]; // for y-x boolean[] diag2 = new boolean[2*n-1]; // for y+x backtrack(result,0,cols,diag1,diag2); return result[0]; &#125;private void backtrack(int[] result,int col,boolean[] cols,boolean[] diag1,boolean[] diag2)&#123; // traverse along rows, int n = cols.length; if(col == n)&#123; result[0]++; return; &#125; for(int row=0;row&lt;n;row++)&#123; int idx1 = col - row + n - 1; // n-1 offset int idx2 = col + row; if(cols[row] || diag1[idx1] || diag2[idx2]) continue; cols[row] = true; diag1[idx1] = true; diag2[idx2] = true; backtrack(result,col+1,cols,diag1,diag2); cols[row] = false; diag1[idx1] = false; diag2[idx2] = false; &#125;&#125; 53. Maximum subarray (easy)Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. 123456789public int maxSubArray(int[] nums) &#123; // save currSum and maxSum int currSum = 0, maxSum = nums[0]; for(int num: nums)&#123; currSum = Math.max(num,num+currSum); maxSum = Math.max(maxSum,currSum); &#125; return maxSum;&#125; 54. Spiral Matrix (medium)Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example,Given the following matrix: 12345[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] You should return [1,2,3,6,9,8,7,4,5]. 123456789101112131415161718192021222324252627public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(matrix.length==0 || matrix[0].length==0) return result; int r1 = 0, r2 = matrix.length-1; int c1 = 0, c2 = matrix[0].length-1; while(r1&lt;=r2 &amp;&amp; c1&lt;=c2)&#123; // add all r1 for(int c=c1;c&lt;=c2;c++) result.add(matrix[r1][c]); // add all c2 for(int r=r1+1;r&lt;=r2;r++) result.add(matrix[r][c2]); // if las row or col break if(r1==r2 || c1==c2) break; // add all r2 for(int c=c2-1;c&gt;=c1+1;c--) result.add(matrix[r2][c]); // add all c1 for(int r=r2;r&gt;=r1+1;r--) result.add(matrix[r][c1]); // update r1++;r2--;c1++;c2--; &#125; return result;&#125; 55. Jump Game (medium)Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example:A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. end to head, check whether it’s a good point 1234567891011public boolean canJump(int[] nums) &#123; if(nums.length == 0) return false; // last index that is a good point int last = nums.length - 1; for(int i=last-1;i&gt;=0;i--)&#123; if(i + nums[i] &gt;= last) last = i; &#125; return last == 0;&#125; 56. Merge Intervals (medium)Given a collection of intervals, merge all overlapping intervals. For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18]. 12345678910111213141516171819202122232425/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); if(intervals==null || intervals.size()==0) return result; Collections.sort(intervals,(o1,o2)-&gt;o1.start-o2.start); Interval prev = null; for(Interval curr : intervals)&#123; // result blank or no overlapping if(prev==null || curr.start&gt;prev.end)&#123; prev = curr; result.add(prev); &#125;else // have overlapping prev.end = Math.max(prev.end,curr.end); &#125; return result;&#125; 57. Insert Interval (hard)Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1:Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9]. Example 2:Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 12345678910111213141516171819202122232425262728293031323334/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); // assume already sorted // Collections.sort(intervals,(o1,o2)-&gt;o1.start-o2.start); int idx = 0; // add intervals before newIntervals first, no overlapping while(idx&lt;intervals.size() &amp;&amp; intervals.get(idx).end&lt;newInterval.start)&#123; result.add(intervals.get(idx)); idx++; &#125; // merge overlapping intervals, curr.end &gt;= new.start while(idx&lt;intervals.size() &amp;&amp; intervals.get(idx).start&lt;=newInterval.end)&#123; Interval curr = intervals.get(idx); newInterval.start = Math.min(newInterval.start,curr.start); newInterval.end = Math.max(newInterval.end,curr.end); idx++; &#125; result.add(newInterval); // add intervals after newIntervals, no overlapping while(idx&lt;intervals.size())&#123; result.add(intervals.get(idx)); idx++; &#125; return result;&#125; 58. Length of Last Word (easy)Given a string s consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: 12Input: &quot;Hello World&quot;Output: 5 123456789public int lengthOfLastWord(String s) &#123; int tail = s.length()-1; while(tail&gt;=0 &amp;&amp; s.charAt(tail)==' ') tail--; int head = tail; while(head&gt;=0 &amp;&amp; s.charAt(head)!=' ') head--; return tail - head;&#125; 59. Spiral Matrix II (medium)Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. For example,Given n = 3, You should return the following matrix: 12345[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 1234567891011121314151617181920public int[][] generateMatrix(int n) &#123; int[][] result = new int[n][n]; int num = 1; int r1 = 0, r2 = n - 1; int c1 = 0, c2 = n - 1; while(r1&lt;=r2 &amp;&amp; c1&lt;=c2)&#123; for(int c=c1;c&lt;=c2;c++) result[r1][c] = num++; for(int r=r1+1;r&lt;=r2;r++) result[r][c2] = num++; if(r1==r2 || c1==c2) break; for(int c=c2-1;c&gt;=c1+1;c--) result[r2][c] = num++; for(int r=r2;r&gt;=r1+1;r--) result[r][c1] = num++; r1++;r2--;c1++;c2--; &#125; return result;&#125; 61. Rotate List (medium)Given a list, rotate the list to the right by k places, where k is non-negative. Example: 12Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public ListNode rotateRight(ListNode head, int k) &#123; // notice corner case if(head == null || head.next == null) return head; ListNode dummy = new ListNode(0), fast = dummy; dummy.next = head; // find length first, and end node int len = 0; while(fast.next != null)&#123; len ++; fast = fast.next; &#125; // find node before new head // k may larger than len =&gt; % ListNode slow = dummy; for(int i=0;i&lt;len-k%len;i++) slow = slow.next; // rotation order, fast.next = dummy.next; dummy.next = slow.next; slow.next = null; return dummy.next;&#125; 62. Unique Paths (medium)A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? Note: m and n will be at most 100. 1234567891011121314public int uniquePaths(int m, int n) &#123; // time O(mn), space O(min(m,n)) if(m &lt;= 0 || n &lt;=0) return 0; // use 1D dp int[] dp = new int[n]; Arrays.fill(dp,1); for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; dp[j] += dp[j-1]; &#125; &#125; return dp[n-1];&#125; 63. Unique Paths II (medium)Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example, There is one obstacle in the middle of a 3x3 grid as illustrated below. 12345[ [0,0,0], [0,1,0], [0,0,0]] The total number of unique paths is 2. 12345678910111213141516171819public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; // similar to previous, use 1D DP if(obstacleGrid==null || obstacleGrid.length==0 || obstacleGrid[0].length==0) return 0; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[] dp = new int[n]; dp[0] = 1; // init head as 0 for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; // obstacle, curr count reset 0 if(obstacleGrid[i][j] == 1) dp[j] = 0; // accumulate when j &gt; 0 else if(j &gt; 0) dp[j] += dp[j-1]; &#125; &#125; return dp[n-1];&#125; 64. Minimum Path Sum (medium)Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example 1: 123[[1,3,1], [1,5,1], [4,2,1]] Given the above grid map, return 17 . Because the path 1→3→1→1→1 minimizes the sum. 12345678910111213141516public int minPathSum(int[][] grid) &#123; if(grid==null || grid.length==0 || grid[0].length==0) return 0; int m = grid.length, n = grid[0].length; // go through first row for(int j=1;j&lt;n;j++) grid[0][j] += grid[0][j-1]; // go through first col for(int i=1;i&lt;m;i++) grid[i][0] += grid[i-1][0]; // go through other for(int i=1;i&lt;m;i++) for(int j=1;j&lt;n;j++) grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]); return grid[m-1][n-1];&#125; 66. Plus One (easy)Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. 123456789101112131415161718192021public int[] plusOne(int[] digits) &#123; if(digits==null || digits.length==0) return new int[0]; // if 9, continue check previous, // if not 9, +1 will stop for(int i=digits.length-1;i&gt;=0;i--)&#123; if(digits[i] == 9) digits[i] = 0; else&#123; digits[i] ++; break; &#125; &#125; // if all 0 if(digits[0] == 0)&#123; int[] result = new int[digits.length+1]; result[0] = 1; return result; &#125; return digits;&#125; 67-add-binary-easyGiven two binary strings, return their sum (also a binary string). For example,a = &quot;11&quot;b = &quot;1&quot;Return &quot;100&quot;. 12345678910111213141516171819public String addBinary(String a, String b) &#123; if(a == null || b == null) return \"\"; // use string builder and reverse StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() - 1; int sum = 0; while(i &gt;= 0 || j &gt;= 0)&#123; if(i &gt;= 0) sum += a.charAt(i--) - '0'; if(j &gt;= 0) sum += b.charAt(j--) - '0'; sb.append(sum % 2); sum /= 2; &#125; if(sum != 0) sb.append(sum); return sb.reverse().toString(); &#125; 69. int sqrt(x) (easy)binary search 12345678910111213141516public int mySqrt(int x) &#123; if(x &lt;= 1) return x; int left = 1, right = x; while(true)&#123; int mid = left + (right-left)/2; if(mid &gt; x / mid) right = mid - 1; else&#123; // mid^2 &lt; x but mid+1 ^2 &gt; x if(mid+1 &gt; x/(mid+1)) return mid; left = mid + 1; &#125; &#125;&#125; #70-climbing-stairs-easyYou are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. **Example 2: 1234567Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step basic: Assume T(n-1) = O(2`n-1)`, therefore T(n) = T(n-1) + T(n-2) + O(1) which is equal to T(n) = O(2`n-1) + O(2n-2) + O(1) = O(2n)` 123456789101112public int climbStairs(int n) &#123; // n step is count n-1 step + count n-2 step if(n &lt;= 2) return n; int first = 1, second = 2, curr = 0; for(int i=3;i&lt;=n;i++)&#123; curr = first + second; first = second; second = curr; &#125; return curr;&#125; add memo top down: 1234567891011121314public int climbStairs(int n) &#123; // 0:1, 1:1, 2:2, 3:3, 4:5, 5:8 if(n &lt;= 1) return 1; int[] memo = new int[n+1]; return helper(n,memo);&#125;private int helper(int n,int[] memo)&#123; if(n &lt;= 1) return 1; if(memo[n] != 0) return memo[n]; memo[n] = helper(n-1,memo) + helper(n-2,memo); return memo[n];&#125; top down dp iteration space O(n) 12345678public int climbStairs(int n) &#123; int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for(int i=2; i&lt;=n; i++) dp[i] = dp[i-1] + dp[i-2]; return dp[n];&#125; iteration O(1) 1234567891011public int climbStairs(int n) &#123; if(n &lt;= 1) return 1; int first = 1, second = 1, result = 0; for(int i=2; i&lt;=n; i++)&#123; result = first + second; first = second; second = result; &#125; return result;&#125; #71-simplify-path-mediumGiven an absolute path for a file (Unix-style), simplify it. For example,path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot; Did you consider the case where path = &quot;/../&quot;?In this case, you should return &quot;/&quot;. Another corner case is the path might contain multiple slashes &#39;/&#39; together, such as &quot;/home//foo/&quot;.In this case, you should ignore redundant slashes and return &quot;/home/foo&quot;. 1234567891011121314151617181920212223242526272829public String simplifyPath(String path) &#123; // use stack .. pop else push if(path == null || path.length() == 0) return \"\"; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for(String s : path.split(\"/\"))&#123; // case .(curr folder) continue if(s.equals(\".\")) continue; // case .. prev folder else if(s.equals(\"..\"))&#123; if(!stack.isEmpty()) stack.pop(); // case name dir, not empty, not /// &#125;else if(!s.isEmpty())&#123; stack.push(s); &#125; &#125; // case / if(stack.isEmpty()) return \"/\"; // pop and build result StringBuilder sb = new StringBuilder(); // build list from stack List&lt;String&gt; list = new ArrayList&lt;&gt;(stack); for(String s : list) sb.append(\"/\").append(s); return sb.toString();&#125; #72-edit-distance-hardGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: 123456Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;) Example 2: 12345678Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;) 123456789101112131415161718192021222324252627282930public int minDistance(String word1, String word2) &#123; // similar regex if(word1==null || word2==null) return 0; // row word1, col word2 int[][] dp = new int[word2.length()+1][word1.length()+1]; // init first row: word1 to \"\" for(int j=0; j&lt;word1.length(); j++) dp[0][j+1] = dp[0][j] + 1; // init first col: \"\" to word2 for(int i=0; i&lt;word2.length(); i++) dp[i+1][0] = dp[i][0] + 1; // the other for(int i=0; i&lt;word2.length(); i++)&#123; for(int j=0; j&lt;word1.length(); j++)&#123; // char1 != char2: // 1. insert: dp[i][j] = dp[i-1][j]+1; // 2. replace: dp[i][j] = dp[i-1][j-1]+1; // 3. delete: dp[i][j] = dp[i][j-1]+1; if(word2.charAt(i) != word1.charAt(j))&#123; dp[i+1][j+1] = 1 + Math.min(dp[i][j], Math.min(dp[i][j+1], dp[i+1][j])); &#125;else // case char1 == char2 dp[i+1][j+1] = dp[i][j]; &#125; &#125; return dp[word2.length()][word1.length()];&#125; #73-set-matrix-zeros-mediumGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Did you use extra space?A straight forward solution using O(m**n) space is probably a bad idea.A simple improvement uses O(m + n) space, but still not the best solution.Could you devise a constant space solution? 123456789101112131415161718192021222324252627282930313233343536373839public void setZeroes(int[][] matrix) &#123; // set all leading row &amp; col to zeros if(matrix.length==0 || matrix[0].length==0) return; boolean firstRow = false, firstCol = false; int row = matrix.length, col = matrix[0].length; // check first col for(int i=0;i&lt;row;i++) if(matrix[i][0] == 0) firstCol = true; // check first row for(int j=0;j&lt;col;j++) if(matrix[0][j] == 0) firstRow = true; // the other for(int i=1;i&lt;row;i++)&#123; for(int j=1;j&lt;col;j++)&#123; if(matrix[i][j] == 0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; // set 0 skip first row &amp; col for(int i=1;i&lt;row;i++)&#123; for(int j=1;j&lt;col;j++)&#123; if(matrix[i][0]==0 || matrix[0][j]==0) matrix[i][j] = 0; &#125; &#125; // update first row &amp; col can cause problem // update first row &amp; col if(firstRow) for(int j=0;j&lt;col;j++) matrix[0][j] = 0; if(firstCol) for(int i=0;i&lt;row;i++) matrix[i][0] = 0;&#125; #74-search-a-2d-matrix-mediumWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example, Consider the following matrix: 12345[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] Given target = 3, return true. 1234567891011121314151617181920public boolean searchMatrix(int[][] matrix, int target) &#123; // convert to binary search if(matrix==null || matrix.length==0 || matrix[0].length==0) return false; final int m = matrix.length, n = matrix[0].length; // left right should be index int left = 0, right = m * n - 1; while(left &lt;= right)&#123; int mid = left + (right-left)/2; int row = mid / n; int col = mid % n; if(matrix[row][col] == target) return true; else if(matrix[row][col] &lt; target) left = mid + 1; else right = mid - 1; &#125; return false;&#125; #75-sort-colors-mediumGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem. 1234567891011121314151617181920public void sortColors(int[] nums) &#123; // 0000|i|1111|j|????|k|2222 if(nums==null || nums.length==0) return; int i = 0, j = 0, k = nums.length-1; // j is unvisited, notice j = k while(j &lt;= k)&#123; if(nums[j] == 0)&#123; swap(nums,i++,j++); &#125;else if(nums[j] == 1) j++; else if(nums[j] == 2) swap(nums,j,k--); &#125;&#125;private void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; 123456789101112131415161718public void sortColors(int[] nums) &#123; // 0000|i|1111|j|????|k|2222 if(nums==null || nums.length==0) return; int i = 0, j = 0, k = nums.length-1; // j is unvisited, notice j = k while(j &lt;= k)&#123; if(nums[j] == 0)&#123; nums[j++] = nums[i]; nums[i++] = 0; &#125;else if(nums[j] == 1)&#123; j ++; &#125;else if(nums[j] == 2)&#123; nums[j] = nums[k]; nums[k--] = 2; &#125; &#125;&#125; #76-minimun-window-substring-hardGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). For example,S = &quot;ADOBECODEBANC&quot;T = &quot;ABC&quot; Minimum window is &quot;BANC&quot;. Note:If there is no such window in S that covers all characters in T, return the empty string &quot;&quot;. If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S. 1234567891011121314151617181920212223242526272829public String minWindow(String s, String t) &#123; if(s==null || t==null) return \"\"; // find t histogram first int[] bin = new int[256]; for(char c : t.toCharArray()) bin[c] ++; // sliding window int head = 0, count = t.length(); int minLen = s.length() + 1, minHead = 0; for(int tail=0;tail&lt;s.length();tail++)&#123; if(bin[s.charAt(tail)] &gt; 0) count --; bin[s.charAt(tail)]--; // valid edge condition while(count == 0)&#123; // update min then shift window if(tail-head+1 &lt; minLen)&#123; minLen = tail - head + 1; minHead = head; &#125; if(bin[s.charAt(head)] == 0) count ++; bin[s.charAt(head)]++; head++; &#125; &#125; return minLen &gt; s.length() ? \"\" : s.substring(minHead,minHead+minLen);&#125; #77-combinations-mediumGiven two integers n and k, return all possible combinations of k numbers out of 1 … n. For example,If n = 4 and k = 2, a solution is: 12345678[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; // backtracking List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,new ArrayList&lt;&gt;(),1,n,k); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,List&lt;Integer&gt; temp,int start,int end,int count)&#123; // optimization here, if start to close to end so no enough elements if(count - temp.size() &gt; end - start + 1) return; ////////////////////////////////////// if(temp.size() == count)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=start;i&lt;=end;i++)&#123; temp.add(i); backtrack(result,temp,i+1,end,count); temp.remove(temp.size()-1); &#125;&#125; #78-subsets-mediumGiven a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; // backtracking // distinct List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,nums,new ArrayList&lt;&gt;(),0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result, int[] nums,List&lt;Integer&gt; temp,int idx)&#123; // add result each level result.add(new ArrayList&lt;&gt;(temp)); for(int i=idx;i&lt;nums.length;i++)&#123; temp.add(nums[i]); backtrack(result,nums,temp,i+1); temp.remove(temp.size()-1); &#125;&#125; #79-word-search-mediumGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example,Given board = 12345[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]] word = &quot;ABCCED&quot;, -&gt; returns true, word = &quot;SEE&quot;, -&gt; returns true, word = &quot;ABCB&quot;, -&gt; returns false. 12345678910111213141516171819202122232425262728293031public boolean exist(char[][] board, String word) &#123; // similar to num of island // use ^256 to obtain space O(1) if(board==null || board.length==0 || board[0].length==0) return false; final int m = board.length, n = board[0].length; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(helper(board,word,0,i,j)) return true; &#125; &#125; return false;&#125;private boolean helper(char[][] board,String word,int idx,int x,int y)&#123; if(idx == word.length()) return true; if(x&lt;0 || x&gt;=board.length || y&lt;0 || y&gt;=board[0].length || word.charAt(idx)!=board[x][y]) return false; // set to not a valid letter board[x][y] ^= 256; if(helper(board,word,idx+1,x-1,y) || helper(board,word,idx+1,x+1,y) || helper(board,word,idx+1,x,y-1) || helper(board,word,idx+1,x,y+1)) return true; // reset to letter board[x][y] ^= 256; return false;&#125; #80-remove-duplicates-from-sorted-array-ii-mediumFollow up for “Remove Duplicates”:What if duplicates are allowed at most twice? For example,Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length. 1234567891011121314151617181920212223242526public int removeDuplicates(int[] nums) &#123; if(nums==null) return 0; if(nums.length &lt;= 2) return nums.length; int tail = 2; // similar but check tail - 2 for(int i=2;i&lt;nums.length;i++)&#123; if(nums[i] != nums[tail-2]) nums[tail++] = nums[i]; &#125; return tail;&#125;public int removeDuplicates(int[] nums) &#123; // optimized if(nums==null) return 0; if(nums.length &lt;= 2) return nums.length; int tail = 0; for(int num : nums)&#123; if(tail &lt; 2 || num != nums[tail-2]) nums[tail++] = num; &#125; return tail;&#125; #81-search-in-rotated-sorted-array-ii-medium Follow up for “Search in Rotated Sorted Array”:What if duplicates are allowed? Would this affect the run-time complexity? How and why? #33-search-in-rotated-sorted-array-medium Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. 12345678910111213141516171819202122232425262728293031323334353637 public boolean search(int[] nums, int target) &#123;// 1) everytime check if targe == nums[mid], if so, we find it.// 2) otherwise, we check if the first half is in order (i.e. nums[left]&lt;=nums[mid]) // and if so, go to step 3), otherwise, the second half is in order, go to step 4)// 3) check if target in the range of [left, mid-1] (i.e. nums[left]&lt;=target &lt; nums[mid]), // if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;// 4) check if target in the range of [mid+1, right] (i.e. nums[mid]&lt;target &lt;= nums[right]), // if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1; if(nums==null || nums.length==0) return false; int left = 0, right = nums.length - 1; while(left &lt;= right)&#123; int mid = left + (right-left)/2; if(nums[mid] == target) return true; // difference to deal with duplicate here if(nums[left]==nums[mid] &amp;&amp; nums[mid]==nums[right])&#123; left++; right--; // left half not rotate &#125;else if(nums[left] &lt;= nums[mid])&#123; // mid in not rotate part if(nums[left]&lt;=target &amp;&amp; target&lt;nums[mid]) right = mid - 1; // mid in rotate part else left = mid + 1; // right half not rotate &#125;else if(nums[mid] &lt;= nums[right])&#123; // mid in not rotate part if(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right]) left = mid + 1; // mid in rotate part else right = mid -1; &#125; &#125; return false; &#125; #82-remove-duplicates-from-sorted-list-ii-mediumGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode dummy = new ListNode(0); ListNode prev = dummy, curr = head; dummy.next = head; while(curr != null)&#123; // if next val = curr val, check next while(curr.next!=null &amp;&amp; curr.val==curr.next.val) curr = curr.next; // if curr is distinct if(prev.next == curr) prev = prev.next; else // prev stays, case next sequence duplication // curr is the last duplication prev.next = curr.next; curr = curr.next; &#125; return dummy.next;&#125; #83-remove-duplicates-from-sorted-list-easyGiven a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. iteration 1234567891011public ListNode deleteDuplicates(ListNode head) &#123; if(head==null || head.next==null) return head; ListNode curr = head; while(curr != null)&#123; while(curr.next!=null &amp;&amp; curr.val==curr.next.val) curr.next = curr.next.next; curr = curr.next; &#125; return head;&#125; recursion 1234567public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); // here head.next != null return head.val == head.next.val ? head.next : head;&#125; #84-largest-rectangle-in-histogram-hardGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. For example,Given heights = [2,1,5,6,2,3],return 10. #42-trapping-rain-water-hard 123456789101112131415161718192021// Maintains an increasing stack// encounter smaller height, check all previous areas.public int largestRectangleArea(int[] heights) &#123; Stack&lt;Integer&gt; idxStack = new Stack&lt;&gt;(); int maxArea = 0; for (int i = 0; i &lt;= heights.length; i++) &#123; // push -1 for last, to pop all previous int height = i == heights.length ? 0 : heights[i]; // when increasing is broken while (!idxStack.isEmpty() &amp;&amp; heights[idxStack.peek()] &gt;= height) &#123; // get previous higher one, compute previous area // it's all area from smaller to the highest int h = heights[idxStack.pop()]; // if is empty, there is a bottom rectangle from current to head int w = idxStack.isEmpty() ? i : i - 1 - idxStack.peek(); maxArea = Math.max(maxArea, h * w); &#125; idxStack.push(i); &#125; return maxArea;&#125; optimized beats 98%, check left then right idea 1234567891011121314151617181920212223242526272829public int largestRectangleArea(int[] heights) &#123; // save left and right index // width is most left &amp; right idx whose h is larger if(heights==null || heights.length==0) return 0; int[] left = new int[heights.length]; int[] right = new int[heights.length]; // find left/right index whose h is larger // utilize previous result to reduce run time for(int i=0;i&lt;heights.length;i++)&#123; int l = i-1; while(l&gt;=0 &amp;&amp; heights[l]&gt;=heights[i]) l = left[l]; left[i] = l; &#125; for(int i=heights.length-1;i&gt;=0;i--)&#123; int r = i+1; while(r&lt;heights.length &amp;&amp; heights[r]&gt;=heights[i]) r = right[r]; right[i] = r; &#125; // then for h, the width is r - l - 1; int maxArea = 0; for(int i=0;i&lt;heights.length;i++)&#123; int w = right[i] - left[i] - 1; maxArea = Math.max(maxArea,heights[i]*w); &#125; return maxArea;&#125; #86-partition-list-mediumGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: 12Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 12345678910111213141516171819public ListNode partition(ListNode head, int x) &#123; // use two head; ListNode dummy1 = new ListNode(0), prev1 = dummy1; ListNode dummy2 = new ListNode(0), prev2 = dummy2; while(head != null)&#123; if(head.val &lt; x)&#123; prev1.next = head; prev1 = prev1.next; &#125;else&#123; prev2.next = head; prev2 = prev2.next; &#125; head = head.next; &#125; // combine two list prev1.next = dummy2.next; prev2.next = null; return dummy1.next;&#125; #87-scramble-string-hardGiven a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = &quot;great&quot;: 1234567 great / \\ gr eat / \\ / \\g r e at / \\ a t To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;. 1234567 rgeat / \\ rg eat / \\ / \\r g e at / \\ a t We say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;. Similarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;. 1234567 rgtae / \\ rg tae / \\ / \\r g ta e / \\ t a We say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: 12Input: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;Output: true Example 2: 12Input: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;Output: false 12345678910111213141516171819202122232425262728public boolean isScramble(String s1, String s2) &#123; // check all possible case if(s1.equals(s2)) return true; // check char count int[] bin = new int[256]; for(int i=0; i&lt;s1.length(); i++)&#123; bin[s1.charAt(i)]++; bin[s2.charAt(i)]--; &#125; // check is char equal for(int n : bin) if(n != 0) return false; // recursion call, check all substring // origin not include, from 1 to length for(int i=1; i&lt;s1.length(); i++)&#123; // a b | c d e, a b | d e c if(isScramble(s1.substring(0,i),s2.substring(0,i)) &amp;&amp; isScramble(s1.substring(i),s2.substring(i))) return true; // a b | c d e, c d e | a b if(isScramble(s1.substring(0,i),s2.substring(s2.length()-i)) &amp;&amp; isScramble(s1.substring(i),s2.substring(0,s2.length()-i))) return true; &#125; return false;&#125; #88-merge-sorted-array-easyGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: 12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 12345678public void merge(int[] nums1, int m, int[] nums2, int n) &#123; // from end to head, int i = m - 1, j = n - 1, k = m + n - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) nums1[k--] = nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--]; while(j &gt;= 0) // nums2 rest nums1[k--] = nums2[j--];&#125; #89-gray-code-mediumThe gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given n = 2, return [0,1,3,2]. Its gray code sequence is: 123400 - 001 - 111 - 310 - 2 Note:For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. 123456789public List&lt;Integer&gt; grayCode(int n) &#123; // bit manipulate List&lt;Integer&gt; result = new ArrayList(); // total should &lt; 1 &lt;&lt; n for(int i=0; i &lt; 1&lt;&lt;n; i++)&#123; result.add(i ^ i&gt;&gt;1); &#125; return result;&#125; #90-subsets-ii-mediumGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 12345678910Input: [1,2,2]Output:[ [2], [1], [1,2,2], [2,2], [1,2], []] 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); // since remove duplicate, need sorting Arrays.sort(nums); backtrack(result,nums,new ArrayList&lt;&gt;(),0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,List&lt;Integer&gt; temp,int idx)&#123; // no need to check result.add(new ArrayList&lt;&gt;(temp)); for(int i=idx;i&lt;nums.length;i++)&#123; // jump duplicate // notice its &gt; idx not &gt; 0 if(i&gt;idx &amp;&amp; nums[i]==nums[i-1]) continue; temp.add(nums[i]); backtrack(result,nums,temp,i+1); temp.remove(temp.size()-1); &#125;&#125; #92-reverse-linked-list-ii-mediumReverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 1234567891011121314151617public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummy = new ListNode(0); ListNode start = dummy; dummy.next = head; // find slow prev first for(int i=1; i&lt;m; i++) start = start.next; // end not change, curr for saving ListNode end = start.next, curr = null; for(int i=0; i&lt;n-m; i++)&#123; curr = end.next; end.next = curr.next; curr.next = start.next; start.next = curr; &#125; return dummy.next;&#125; #93-restore-ip-addresses-mediumGiven a string containing only digits, restore it by returning all possible valid IP address combinations. Example: 12Input: &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 12345678910111213141516171819202122232425262728293031public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); backtrack(result,s,new StringBuilder(),0,1); return result;&#125;private void backtrack(List&lt;String&gt; result,String s,StringBuilder sb,int idx,int block)&#123; // to 5 block and s is empty if(block == 5 &amp;&amp; idx == s.length())&#123; result.add(sb.toString()); return; &#125; // s left or block left if(block &gt; 4 || idx == s.length()) return; int len = sb.length(); // for reset // one block most 3 digit for(int i=1; i&lt;4 &amp;&amp; idx+i&lt;=s.length(); i++)&#123; String partition = s.substring(idx,idx+i); // case 001 &amp;&amp; 256 if(i!=1 &amp;&amp; partition.charAt(0)=='0' || i==3 &amp;&amp; Integer.parseInt(partition)&gt;255) continue; sb.append(partition); // for seperator if(block &lt; 4) sb.append('.'); // backtrack backtrack(result,s,sb,idx+i,block+1); sb.setLength(len); &#125;&#125; #94-binary-tree-inorder-traversal-mediumRecursion: 123456789101112public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); dfs(root,result); return result;&#125;private void dfs(TreeNode root,List&lt;Integer&gt; result)&#123; if(root == null) return; dfs(root.left,result); result.add(root.val); dfs(root.right,result);&#125; Iteration: 123456789101112131415public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.isEmpty() || root!=null)&#123; if(root != null)&#123; stack.push(root); root = root.left; &#125;else&#123; TreeNode curr = stack.pop(); result.add(curr.val); root = curr.right; &#125; &#125; return result;&#125; #95-unique-bst-ii-mediumGiven an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. Example: 1234567891011121314151617Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&apos;s shown below: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 1234567891011121314151617181920212223242526272829public List&lt;TreeNode&gt; generateTrees(int n) &#123; if(n == 0) return new ArrayList&lt;&gt;(); return helper(1,n); &#125;public List&lt;TreeNode&gt; helper(int left,int right)&#123; List&lt;TreeNode&gt; trees = new ArrayList&lt;&gt;(); if(left &gt; right)&#123; trees.add(null); return trees; &#125; if(left == right)&#123; trees.add(new TreeNode(left)); return trees; &#125; for(int rootVal=left; rootVal&lt;=right; rootVal++)&#123; List&lt;TreeNode&gt; leftSubTrees = helper(left,rootVal-1); List&lt;TreeNode&gt; rightSubTrees = helper(rootVal+1,right); for(TreeNode l : leftSubTrees)&#123; for(TreeNode r : rightSubTrees)&#123; TreeNode root = new TreeNode(rootVal); root.left = l; root.right = r; trees.add(root); &#125; &#125; &#125; return trees;&#125; #96-unique-bst-mediumGiven n, how many structurally unique BST’s (binary search trees) that store values 1 … n? Example: 12345678910Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST&apos;s: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 12345678910111213141516public int numTrees(int n) &#123; // for n = 5 // if 1 as root, dp[0] * dp[4] // if 2 as root, dp[1] * dp[3] // if 3 as root, dp[2] * dp[2] // if 4 as root, dp[3] * dp[1] // if 5 as root, dp[4] * dp[0] // find how many node in left &amp; right subtree int[] dp = new int[n+1]; dp[0] = 1; // use 1 * the other subtree dp[1] = 1; for(int i=2; i&lt;=n; ++i) for(int j=0; j&lt;i; ++j) dp[i] += dp[j] * dp[i-1-j]; return dp[n];&#125; #97-interleaving-string-hardGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: 12Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;Output: true Example 2: 12Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;Output: false 12345678910111213141516171819202122232425262728293031public boolean isInterleave(String s1, String s2, String s3) &#123; if(s1==null || s2==null || s3==null) return false; if(s1.length() + s2.length() != s3.length()) return false; // s2 row, s1 col boolean[][] dp = new boolean[s1.length()+1][s2.length()+1]; dp[0][0] = true; // \"\" + \"\" == \"\" // init first row: check j-1 &amp;&amp; char==char for s2 for(int j=0; j&lt;s2.length(); j++) dp[0][j+1] = dp[0][j] &amp;&amp; s2.charAt(j)==s3.charAt(j); // init first col: check i-1 &amp;&amp; char==char for s1 for(int i=0; i&lt;s1.length(); i++) dp[i+1][0] = dp[i][0] &amp;&amp; s1.charAt(i)==s3.charAt(i); // dp for(int i=0; i&lt;s1.length(); i++)&#123; for(int j=0; j&lt;s2.length(); j++)&#123; // case1, add s1.char at tail // [i-1][j] &amp;&amp; s1.char==s3.char // case2, add s2.char at tail // [i][j-1] &amp;&amp; s2.char==s3.char char c1 = s1.charAt(i); char c2 = s2.charAt(j); char c3 = s3.charAt(i+j+1); // notice +1 // use if will quicker dp[i+1][j+1] = (dp[i][j+1] &amp;&amp; c1==c3) || (dp[i+1][j] &amp;&amp; c2==c3); &#125; &#125; return dp[s1.length()][s2.length()];&#125; #98-validate-binary-search-tree-mediumGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 1234567891011121314151617181920public boolean isValidBST(TreeNode root) &#123; // inorder iteration Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode prev = null; while(!stack.isEmpty() || root!=null)&#123; if(root != null)&#123; stack.push(root); root = root.left; &#125;else&#123; TreeNode curr = stack.pop(); // do inorder here if(prev==null || prev.val&lt;curr.val) prev = curr; // valid, mush &lt; else return false; root = curr.right; &#125; &#125; return true;&#125; #100-same-tree-easy123456789public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p==null &amp;&amp; q==null) return true; if(p==null || q==null) return false; if(p.val == q.val) return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); return false;&#125; #101-symmetric-tree-easyrecursion: 12345678910111213public boolean isSymmetric(TreeNode root) &#123; return root == null || isSymmetric(root.left,root.right); &#125;private boolean isSymmetric(TreeNode left,TreeNode right)&#123; if(left == null &amp;&amp; right == null) return true; if(left == null || right == null) return false; if(left.val == right.val) return isSymmetric(left.left,right.right) &amp;&amp; isSymmetric(left.right,right.left); return false;&#125; iteration: 12345678910111213141516171819202122public boolean isSymmetric(TreeNode root) &#123; if(root == null) return true; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root.left); queue.offer(root.right); while(queue.size() &gt;= 2)&#123; TreeNode left = queue.poll(); TreeNode right = queue.poll(); if(left==null &amp;&amp; right==null) continue; if(left==null || right==null) return false; if(left.val != right.val) return false; queue.add(left.left); queue.add(right.right); queue.add(left.right); queue.add(right.left); &#125; return true;&#125; #102-level-order-traversal-mediumIteration: 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(size); result.add(level); for(int i=0; i&lt;size; i++)&#123; TreeNode curr = queue.poll(); level.add(curr.val); if(curr.left != null) queue.offer(curr.left); if(curr.right != null) queue.offer(curr.right); &#125; &#125; return result;&#125; DFS recursion: 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; dfs(result,root,0); return result;&#125;private void dfs(List&lt;List&lt;Integer&gt;&gt; result, TreeNode root,int level)&#123; if(root == null) return; if(result.size() &lt; level + 1) result.add(new ArrayList&lt;&gt;()); result.get(level).add(root.val); dfs(result,root.left,level+1); dfs(result,root.right,level+1);&#125; DFS iteration: 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Map&lt;TreeNode,Integer&gt; map = new HashMap&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); map.put(root,0); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); int level = map.get(node); if(level + 1 &gt; result.size()) result.add(new ArrayList&lt;&gt;()); result.get(level).add(node.val); if(node.right != null)&#123; stack.push(node.right); map.put(node.right,level+1); &#125; if(node.left != null)&#123; stack.push(node.left); map.put(node.left,level+1); &#125; &#125; return result;&#125; Level order II 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if(root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(size); result.add(0,level); for(int i=0; i&lt;size; i++)&#123; TreeNode curr = queue.poll(); level.add(curr.val); if(curr.left != null) queue.offer(curr.left); if(curr.right != null) queue.offer(curr.right); &#125; &#125; return result;&#125; #103-zigzag-level-order-traversal-mediumGiven a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 return its zigzag level order traversal as: 12345[ [3], [20,9], [15,7]] 1234567891011121314151617181920212223242526public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int cnt = 0; while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; level = new LinkedList&lt;&gt;(); result.add(level); for(int i=0; i&lt;size; i++)&#123; TreeNode curr = queue.poll(); if(cnt % 2 == 0) level.add(curr.val); else level.add(0,curr.val); if(curr.left != null) queue.offer(curr.left); if(curr.right != null) queue.offer(curr.right); &#125; cnt ++; &#125; return result;&#125; #105-construct-tree-preorder-inorder-mediumGiven preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] Return the following binary tree: 12345 3 / \\9 20 / \\ 15 7 123456789101112131415161718192021public TreeNode buildTree(int[] preorder, int[] inorder) &#123; // use preorder traverse root, inorder find left &amp; right return helper(preorder,inorder,0,0,inorder.length-1);&#125;private TreeNode helper(int[] preorder,int[] inorder,int preTail,int inHead,int inTail)&#123; if(inHead &gt; inTail || preTail==preorder.length) return null; TreeNode node = new TreeNode(preorder[preTail]); // search node in inorder int idx = 0; for(int i=inHead; i&lt;=inTail; i++)&#123; if(inorder[i] == node.val) idx = i; &#125; // [inHead, i-1] left part, [i+1,inTail] right part int leftNode = preTail + 1; int rightNode = preTail + 1 + idx - inHead; node.left = helper(preorder,inorder,leftNode,inHead,idx-1); node.right = helper(preorder,inorder,rightNode,idx+1,inTail); return node;&#125; #106-construct-tree-inorder-postorder-mediumGiven inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12inorder = [9,3,15,20,7]postorder = [9,15,7,20,3] Return the following binary tree: 12345 3 / \\9 20 / \\ 15 7 12345678910111213141516171819202122232425public TreeNode buildTree(int[] inorder, int[] postorder) &#123; // from postorder define root, left child, // from inorder define left half, right half return helper(inorder, postorder, 0, inorder.length-1, 0, postorder.length-1);&#125;private TreeNode helper(int[] inorder, int[] postorder, int inHead, int inTail, int postHead, int postTail)&#123; // postHead,postTail not matter if(inHead &gt; inTail || postHead &gt; postTail) return null; // use postTail define root TreeNode node = new TreeNode(postorder[postTail]); // define left half and right half, search in inorder int idx = 0; for(int i=inHead; i&lt;=inTail; i++) if(inorder[i] == node.val)&#123; idx = i; break; &#125; // define left child and right child int leftNode = postHead + (idx - inHead - 1); int rightNode = leftNode + 1; node.left = helper(inorder,postorder,inHead,idx-1,postHead,leftNode); node.right = helper(inorder,postorder,idx+1,inTail,rightNode,postTail-1); return node;&#125; #109-sorted-list-to-bst-mediumGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 12345678910111213141516171819202122public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; // from here see tail init null, exclude return helper(head,null);&#125;private TreeNode helper(ListNode head,ListNode tail)&#123; // tail exclude if(head == tail) return null; ListNode slow = head, fast = head; // find mid when fast reach tail while(fast != tail &amp;&amp; fast.next != tail)&#123; slow = slow.next; fast = fast.next.next; &#125; // mid is slow TreeNode node = new TreeNode(slow.val); node.left = helper(head,slow);// mid exclude node.right = helper(slow.next,tail); return node;&#125; #110-balanced-binary-tree-easy12345678910111213public boolean isBalanced(TreeNode root) &#123; if(root == null) return true; int left = depth(root.left); int right = depth(root.right); if(Math.abs(left - right) &gt; 1) return false; return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125;private int depth(TreeNode root)&#123; return root == null ? 0 : 1 + Math.max(depth(root.left),depth(root.right));&#125; #111-min-depth-of-binary-tree-easy12345678910public int minDepth(TreeNode root) &#123; if(root == null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); if(left == 0 || right == 0) return left + right + 1; else return Math.min(left,right) + 1;&#125; #112-path-sum-easyGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. 12345678public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; // when leaf node if(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==sum) return true; return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);&#125; #113-path-sum-ii-mediumGiven a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); helper(root,sum,result,new ArrayList&lt;&gt;()); return result;&#125;private void helper(TreeNode root,int sum,List&lt;List&lt;Integer&gt;&gt; result,List&lt;Integer&gt; temp)&#123; if(root == null) return; // add here, add when null=&gt;duplicate result temp.add(root.val); // valid result added if(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==sum) result.add(new ArrayList&lt;&gt;(temp)); // left and right helper(root.left,sum-root.val,result,temp); helper(root.right,sum-root.val,result,temp); // remove curr temp.remove(temp.size()-1);&#125; #114-flatten-binary-tree-to-linked-list-mediumGiven a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 / \\ 2 5 / \\ \\3 4 6 The flattened tree should look like: 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 12345678910111213class Solution &#123; TreeNode prev = null; public void flatten(TreeNode root) &#123; if(root == null) return; // use reverse post order flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; &#125;&#125; #115-distinct-subsequences-hardGiven a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ACE&quot; is a subsequence of &quot;ABCDE&quot; while &quot;AEC&quot; is not). Example 1: 12345678910111213Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;Output: 3Explanation:As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.(The caret symbol ^ means the chosen letters)rabbbit^^^^ ^^rabbbit^^ ^^^^rabbbit^^^ ^^^ 12345678910111213141516171819202122232425public int numDistinct(String s, String t) &#123; // similar to regex 10 // use dp if(s==null || t==null) return 0; // rows t, columns s, remove char from s int[][] dp = new int[t.length()+1][s.length()+1]; // init first row: remove all to get \"\" for(int col=0; col&lt;=s.length(); col++) dp[0][col] = 1; // init first col: should all be 0: \"\" cannot get un-\"\" for(int i=0; i&lt;t.length(); i++)&#123; // for t for(int j=0; j&lt;s.length(); j++)&#123; // for s // 1. if same char: keep it || remove it // if keep dp[i][j] = dp[i-1][j-1]; // if remove dp[i][j] = dp[i][j-1]; if(s.charAt(j) == t.charAt(i))&#123; dp[i+1][j+1] = dp[i][j] + dp[i+1][j]; &#125;else&#123; // 2. if not same: remove it dp[i+1][j+1] = dp[i+1][j]; &#125; &#125; &#125; return dp[t.length()][s.length()]; &#125; #116-populating-next-right-pointer-mediumGiven a binary tree 12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. After calling your function, the tree should look like: 12345 1 -&gt; NULL / \\ 2 -&gt; 3 -&gt; NULL / \\ / \\4-&gt;5-&gt;6-&gt;7 -&gt; NULL 1234567891011121314151617public void connect(TreeLinkNode root) &#123; if(root == null) return; TreeLinkNode level = root, curr = null; while(level != null)&#123; curr = level; while(curr != null)&#123; if(curr.left != null)&#123; curr.left.next = curr.right; if(curr.next != null) curr.right.next = curr.next.left; &#125; curr = curr.next; &#125; level = level.left; &#125;&#125; #117-populating-next-right-pointer-ii-mediumGiven the following binary tree, 12345 1 / \\ 2 3 / \\ \\4 5 7 After calling your function, the tree should look like: 12345 1 -&gt; NULL / \\ 2 -&gt; 3 -&gt; NULL / \\ \\4-&gt; 5 -&gt; 7 -&gt; NULL 123456789101112131415161718192021222324252627282930public void connect(TreeLinkNode root) &#123; TreeLinkNode curr = root; // one high level TreeLinkNode head = null, prev = null; // two low level while(curr != null)&#123; // in curr level while(curr != null)&#123; if(curr.left != null)&#123; if(prev == null)&#123; // no head found head = curr.left; &#125;else&#123; prev.next = curr.left; &#125; prev = curr.left; &#125; if(curr.right != null)&#123; if(prev == null)&#123; head = curr.right; &#125;else&#123; prev.next = curr.right; &#125; prev = curr.right; &#125; curr = curr.next; &#125; // jump to next level head &amp; reset curr = head; head = null; prev = null; &#125;&#125; #118-pascals-triangle-easy123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 1234567891011public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for(int row=1; row&lt;=numRows; row++)&#123; temp.add(1); for(int i=temp.size()-2; i&gt;0; i--) temp.set(i,temp.get(i)+temp.get(i-1)); result.add(new ArrayList&lt;&gt;(temp)); &#125; return result;&#125; #120-triangle-mediumGiven a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 1234567891011121314151617public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; // add bottom up, so that space O(1) if(triangle.size() == 0) return 0; int n = triangle.size(); // n+1 for the last line int[] memo = new int[n+1]; // for location i, check i &amp; i+1 for(int i=n-1; i&gt;=0; i--)&#123; for(int j=0; j&lt;triangle.get(i).size(); j++)&#123; int curr = triangle.get(i).get(j); // memo is init as 0s memo[j] = Math.min(memo[j],memo[j+1]) + curr; &#125; &#125; return memo[0];&#125; #126-word-ladder-ii-hardGiven two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: 12345678910Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output:[ [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;], [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]] Example 2: 12345678Input:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: []Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation. BFS + DFS, check path dist to optimize 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123; public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; // use maps to save nearest path len, and child List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); Set&lt;String&gt; dict = new HashSet&lt;&gt;(wordList); Map&lt;String,Set&lt;String&gt;&gt; children = new HashMap&lt;&gt;(); Map&lt;String,Integer&gt; dist = new HashMap&lt;&gt;(); // init bfs(beginWord,endWord,dict,children,dist); dfs(beginWord,endWord,children,dist,result,new ArrayList&lt;&gt;()); return result; &#125; private void bfs(String beginWord,String endWord,Set&lt;String&gt; dict,Map&lt;String,Set&lt;String&gt;&gt; children,Map&lt;String,Integer&gt; dist)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginWord); int level = 1; dist.put(beginWord,level); boolean findEnd = false; while(!queue.isEmpty())&#123; int size = queue.size(); level ++; for(int i=0; i&lt;size; ++i)&#123; String curr = queue.poll(); Set&lt;String&gt; child = children.get(curr); // make sure a word's children init once, if(child == null)&#123; child = new HashSet&lt;&gt;(); children.put(curr,child); &#125;else // meet twice, dup visited, // optimize here or TLE continue; // check all possible nei in dict char[] currChar = curr.toCharArray(); for(int j=0; j&lt;currChar.length; ++j)&#123; char prev = currChar[j]; for(char c='a'; c&lt;='z'; ++c)&#123; if(prev == c) continue; currChar[j] = c; String nei = String.valueOf(currChar); if(dict.contains(nei))&#123; queue.offer(nei); child.add(nei); if(!dist.containsKey(nei)) dist.put(nei,level); if(endWord.equals(nei)) // break after iterate this level findEnd = true; &#125; &#125; currChar[j] = prev; // restore &#125; &#125; if(findEnd) break; &#125; &#125; // backtracking private void dfs(String curr,String endWord,Map&lt;String,Set&lt;String&gt;&gt; children,Map&lt;String,Integer&gt; dist,List&lt;List&lt;String&gt;&gt; result,List&lt;String&gt; path)&#123; path.add(curr); if(endWord.equals(curr))&#123; result.add(new ArrayList&lt;&gt;(path)); &#125;else&#123; Set&lt;String&gt; child = children.get(curr); if(child != null) for(String c : child)&#123; // check if it's the nearest path if(dist.get(curr) + 1 == dist.get(c)) dfs(c,endWord,children,dist,result,path); &#125; &#125; path.remove(path.size()-1); &#125;&#125; Two end set BFS + DFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; // use maps to save nearest path len, and child List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); Set&lt;String&gt; dict = new HashSet&lt;&gt;(wordList); Map&lt;String, List&lt;String&gt;&gt; children = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; dist = new HashMap&lt;&gt;(); if(!dict.contains(endWord)) return result; bfs(beginWord, endWord, dict, children, dist); dfs(beginWord, endWord, children, result, new ArrayList&lt;&gt;()); return result;&#125;private void bfs(String beginWord, String endWord, Set&lt;String&gt; dict, Map&lt;String, List&lt;String&gt;&gt; children, Map&lt;String, Integer&gt; dist) &#123; boolean finish = false, flip = false; Set&lt;String&gt; startSet = new HashSet&lt;&gt;(); Set&lt;String&gt; endSet = new HashSet&lt;&gt;(); startSet.add(beginWord); endSet.add(endWord); while (!startSet.isEmpty()) &#123; if (startSet.size() &gt; endSet.size()) &#123; Set&lt;String&gt; temp = startSet; startSet = endSet; endSet = temp; flip = !flip; &#125; finish = false; // remove 2 ends here dict.removeAll(startSet); dict.removeAll(endSet); Set&lt;String&gt; next = new HashSet&lt;&gt;(); for (String curr : startSet) &#123; char[] currChar = curr.toCharArray(); for (int j = 0; j &lt; currChar.length; ++j) &#123; char prev = currChar[j]; for (char c = 'a'; c &lt;= 'z'; ++c) &#123; if (prev == c) continue; currChar[j] = c; String nei = String.valueOf(currChar); String root = flip ? nei : curr; String val = flip ? curr : nei; List&lt;String&gt; child = children.get(root); if (child == null) child = new ArrayList&lt;&gt;(); if (dict.contains(nei)) &#123; child.add(val); children.put(root, child); next.add(nei); &#125; // bug if child not added here, children map incomplete if (endSet.contains(nei)) &#123; finish = true; child.add(val); children.put(root, child); &#125; &#125; currChar[j] = prev; // restore &#125; &#125; startSet = next; if (finish) break; &#125;&#125;private void dfs(String curr, String endWord, Map&lt;String, List&lt;String&gt;&gt; children, List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; path) &#123; if (path.contains(curr)) return; path.add(curr); if (endWord.equals(curr)) &#123; result.add(new ArrayList&lt;&gt;(path)); &#125; else &#123; List&lt;String&gt; child = children.get(curr); if (child != null) for (String c : child) &#123; dfs(c, endWord, children, result, path); &#125; &#125; path.remove(path.size() - 1);&#125; Optimized one queue solution, remove level from dict idea from 2 end set solution above No nearest dist map required 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; // use maps to save nearest path len, and child List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); Set&lt;String&gt; dict = new HashSet&lt;&gt;(wordList); Map&lt;String, List&lt;String&gt;&gt; children = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; dist = new HashMap&lt;&gt;(); if (!dict.contains(endWord)) return result; bfs(beginWord, endWord, dict, children); logger.info(\"&#123;&#125;\", children); dfs(beginWord, endWord, children, result, new ArrayList&lt;&gt;()); return result;&#125;private void bfs(String beginWord, String endWord, Set&lt;String&gt; dict, Map&lt;String, List&lt;String&gt;&gt; children) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginWord); boolean findEnd = false; while (!queue.isEmpty()) &#123; int size = queue.size(); // !!!! remove level from set, to replace using dist // in this case no backward neighbors dict.removeAll(queue); for (int i = 0; i &lt; size; ++i) &#123; String curr = queue.poll(); List&lt;String&gt; child = children.get(curr); if (child == null) child = new ArrayList&lt;&gt;(); else // two parent reach one child, duplicate result in child's children continue; // check all possible nei in dict char[] currChar = curr.toCharArray(); for (int j = 0; j &lt; currChar.length; ++j) &#123; char prev = currChar[j]; for (char c = 'a'; c &lt;= 'z'; ++c) &#123; if (prev == c) continue; currChar[j] = c; String nei = String.valueOf(currChar); if (dict.contains(nei)) &#123; queue.offer(nei); child.add(nei); children.put(curr, child); &#125; if (endWord.equals(nei)) // break after iterate this level findEnd = true; &#125; currChar[j] = prev; // restore &#125; &#125; if (findEnd) break; &#125;&#125;// backtrackingprivate void dfs(String curr, String endWord, Map&lt;String, List&lt;String&gt;&gt; children, List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; path) &#123; if (path.contains(curr)) return; path.add(curr); if (endWord.equals(curr)) &#123; result.add(new ArrayList&lt;&gt;(path)); &#125; else &#123; List&lt;String&gt; child = children.get(curr); if (child != null) for (String c : child) &#123; dfs(c, endWord, children, result, path); &#125; &#125; path.remove(path.size() - 1);&#125; #127-word-ladder-mediumGiven two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: 123456789Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output: 5Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5. Example 2: 12345678Input:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: 0Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation. 1234567891011121314151617181920212223242526272829303132333435public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; // bfs Set&lt;String&gt; dict = new HashSet&lt;&gt;(); for(String word : wordList) dict.add(word); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginWord); int len = 1; // return depth of level to reach endword while(!queue.isEmpty())&#123; int size = queue.size(); len ++; // remember use level, otherwise wrong for(int level=0; level&lt;size; ++level)&#123; char[] curr = queue.poll().toCharArray(); for(int i=0; i&lt;curr.length; ++i)&#123; // replace curr[i] with a to z char prev = curr[i]; for(char c='a'; c&lt;='z'; ++c)&#123; if(c != prev)&#123; curr[i] = c; String newWord = String.valueOf(curr); if(dict.contains(newWord))&#123; if(newWord.equals(endWord)) return len; queue.offer(newWord); dict.remove(newWord); &#125; &#125; &#125; curr[i] = prev; &#125; &#125; &#125; return 0;&#125; Optimized using to direction set: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; // bfs: optimized using two ends Set&lt;String&gt; dict = new HashSet&lt;&gt;(); for(String word : wordList) dict.add(word); // if set not contain endWord, return 0 if(!dict.contains(endWord)) return 0; Set&lt;String&gt; startSet = new HashSet&lt;&gt;(); Set&lt;String&gt; endSet = new HashSet&lt;&gt;(); startSet.add(beginWord); endSet.add(endWord); int len = 1; // return depth of level to reach endword while(!startSet.isEmpty() &amp;&amp; !endSet.isEmpty())&#123; // traverse smaller set to optimize if(startSet.size() &gt; endSet.size())&#123; Set&lt;String&gt; temp = startSet; startSet = endSet; endSet = temp; &#125; len ++; // update next level startSet Set&lt;String&gt; nextSet = new HashSet&lt;&gt;(); for(String word : startSet)&#123; char[] curr = word.toCharArray(); for(int i=0; i&lt;curr.length; ++i)&#123; char prev = curr[i]; for(char c='a'; c&lt;='z'; ++c)&#123; if(prev == c) continue; curr[i] = c; String newWord = String.valueOf(curr); if(endSet.contains(newWord)) return len; if(dict.contains(newWord))&#123; nextSet.add(newWord); dict.remove(newWord); &#125; &#125; curr[i] = prev; // restore &#125; &#125; startSet = nextSet; &#125; return 0;&#125; #128-longest-consecutive-sequence-hardGiven an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: 123Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 1234567891011121314151617181920public int longestConsecutive(int[] nums) &#123; // union find using set // find the head (head - 1 not exist) if(nums == null || nums.length == 0) return 0; int result = 0; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num : nums) set.add(num); for(int num : nums)&#123; // find a head if(!set.contains(num - 1))&#123; int len = 1; while(set.contains(++num)) len ++; result = Math.max(result,len); &#125; &#125; return result;&#125; #130-surrounded-regionsGiven a 2D board containing &#39;X&#39; and &#39;O&#39; (the letter O), capture all regions surrounded by &#39;X&#39;. A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region. For example, 1234X X X XX O O XX X O XX O X X After running your function, the board should be: 1234X X X XX X X XX X X XX O X X Notice overflow case: 12345678910OOOOOOOOOOXXXXXXXXXOOOOOOOOOOOOXXXXXXXXXOOOOOOOOOOXXXXXXXXXOOOOOOOOOOOOXXXXXXXXXOOOOOOOOOOXXXXXXXXXO 12345678910OOOOOOOOOOOXXXXXXXXXXXOXXOOOOOOOOOOXXOXXXXXXXXXXXOOOOOOOOOOXXXXXXXXXXXOXXOOOOOOOOOOXXOXXXXXXXXXXXOOOOOOOOOOXXXXXXXXXXXOX 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void solve(char[][] board) &#123; // if surrounded, must at edge // check edge set 0 to 1 if(board==null||board.length==0||board[0].length==0) return; int m = board.length, n = board[0].length; // set first last row for(int j=0; j&lt;n; j++)&#123; check(board,m,n,0,j); if(m &gt; 1) check(board,m,n,m-1,j); &#125; // set left right col for(int i=1; i&lt;m; i++)&#123; check(board,m,n,i,0); if(n &gt; 1) check(board,m,n,i,n-1); &#125; // set 1 to 0, 0 to X for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(board[i][j] == '1') board[i][j] = 'O'; else if(board[i][j] == 'O') board[i][j] = 'X'; &#125; &#125;&#125;private void check(char[][] board,int m,int n,int i,int j)&#123; // use trick avoid TLE, skip first row and left col // skip only one not both for best performance if(board[i][j] == 'O')&#123; board[i][j] = '1'; // use i&gt;1 instead of i&gt;=1 if(i &gt; 1) check(board,m,n,i-1,j); if(i &lt; m-1) check(board,m,n,i+1,j); // use j&gt;1 instead of j&gt;=1 if(j &gt; 1) check(board,m,n,i,j-1); if(j &lt; n-1) check(board,m,n,i,j+1); &#125;&#125; #133-clone-graph-mediumClone an undirected graph. Each node in the graph contains a label and a list of its neighbors. 123456789101112131415161718192021222324/** * Definition for undirected graph. * class UndirectedGraphNode &#123; * int label; * List&lt;UndirectedGraphNode&gt; neighbors; * UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125; * &#125;; */ public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; Map&lt;Integer,UndirectedGraphNode&gt; visited = new HashMap&lt;&gt;(); return clone(node,visited); &#125; private UndirectedGraphNode clone(UndirectedGraphNode node, Map&lt;Integer,UndirectedGraphNode&gt; visited)&#123; if(node == null) return null; if(visited.containsKey(node.label)) return visited.get(node.label); UndirectedGraphNode newNode = new UndirectedGraphNode(node.label); visited.put(node.label,newNode); for(UndirectedGraphNode n : node.neighbors)&#123; newNode.neighbors.add(clone(n,visited)); &#125; return newNode; &#125; #136-single-number-easyGiven a non-empty array of integers, every element appears twice except for one. Find that single one. 123456public int singleNumber(int[] nums) &#123; int result = 0; for(int num : nums) result ^= num; return result;&#125; #141-linked-list-cycle-easyGiven a linked list, determine if it has a cycle in it. 123456789101112public boolean hasCycle(ListNode head) &#123; if(head == null) return false; ListNode slow = head, fast = head; do&#123; if(fast==null || fast.next==null) return false; slow = slow.next; fast = fast.next.next; &#125;while(slow != fast); return true;&#125; 123456789101112public boolean hasCycle(ListNode head) &#123; if(head==null) return false; ListNode slow = head, fast = head; while(fast !=null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if(slow == fast) return true;; &#125; return false;&#125; #142-linked-list-cycle-ii-mediumGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. 12345678910111213141516public ListNode detectCycle(ListNode head) &#123; if(head==null || head.next==null) return null; ListNode slow = head, fast = head; do&#123; if(fast==null || fast.next==null) return null; slow = slow.next; fast = fast.next.next; &#125;while(slow != fast); while(head != fast)&#123; head = head.next; fast = fast.next; &#125; return head;&#125; #146-lru-cache-hardDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class LRUCache &#123; // implement double linked list // most recent at head // least recent at tail DListNode head = null; DListNode tail = null; int capacity = 0; Map&lt;Integer,DListNode&gt; map; // save key, node public LRUCache(int capacity) &#123; this.capacity = capacity; map = new HashMap&lt;&gt;(); // init head tail head = new DListNode(); tail = new DListNode(); head.next = tail; tail.prev = head; &#125; public int get(int key) &#123; if(!map.containsKey(key)) return -1; DListNode node = map.get(key); moveToHead(node); // most recent return node.val; &#125; public void put(int key, int value) &#123; // notice when same key, diff val if(map.containsKey(key))&#123; DListNode node = map.get(key); node.setVal(value); moveToHead(node); // active return; &#125; DListNode node = new DListNode(key,value); if(capacity == 0)&#123; int removeKey = removeLast(); // remove least from list and map map.remove(removeKey); capacity ++; &#125; addFirst(node); map.put(key,node); capacity --; &#125; // add most recent to head private void addFirst(DListNode node)&#123; node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; &#125; // remove a node private void remove(DListNode node)&#123; node.prev.next = node.next; node.next.prev = node.prev; node.prev = null; node.next = null; &#125; // remove least recent node, return key private int removeLast()&#123; DListNode last = tail.prev; remove(tail.prev); return last.key; &#125; // set to head private void moveToHead(DListNode node)&#123; remove(node); addFirst(node); &#125; private class DListNode&#123; int key; int val; DListNode prev; DListNode next; public DListNode()&#123;&#125; public DListNode(int key,int val)&#123; this.key = key; this.val = val; &#125; // use when put with same key public void setVal(int val)&#123; this.val = val; &#125; &#125;&#125; #149-max-points-on-a-line-hardGiven n points on a 2D plane, find the maximum number of points that lie on the same straight line. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a point. * class Point &#123; * int x; * int y; * Point() &#123; x = 0; y = 0; &#125; * Point(int a, int b) &#123; x = a; y = b; &#125; * &#125; */class Solution &#123; public int maxPoints(Point[] points) &#123; // use O(n^2) to find all pair, store slope as key if(points == null) return 0; int result = 0; // map: slope as key, count as val Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); // loop over all points for(int i=0; i&lt;points.length; ++i)&#123; // check all lines with i and j // find max point on a line except i and overlap int max = 0, overlap = 0; map.clear(); for(int j=i+1; j&lt;points.length; ++j)&#123; // x,y pair as slope int x = points[j].x - points[i].x; int y = points[j].y - points[i].y; if(x == 0 &amp;&amp; y == 0)&#123; // points overlap overlap ++; continue; &#125; int gcd = getGCD(x,y); // vertical and horizontal covered x /= gcd; y /= gcd; String key = x + \",\" + y; if(map.containsKey(key)) map.put(key,map.get(key)+1); else map.put(key,1); // max for one start point max = Math.max(max,map.get(key)); &#125; // start point + other point on line + same as start result = Math.max(result,max+overlap+1); &#125; return result; &#125; private int getGCD(int a,int b)&#123; return a == 0 ? b : getGCD(b%a,a); &#125;&#125; #151-reverse-words-in-a-string-medium1234567891011121314151617181920212223242526272829303132333435363738394041public String reverseWords(String s) &#123; if(s == null || s.length() == 0) return \"\"; char[] input = s.toCharArray(); int l = 0, r = 0; while(r &lt; input.length)&#123; // find head l = r; while(l&lt;input.length &amp;&amp; input[l]==' ') l++; // find tail r = l; while(r&lt;input.length &amp;&amp; input[r]!=' ') r++; // reverse reverse(input,l,r-1); &#125; // reverse whole reverse(input,0,input.length-1); return reduce(input); &#125;private String reduce(char[] c)&#123; int head = 0; for(int tail=0; tail&lt;c.length; tail++)&#123; if(c[tail]==' ' &amp;&amp; (head==0 || c[tail-1]==' ')) continue; c[head++] = c[tail]; &#125; // case last \" \" if(head &gt; 0 &amp;&amp; c[head-1] == ' ') return new String(c,0,head-1); return new String(c,0,head);&#125;private void reverse(char[] c,int i,int j)&#123; while(i &lt; j)&#123; char temp = c[i]; c[i] = c[j]; c[j] = temp; i++; j--; &#125;&#125; #156-binary-tree-upside-down-mediumGiven a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root. For example:Given a binary tree {1,2,3,4,5}, 12345 1 / \\ 2 3 / \\4 5 return the root of the binary tree [4,5,2,#,#,3,1]. 1234567891011 4 / \\ 5 2 / \\ 3 1 1 / 2 -- 3 / 4 -- 5 1234567891011121314151617181920public TreeNode upsideDownBinaryTree(TreeNode root) &#123; // 1 // / \\ // 2 - 3 // / \\ // 4 - 5 TreeNode curr = root; TreeNode next = null, prev = null, right = null; while(curr != null)&#123; next = curr.left; // save left curr.left = right; right = curr.right; curr.right = prev; prev = curr; curr = next; &#125; return prev;&#125; #159-longest-substring-with-at-most-2-distince-characters-hardGiven a string s , find the length of the longest substring t that contains at most 2 distinct characters. Example 1: 123Input: &quot;eceba&quot;Output: 3Explanation: t is &quot;ece&quot; which its length is 3. Example 2: 123Input: &quot;ccaabbb&quot;Output: 5Explanation: t is &quot;aabbb&quot; which its length is 5. 123456789101112131415161718192021public int lengthOfLongestSubstringTwoDistinct(String s) &#123; // sliding window if(s == null || s.length() == 0) return 0; int[] bin = new int[256]; int head = 0, maxLen = 0, count = 0; for(int tail=0; tail&lt;s.length(); tail++)&#123; if(bin[s.charAt(tail)] == 0) // new char count ++; bin[s.charAt(tail)] ++; while(count &gt; 2)&#123; // make it most 2 if(bin[s.charAt(head)] == 1) // remove a distinct char count --; bin[s.charAt(head)] --; head++; &#125; maxLen = Math.max(maxLen,tail-head+1); &#125; return maxLen;&#125; #160-intersection-of-two-linked-list-easyWrite a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 O(n) &amp; O(1) 1234567891011public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; ListNode pointer1 = headA; ListNode pointer2 = headB; // 2 iterations to overcome the difference while(pointer1 != pointer2)&#123; pointer1 = pointer1==null? headB:pointer1.next; pointer2 = pointer2==null? headA:pointer2.next; &#125; return pointer1;&#125; #163-missing-ranges-mediumGiven a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges. For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return [&quot;2&quot;, &quot;4-&gt;49&quot;, &quot;51-&gt;74&quot;, &quot;76-&gt;99&quot;]. Corner cases: Integer.min, Integer.max #228-summary-ranges-medium 1234567891011121314151617181920212223242526272829public List&lt;String&gt; findMissingRanges(int[] nums, int lower, int upper) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(nums==null) return result; int head = lower; for(int i=0; i&lt;nums.length; i++)&#123; // deal with corner case // [-2147483648,-2147483648,0,2147483647,2147483647] // -2147483648 // 2147483647 if(nums[i] == Integer.MIN_VALUE)&#123; // tail cannot be nums[i] - 1 head = nums[i] + 1; continue; &#125; int tail = nums[i] - 1; if(tail &gt;= head) result.add(head + (tail&gt;head? \"-&gt;\"+tail : \"\")); // deal with corner case, return here if(nums[i] == Integer.MAX_VALUE) return result; head = nums[i] + 1; &#125; // deal with last num if(head &lt;= upper) result.add(head + (upper&gt;head? \"-&gt;\"+upper : \"\")); return result;&#125; #165-compare-version-numbers-mediumCompare two version numbers version1 and version2.If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character.The . character does not represent a decimal point and is used to separate number sequences.For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. Here is an example of version numbers ordering: 120.1 &lt; 1.1 &lt; 1.2 &lt; 13.37 01 = 1, 1.0 = 1 12345678910111213141516public int compareVersion(String version1, String version2) &#123; // . match a char String[] v1 = version1.split(\"\\\\.\"); String[] v2 = version2.split(\"\\\\.\"); for(int i=0,j=0;i&lt;v1.length||j&lt;v2.length;)&#123; int num1 = i &gt;= v1.length ? 0 : Integer.parseInt(v1[i++]); int num2 = j &gt;= v2.length ? 0 : Integer.parseInt(v2[j++]); if(num1 == num2) continue; else if(num1 &lt; num2) return -1; else return 1; &#125; return 0;&#125; #169-majority-element-easyGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Can use sorting as well #229-majority-element-ii-medium 12345678910public int majorityElement(int[] nums) &#123; // Boyer-Moore Voting Algorithm int result = 0, count = 0; for(int num : nums)&#123; if(count == 0) result = num; count += num == result ? 1 : -1; &#125; return result;&#125; 200. Number of Islands (medium)Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. *Example 1:* Answer: 1 123411110110101100000000 *Example 2:* Answer: 3 123411000110000010000011 dfs approach time O(mn), space O(mn) worst 1234567891011121314151617181920212223242526272829public int numIslands(char[][] grid) &#123; if(grid==null || grid.length==0 || grid[0].length==0) return 0; // dfs approach, connected component idea int m = grid.length, n = grid[0].length; int count = 0; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; // if 1, count ++, traverse neighbor if(grid[i][j] == '1')&#123; count ++; dfs(grid,i,j); &#125; &#125; &#125; return count;&#125;private void dfs(char[][] grid,int i,int j)&#123; int m = grid.length, n = grid[0].length; // if out of bound, or not island if(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || grid[i][j]=='0') return; grid[i][j] = '0'; // set visited // visit up down left right dfs(grid,i-1,j); dfs(grid,i+1,j); dfs(grid,i,j-1); dfs(grid,i,j+1);&#125; BFS approach, time O(mn), space O(min(m,n)) 12345678910111213141516171819202122232425262728293031323334353637383940public int numIslands(char[][] grid) &#123; // bfs approach if(grid==null || grid.length==0 || grid[0].length==0) return 0; int count = 0; int m = grid.length, n = grid[0].length; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; // only care about 1 if(grid[i][j] == '1')&#123; count ++; grid[i][j] = '0'; int[] curr = &#123;i,j&#125;; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(curr); while(!queue.isEmpty())&#123; curr = queue.poll(); int row = curr[0], col = curr[1]; if(row-1&gt;=0 &amp;&amp; grid[row-1][col] == '1')&#123; queue.offer(new int[]&#123;row-1,col&#125;); grid[row-1][col] = '0'; &#125; if(row+1&lt;m &amp;&amp; grid[row+1][col] == '1')&#123; queue.offer(new int[]&#123;row+1,col&#125;); grid[row+1][col] = '0'; &#125; if(col-1&gt;=0 &amp;&amp; grid[row][col-1] == '1')&#123; queue.offer(new int[]&#123;row,col-1&#125;); grid[row][col-1] = '0'; &#125; if(col+1&lt;n &amp;&amp; grid[row][col+1] == '1')&#123; queue.offer(new int[]&#123;row,col+1&#125;); grid[row][col+1] = '0'; &#125; &#125; &#125; &#125; &#125; return count;&#125; ####","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jliao011.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode Solutions","slug":"leet-code","date":"2018-05-27T07:31:15.000Z","updated":"2018-07-13T05:18:10.000Z","comments":true,"path":"2018/05/27/leet-code/","link":"","permalink":"https://jliao011.github.io/2018/05/27/leet-code/","excerpt":"","text":"1 ~ 200 1 ~ 100 101 ~ 200 #101-symmetric-tree-easy #102-level-order-traversal-medium #3-longest-substring-without-repeating-characters-medium #103-zigzag-level-order-traversal-medium #105-construct-tree-preorder-inorder-medium #106-construct-tree-inorder-postorder-medium #109-sorted-list-to-bst-medium #10-regular-expression-match-hard #110-balanced-binary-tree-easy #111-min-depth-of-binary-tree-easy #112-path-sum-easy #113-path-sum-ii-medium #114-flatten-binary-tree-to-linked-list-medium #115-distinct-subsequences-hard #116-populating-next-right-pointer-medium #117-populating-next-right-pointer-ii-medium #118-pascals-triangle-easy #29-divide-two-integers-medium #120-triangle-medium #22-generate-parentheses-medium #25-reverse-nodes-in-k-group-hard #128-longest-consecutive-sequence-hard #130-surrounded-regions #31-next-permutation-medium #32-longest-valid-parentheses-hard #33-search-in-rotated-sorted-array-medium #133-clone-graph-medium #136-single-number-easy #38-count-and-say-easy #41-first-missing-positive-hard #141-linked-list-cycle-easy #42-trapping-rain-water-hard #142-linked-list-cycle-ii-medium #146-lru-cache-hard #149-max-points-on-a-line-hard #151-reverse-words-in-a-string-medium #156-binary-tree-upside-down-medium #159-longest-substring-with-at-most-2-distince-characters-hard #160-intersection-of-two-linked-list-easy #61-rotate-list-medium #62-unique-paths-medium #63-unique-paths-ii-medium #163-missing-ranges-medium #64-minimum-path-sum-medium #165-compare-version-numbers-medium #66-plus-one-easy #67-add-binary-easy #169-majority-element-easy #70-climbing-stairs-easy #71-simplify-path-medium #72-edit-distance-hard #73-set-matrix-zeros-medium #74-search-a-2d-matrix-medium #75-sort-colors-medium #76-minimun-window-substring-hard #77-combinations-medium #78-subsets-medium #79-word-search-medium #80-remove-duplicates-from-sorted-array-ii-medium #81-search-in-rotated-sorted-array-ii-medium #82-remove-duplicates-from-sorted-list-ii-medium #83-remove-duplicates-from-sorted-list-easy #84-largest-rectangle-in-histogram-hard #86-partition-list-medium #87-scramble-string-hard #88-merge-sorted-array-easy #89-gray-code-medium #90-subsets-ii-medium #92-reverse-linked-list-ii-medium #93-restore-ip-addresses-medium #94-binary-tree-inorder-traversal-medium #95-unique-bst-ii-medium #96-unique-bst-medium #97-interleaving-string-hard #98-validate-binary-search-tree-medium #100-same-tree-easy 201 ~ 400 201 ~ 300 301 ~ 400 #201-bitwise-and-of-numbers-range-medium #204-count-primes-easy #207-course-schedule-medium #210-course-schedule-ii-medium #211-add-and-search-word-medium #313-supper-ugly-number-medium #217-contains-duplicate-easy #219-contains-duplicate-ii-easy #220-contains-duplicate-iii-medium #223-rectangle-area-medium #325-max-size-subarray-sum-equals-k-medium #228-summary-ranges-medium #229-majority-element-ii-medium #235-lca-of-a-bst-easy #335-self-crossing-hard #236-lca-of-a-binary-tree-medium #241-different-ways-to-add-parentheses-medium #243-shortest-word-distance-easy #244-shortest-word-distance-ii-medium #245-shortest-word-distance-iii-medium #347-top-k-frequent-elements-medium #248-strobogrammatic-number-iii-hard #350-intersection-of-two-arrays-easy #253-meeting-rooms-ii-medium #263-ugly-number-easy #268-missing-number-easy #271-encode-and-decode-strings-medium #371-sum-of-two-integers-easy #272-closest-bst-value-ii-hard #373-find-k-pairs-with-smallest-sum-medium #378-k-th-smallest-element-in-a-sorted-matrix-medium #279-perfect-squares-medium #384-shuffle-an-array-medium #285-inorder-successor-in-bst-medium #287-find-duplicate-number-medium #388-longest-absolute-file-path-medium #295-find-median-from-data-stream-hard #297-encode-and-decode-binary-tree-hard #300-longest-increasing-subsequence-medium 401 ~ 600 401 ~ 500 501 ~ 600 #503-next-greater-element-ii-medium #406-queue-reconstruction-by-height-medium #516-longest-palindromic-subsequence-medium #419-battleships-in-a-board-medium #443-string-compression-easy #448-find-all-disappeared-number-easy #556-next-greater-element-iii-medium #560-subarray-sum-equals-k-medium #463-island-perimeter-easy #476-number-complement-easy #496-next-greater-element-i-easy #500-keyboard-row-easy 601 ~ 800 601 ~ 700 701 ~ 800 #604-compressed-string-iterator-easy #625-minimun-factorization-medium #632-smallest-range-hard 801 ~ 1000 801 ~ 900 901 ~ 1000 #809-expressive-word-medium #814-binary-tree-pruning-medium #817-linked-list-components-medium #855-exam-room-medium #856-score-of-parentheses-medium #862-shortest-subarray-with-sum-at-least-k-hard #863-all-nodes-distance-k-in-binary-tree-medium #864-random-pick-with-blacklist-hard #3-longest-substring-without-repeating-characters-mediumGiven a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 12345678910111213public static int lengthOfLongestSubstringDistinct(String s) &#123; int maxLen = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // save character, index for (int head = 0, tail = 0; tail &lt; s.length(); tail++) &#123; // if duplicated, move head if (map.containsKey(s.charAt(tail))) // head cannot move back e.g. abbbbbba head = Math.max(head, map.get(s.charAt(tail)) + 1); map.put(s.charAt(tail), tail); maxLen = Math.max(maxLen, tail - head + 1); &#125; return maxLen;&#125; 12345678910public static int lengthOfLongestSubstringDistinctOPT(String s) &#123; int maxLen = 0; int[] bin = new int[26]; // case only alphabet, save index for (int head = 0, tail = 0; tail &lt; s.length(); tail++) &#123; head = Math.max(head, bin[s.charAt(tail) - 'a']); // maybe 0 bin[s.charAt(tail) - 'a'] = tail + 1; // save same's next maxLen = Math.max(maxLen, tail - head + 1); &#125; return maxLen;&#125; #10-regular-expression-match-hardGiven an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;. 12&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. 123456789101112131415161718192021222324252627282930313233 public boolean isMatch(String s, String p) &#123;if (s == null || p == null) return false;boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];dp[0][0] = true;// initial the first linefor (int j = 1; j &lt;= p.length(); j++) &#123; if (p.charAt(j - 1) == '*') dp[0][j] = dp[0][j - 2];&#125;// dp conditions:// (1) p.char == . || p.char == s.char// (2) p.char == *:// 1. treat as 0 : check i, j-2// 2. if p[j-1] == s.char || .: check i-1,jfor (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 1; j &lt;= p.length(); j++) &#123; if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) dp[i][j] = dp[i - 1][j - 1]; else if (p.charAt(j - 1) == '*') &#123; // check * is 0 dp[i][j] = dp[i][j - 2]; if (dp[i][j]) continue; // if p.prev equal or . if (p.charAt(j - 2) == s.charAt(i - 1) || p.charAt(j - 2) == '.') &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125;&#125;return dp[s.length()][p.length()]; &#125; #22-generate-parentheses-mediumGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 12345678910111213141516171819202122232425public List&lt;String&gt; generateParenthesis(int n) &#123; // utilizing backtracking List&lt;String&gt; result = new ArrayList&lt;&gt;(); backtrack(result,new StringBuilder(),0,0,n); return result;&#125;private void backtrack(List&lt;String&gt; result,StringBuilder temp,int left,int right,int n)&#123; if(temp.length() == n * 2)&#123; result.add(temp.toString()); return; &#125; int len = temp.length(); // append ( if(left &lt; n)&#123; temp.append('('); backtrack(result,temp,left+1,right,n); temp.setLength(len); &#125; // append ) if(right &lt; left)&#123; temp.append(')'); backtrack(result,temp,left,right+1,n); temp.setLength(len); &#125;&#125; #25-reverse-nodes-in-k-group-hardGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 12345678910111213141516171819202122232425262728293031public ListNode reverseKGroup(ListNode head, int k) &#123; // constant memory, cannot use recursion (dummy) if(head==null || k==1) return head; ListNode dummy = new ListNode(0), prev = dummy, tail = dummy, next = null, curr = null; prev.next = head; while(true)&#123; // find group first, k th node int count = 0; while(count&lt;k &amp;&amp; tail!=null)&#123; count ++; tail = tail.next; &#125; // less than k break if(tail == null) break; // reverse prev to curr // D -&gt; 1 -&gt; 2 -&gt; 3(T) -&gt; N // move 1 after 3: D 2 3 1 N head = prev.next; for(int i=0;i&lt;k-1;i++)&#123; next = prev.next; // save 1 prev.next = next.next; // assign head next.next = tail.next; // assign tail tail.next = next; &#125; prev = head; tail = head; &#125; return dummy.next;&#125; #29-divide-two-integers-mediumGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. 12345678910111213141516171819202122232425262728public int divide(int dividend, int divisor) &#123; if(divisor == 0) return Integer.MAX_VALUE; if(dividend == 0) return 0; if(divisor == 1) return dividend; if(divisor == -1) return dividend == Integer.MIN_VALUE? Integer.MAX_VALUE : -dividend; int sign = 1; if(dividend &lt; 0 ^ divisor &lt;0) sign = -1; long ldividend = Math.abs((long)dividend); // notice long inside long ldivisor = Math.abs((long)divisor); int result = 0; while(ldividend &gt;= ldivisor)&#123; long temp = ldivisor, multi = 1; while(temp &lt;&lt; 1 &lt; ldividend)&#123; temp &lt;&lt;= 1; multi &lt;&lt;= 1; &#125; ldividend -= temp; result += multi; &#125; return sign==1? result : -result;&#125; #31-next-permutation-mediumImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 12345678910111213141516171819202122232425public void nextPermutation(int[] nums) &#123; int head = nums.length - 2; while(head &gt;= 0 &amp;&amp; nums[head] &gt;= nums[head+1]) head --; if(head &gt;= 0)&#123; int tail = nums.length - 1; while(nums[tail] &lt;= nums[head]) tail --; swap(nums,head,tail); &#125; // if head == -1, just reverse reverse(nums,head+1,nums.length-1);&#125;private void reverse(int[] nums,int i,int j)&#123; while(i &lt; j)&#123; swap(nums,i,j); i++; j--; &#125;&#125;private void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; #32-longest-valid-parentheses-hardGiven a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. For &quot;(()&quot;, the longest valid parentheses substring is &quot;()&quot;, which has length = 2. Another example is &quot;)()())&quot;, where the longest valid parentheses substring is &quot;()()&quot;, which has length = 4. 1234567891011121314151617181920public int longestValidParentheses(String s) &#123; if(s==null || s.length()==0) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(-1); // for first pair if () int maxLen = 0; for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i) == '(') stack.push(i); else&#123; stack.pop(); if(stack.isEmpty())&#123; stack.push(i); // first not valid &#125;else&#123; maxLen = Math.max(maxLen,i-stack.peek()); &#125; &#125; &#125; return maxLen;&#125; #33-search-in-rotated-sorted-array-mediumSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1: 12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2: 12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 1234567891011121314151617181920212223242526public int search(int[] nums, int target) &#123; if(nums==null || nums.length==0) return -1; int left = 0, right = nums.length - 1; while(left &lt;= right)&#123; int mid = left + (right-left)/2; if(nums[mid] == target) return mid; // left half not rotate if(nums[left] &lt;= nums[mid])&#123; // mid in not rotate part if(nums[left]&lt;=target &amp;&amp; target&lt;nums[mid]) right = mid - 1; // mid in rotate part else left = mid + 1; // right half not rotate &#125;else&#123; // mid in not rotate part if(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right]) left = mid + 1; // mid in rotate part else right = mid -1; &#125; &#125; return -1;&#125; 36. Valid Sudoku (medium)Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character &#39;.&#39;. A partially filled sudoku which is valid. Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. 123456789101112131415161718192021222324252627public boolean isValidSudoku(char[][] board) &#123; if(board==null || board.length!=9 || board[0].length!=9) return false; Set&lt;Character&gt; rowSet = new HashSet&lt;&gt;(); Set&lt;Character&gt; colSet = new HashSet&lt;&gt;(); Set&lt;Character&gt; cubSet = new HashSet&lt;&gt;(); // check row, col, cube for(int row=0;row&lt;9;row++)&#123; rowSet.clear(); colSet.clear(); cubSet.clear(); for(int col=0;col&lt;9;col++)&#123; // left to right if(board[row][col]!='.' &amp;&amp; !rowSet.add(board[row][col])) return false; // up to down if(board[col][row]!='.' &amp;&amp; !colSet.add(board[col][row])) return false; // map to a cube int cubeRow = 3 * (row / 3) + col / 3; int cubeCol = 3 * (row % 3) + col % 3; if(board[cubeRow][cubeCol]!='.' &amp;&amp; !cubSet.add(board[cubeRow][cubeCol])) return false; &#125; &#125; return true;&#125; 37. Sudoku Solver (hard)Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character &#39;.&#39;. You may assume that there will be only one unique solution. A sudoku puzzle… …and its solution numbers marked in red. 123456789101112131415161718192021222324252627282930313233public void solveSudoku(char[][] board) &#123; if(board==null || board.length!=9 || board[0].length!=9) return; solver(board);&#125;private boolean solver(char[][] board)&#123; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; if(board[i][j] != '.') continue; for(char c='1';c&lt;='9';c++)&#123; if(isValid(board,i,j,c))&#123; board[i][j] = c; if(solver(board)) return true; board[i][j] = '.'; &#125; &#125; return false; &#125; &#125; return true;&#125;private boolean isValid(char[][] board,int i,int j,char c)&#123; for(int k=0;k&lt;9;k++)&#123; if(board[i][k] == c) return false; if(board[k][j] == c) return false; int row = 3 * (i / 3) + k / 3; int col = 3 * (j / 3) + k % 3; if(board[row][col] == c) return false; &#125; return true;&#125; #38-count-and-say-easyThe count-and-say sequence is the sequence of integers with the first five terms as following: 123451. 12. 113. 214. 12115. 111221 1 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211. Given an integer n, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string. Example 1: 12Input: 1Output: &quot;1&quot; Example 2: 12Input: 4Output: &quot;1211&quot; 123456789101112131415161718192021public String countAndSay(int n) &#123; if(n == 1) return \"1\"; String result = \"1\"; for(int i=2;i&lt;=n;i++)&#123; int idx = 0; StringBuilder sb = new StringBuilder(); while(idx &lt; result.length())&#123; char curr = result.charAt(idx); int count = 1; while(idx&lt;result.length()-1 &amp;&amp; result.charAt(idx)==result.charAt(idx+1))&#123; idx ++; count ++; &#125; sb.append(count).append(curr); idx ++; &#125; result = sb.toString(); &#125; return result;&#125; 39. Combination Sum (medium)Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: 1234[ [7], [2, 2, 3]] 12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; // use backtracking List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,candidates,new ArrayList&lt;&gt;(),target,0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] candidates,List&lt;Integer&gt; temp,int target,int idx)&#123; if(target &lt; 0) return; if(target == 0)&#123; // should build a new list result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=idx;i&lt;candidates.length;i++)&#123; temp.add(candidates[i]); // item repeatly used, should call i backtrack(result,candidates,temp,target-candidates[i],i); // remove after recursion temp.remove(temp.size()-1); &#125;&#125; 40. Combination Sum II (medium)Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is: 123456[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; // backtracking, duplicate element, use once List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(candidates); // to skip duplicate backtrack(result,candidates,new ArrayList&lt;&gt;(),target,0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] candidates,List&lt;Integer&gt; temp,int target,int idx)&#123; if(target &lt; 0) return; if(target == 0)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=idx;i&lt;candidates.length;i++)&#123; // here i &gt; idx not 0. to avoid duplicate // since same adjacent same element, so need sorting if(i&gt;idx &amp;&amp; candidates[i]==candidates[i-1]) continue; temp.add(candidates[i]); backtrack(result,candidates,temp,target-candidates[i],i+1); temp.remove(temp.size()-1); &#125;&#125; #41-first-missing-positive-hardGiven an unsorted integer array, find the first missing positive integer. For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 1234567891011121314151617public int firstMissingPositive(int[] nums) &#123; // swap pos num to corresponding index for(int i=0;i&lt;nums.length;i++)&#123; // use nums[i]-1 as index, cannot have cycle while(nums[i]&gt;0 &amp;&amp; nums[i]&lt;=nums.length &amp;&amp; nums[i]!=nums[nums[i]-1])&#123; int temp = nums[nums[i]-1]; nums[nums[i]-1] = nums[i]; nums[i] = temp; &#125; &#125; // traverse find nums[i]-1 != i for(int i=0;i&lt;nums.length;i++) if(nums[i] != i + 1) return i + 1; // beyond the bound return nums.length + 1;&#125; #42-trapping-rain-water-hardGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example,Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. DP approach O(n) &amp; O(n) 123456789101112131415161718192021222324public int trap(int[] height) &#123; // use dp 3 pass if(height.length == 0) return 0; // first pass find left max int[] left = new int[height.length]; int leftMax = height[0]; for(int i=0;i&lt;height.length;i++)&#123; leftMax = Math.max(leftMax,height[i]); left[i] = leftMax; &#125; // second pass find right max int[] right = new int[height.length]; int rightMax = height[height.length-1]; for(int i=height.length-1;i&gt;=0;i--)&#123; rightMax = Math.max(rightMax,height[i]); right[i] = rightMax; &#125; // third pass find water each idx int result = 0; for(int i=0;i&lt;height.length;i++) result += Math.min(left[i],right[i]) - height[i]; return result;&#125; Stack approach O(n) &amp; O(n) 12345678910111213141516171819202122public int trap(int[] height) &#123; // stack approaching if(height.length == 0) return 0; // use stack to save index Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int result = 0; for(int i=0;i&lt;height.length;i++)&#123; // if larger than prev while(!stack.isEmpty() &amp;&amp; height[i]&gt;height[stack.peek()])&#123; int currIdx = stack.pop(); if(stack.isEmpty()) break; // compare prev height and i height int h = Math.min(height[stack.peek()],height[i]) - height[currIdx]; int w = i - stack.peek() - 1; result += h * w; &#125; stack.push(i); &#125; return result;&#125; Two pointer approach O(n) &amp; O(1) 12345678910111213141516171819202122232425public int trap(int[] height) &#123; // two pointer if(height.length == 0) return 0; // left &amp; right max, int left = 0, right = height.length - 1; int leftMax = height[left], rightMax = height[right]; int result = 0; // stop when left&gt;right, should be &lt;= while(left &lt;= right)&#123; // case left ++ if(leftMax &lt; rightMax)&#123; if(height[left] &lt; leftMax) result += leftMax - height[left]; leftMax = Math.max(leftMax,height[left]); left ++; &#125;else&#123; // case right -- if(height[right] &lt; rightMax) result += rightMax - height[right]; rightMax = Math.max(rightMax,height[right]); right --; &#125; &#125; return result;&#125; 43. Multiply Strings (medium)Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2. Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. 1234567891011121314151617181920212223242526272829public String multiply(String num1, String num2) &#123; if(num1==null || num1.length()==0) return \"\"; if(num2==null || num2.length()==0) return \"\"; if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\"; int m = num1.length(), n = num2.length(); // num1 * num2 max len = m + n int[] result = new int[m+n]; // i bit * j bit head is at i+j for(int i=m-1;i&gt;=0;i--)&#123; for(int j=n-1;j&gt;=0;j--)&#123; int n1 = num1.charAt(i) - '0'; int n2 = num2.charAt(j) - '0'; int sum = n1 * n2 + result[i+j+1]; // one digit result[i+j+1] = sum % 10; // ten digit result[i+j] += sum / 10; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;result.length;i++)&#123; if(!(sb.length()==0 &amp;&amp; result[i]==0)) sb.append(result[i]); &#125; return sb.toString();&#125; 44. Wildcard Matching (hard)Implement wildcard pattern matching with support for &#39;?&#39; and &#39;*&#39;. 12345678910111213141516&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;*&quot;) → trueisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;ab&quot;, &quot;?*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false Similar method to regular expression match, DP approach 123456789101112131415161718192021222324public boolean isMatch(String s, String p) &#123; if(s==null || p==null) return false; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; // go through first row, * could match \"\" // first col is false, dont match \"\" for(int j=1;j&lt;=p.length();j++) if(p.charAt(j-1) == '*') dp[0][j] = dp[0][j-1]; // case 1: p.char==(s.char, ?) =&gt; dp[i][j] = dp[i-1][j-1] // case 2: p.char==* =&gt; * is \"\" dp[i][j] = dp[i][j-1] // =&gt; * is not \"\" dp[i][j] = dp[i-1][j]; for(int i=1;i&lt;=s.length();i++)&#123; for(int j=1;j&lt;=p.length();j++)&#123; if(p.charAt(j-1)==s.charAt(i-1) || p.charAt(j-1)=='?') dp[i][j] = dp[i-1][j-1]; else if(p.charAt(j-1) == '*') // * is sequence and * is blank dp[i][j] = dp[i-1][j] || dp[i][j-1]; &#125; &#125; return dp[s.length()][p.length()];&#125; 46. Permutations (distinct)(medium)Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations: 12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Backtracking add to temp 1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // use backtracking, remember to use visited List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,nums,new ArrayList&lt;&gt;(),new boolean[nums.length]); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,List&lt;Integer&gt; temp,boolean[] visited)&#123; if(temp.size() == nums.length)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; // check visited, i from 0 to n for(int i=0;i&lt;nums.length;i++)&#123; if(visited[i]) continue; visited[i] = true; temp.add(nums[i]); backtrack(result,nums,temp,visited); // reset when return to here visited[i] = false; temp.remove(temp.size()-1); &#125;&#125; Backtracking swap (quicker) 1234567891011121314151617181920212223242526public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,nums,0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,int idx)&#123; if(idx == nums.length)&#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for(int num: nums) temp.add(num); result.add(temp); return; &#125; for(int i=idx;i&lt;nums.length;i++)&#123; swap(nums,idx,i); // swap every position with idx backtrack(result,nums,idx+1); // swap back when return here swap(nums,idx,i); &#125;&#125;private void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; 47. Permutations II (duplicates)(medium)Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations: 12345[ [1,1,2], [1,2,1], [2,1,1]] 1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); // need sorting to remove duplicate Arrays.sort(nums); backtrack(result,nums,new ArrayList&lt;&gt;(),new boolean[nums.length]); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,List&lt;Integer&gt; temp,boolean[] used)&#123; if(temp.size() == nums.length)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; // both !used[i-1] and used[i-1] work if(used[i] || i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!used[i-1]) continue; used[i] = true; temp.add(nums[i]); backtrack(result,nums,temp,used); used[i] = false; temp.remove(temp.size()-1); &#125;&#125; 48. Rotate Image (medium)Rotate the image by 90 degrees (clockwise). Note:You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. clockwise: upside down first, then symmetry anti-clockwise: left right first, then symmetry 1234567891011121314151617181920212223242526public void rotate(int[][] matrix) &#123; if(matrix.length==0 || matrix[0].length==0) return; if(matrix.length != matrix[0].length) return; // upside down int n = matrix.length; for(int col=0;col&lt;n;col++)&#123; int up = 0, down = n-1; while(up &lt; down)&#123; int temp = matrix[up][col]; matrix[up][col] = matrix[down][col]; matrix[down][col] = temp; up ++; down --; &#125; &#125; // symmetry for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125;&#125; 49. Group Anagrams (medium)Given an array of strings, group anagrams together. For example, given: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Return: 12345[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lower-case. HashMap, return 123456789101112131415161718public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; // using hashtable // key is sorted str List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); if(strs.length == 0) return result; for(String str: strs)&#123; char[] c = str.toCharArray(); Arrays.sort(c); String key = new String(c); if(!map.containsKey(key)) map.put(key,new ArrayList&lt;&gt;()); map.get(key).add(str); &#125; // map.keySet() map.values() return new ArrayList&lt;&gt;(map.values());&#125; 50. Pow(x,n) (medium)recursion 12345678910111213141516public double myPow(double x, int n) &#123; if(n == 0) return 1; if(n &lt; 0)&#123; // deal with int.min // +2 could remain even or odd if(n == Integer.MIN_VALUE) n+=2; n = -n; x = 1 / x; &#125; if(n % 2 == 0) return myPow(x*x,n/2); else return x * myPow(x*x,n/2);&#125; iteration 1234567891011121314151617181920public double myPow(double x, int n) &#123; if(n == 0) return 1; if(n &lt; 0)&#123; // deal with int.min // +2 could remain even or odd if(n == Integer.MIN_VALUE) n+=2; n = -n; x = 1 / x; &#125; double result = 1; while(n &gt; 0)&#123; if((n &amp; 1) == 1) // n is odd result *= x; x *= x; n &gt;&gt;= 1; &#125; return result;&#125; 51. N-Queens (hard)backtracking The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively. For example,There exist two distinct solutions to the 4-queens puzzle: 1234567891011[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); // construct blank board char[][] board = new char[n][n]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) board[i][j] = '.'; // backtracking backtrack(result,board,0); return result; &#125;private void backtrack(List&lt;List&lt;String&gt;&gt; result,char[][] board,int col)&#123; if(col == board.length)&#123; result.add(build(board)); return; &#125; // for each row, try each col, only one loop need for(int row=0;row&lt;board.length;row++)&#123; if(isValid(board,row,col))&#123; board[row][col] = 'Q'; backtrack(result,board,col+1); board[row][col] = '.'; &#125; &#125;&#125;private boolean isValid(char[][] board,int row,int col)&#123; int n = board.length; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(board[i][j] == '.') continue; // in same row, same col, same diagnal if(i==row || j==col || Math.abs(i-row)==Math.abs(j-col)) return false; &#125; &#125; return true;&#125;private List&lt;String&gt; build(char[][] board)&#123; // build board to a result instance int n = board.length; List&lt;String&gt; rows = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++) rows.add(String.valueOf(board[i])); return rows;&#125; 52. N-Queens II (hard)Now, instead outputting board configurations, return the total number of distinct solutions. 123456789101112131415161718192021222324252627282930313233343536public int totalNQueens(int n) &#123; // only check valid cases // use 4 boolean arrays to mark: // 1. traverse each row, no check same row // 2. same col occupied // 3. 45 diagnal occupied: y=x+b =&gt; b=y-x constant // 4. 135 diagnal occupied y=-x+b =&gt; b=y+x constant // board has 2n-1 diagnals each case int[] result = new int[1]; boolean[] cols = new boolean[n]; // for col boolean[] diag1 = new boolean[2*n-1]; // for y-x boolean[] diag2 = new boolean[2*n-1]; // for y+x backtrack(result,0,cols,diag1,diag2); return result[0]; &#125;private void backtrack(int[] result,int col,boolean[] cols,boolean[] diag1,boolean[] diag2)&#123; // traverse along rows, int n = cols.length; if(col == n)&#123; result[0]++; return; &#125; for(int row=0;row&lt;n;row++)&#123; int idx1 = col - row + n - 1; // n-1 offset int idx2 = col + row; if(cols[row] || diag1[idx1] || diag2[idx2]) continue; cols[row] = true; diag1[idx1] = true; diag2[idx2] = true; backtrack(result,col+1,cols,diag1,diag2); cols[row] = false; diag1[idx1] = false; diag2[idx2] = false; &#125;&#125; 53. Maximum subarray (easy)Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. 123456789public int maxSubArray(int[] nums) &#123; // save currSum and maxSum int currSum = 0, maxSum = nums[0]; for(int num: nums)&#123; currSum = Math.max(num,num+currSum); maxSum = Math.max(maxSum,currSum); &#125; return maxSum;&#125; 54. Spiral Matrix (medium)Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example,Given the following matrix: 12345[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] You should return [1,2,3,6,9,8,7,4,5]. 123456789101112131415161718192021222324252627public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(matrix.length==0 || matrix[0].length==0) return result; int r1 = 0, r2 = matrix.length-1; int c1 = 0, c2 = matrix[0].length-1; while(r1&lt;=r2 &amp;&amp; c1&lt;=c2)&#123; // add all r1 for(int c=c1;c&lt;=c2;c++) result.add(matrix[r1][c]); // add all c2 for(int r=r1+1;r&lt;=r2;r++) result.add(matrix[r][c2]); // if las row or col break if(r1==r2 || c1==c2) break; // add all r2 for(int c=c2-1;c&gt;=c1+1;c--) result.add(matrix[r2][c]); // add all c1 for(int r=r2;r&gt;=r1+1;r--) result.add(matrix[r][c1]); // update r1++;r2--;c1++;c2--; &#125; return result;&#125; 55. Jump Game (medium)Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example:A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. end to head, check whether it’s a good point 1234567891011public boolean canJump(int[] nums) &#123; if(nums.length == 0) return false; // last index that is a good point int last = nums.length - 1; for(int i=last-1;i&gt;=0;i--)&#123; if(i + nums[i] &gt;= last) last = i; &#125; return last == 0;&#125; 56. Merge Intervals (medium)Given a collection of intervals, merge all overlapping intervals. For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18]. 12345678910111213141516171819202122232425/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); if(intervals==null || intervals.size()==0) return result; Collections.sort(intervals,(o1,o2)-&gt;o1.start-o2.start); Interval prev = null; for(Interval curr : intervals)&#123; // result blank or no overlapping if(prev==null || curr.start&gt;prev.end)&#123; prev = curr; result.add(prev); &#125;else // have overlapping prev.end = Math.max(prev.end,curr.end); &#125; return result;&#125; 57. Insert Interval (hard)Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1:Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9]. Example 2:Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 12345678910111213141516171819202122232425262728293031323334/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); // assume already sorted // Collections.sort(intervals,(o1,o2)-&gt;o1.start-o2.start); int idx = 0; // add intervals before newIntervals first, no overlapping while(idx&lt;intervals.size() &amp;&amp; intervals.get(idx).end&lt;newInterval.start)&#123; result.add(intervals.get(idx)); idx++; &#125; // merge overlapping intervals, curr.end &gt;= new.start while(idx&lt;intervals.size() &amp;&amp; intervals.get(idx).start&lt;=newInterval.end)&#123; Interval curr = intervals.get(idx); newInterval.start = Math.min(newInterval.start,curr.start); newInterval.end = Math.max(newInterval.end,curr.end); idx++; &#125; result.add(newInterval); // add intervals after newIntervals, no overlapping while(idx&lt;intervals.size())&#123; result.add(intervals.get(idx)); idx++; &#125; return result;&#125; 58. Length of Last Word (easy)Given a string s consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: 12Input: &quot;Hello World&quot;Output: 5 123456789public int lengthOfLastWord(String s) &#123; int tail = s.length()-1; while(tail&gt;=0 &amp;&amp; s.charAt(tail)==' ') tail--; int head = tail; while(head&gt;=0 &amp;&amp; s.charAt(head)!=' ') head--; return tail - head;&#125; 59. Spiral Matrix II (medium)Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. For example,Given n = 3, You should return the following matrix: 12345[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 1234567891011121314151617181920public int[][] generateMatrix(int n) &#123; int[][] result = new int[n][n]; int num = 1; int r1 = 0, r2 = n - 1; int c1 = 0, c2 = n - 1; while(r1&lt;=r2 &amp;&amp; c1&lt;=c2)&#123; for(int c=c1;c&lt;=c2;c++) result[r1][c] = num++; for(int r=r1+1;r&lt;=r2;r++) result[r][c2] = num++; if(r1==r2 || c1==c2) break; for(int c=c2-1;c&gt;=c1+1;c--) result[r2][c] = num++; for(int r=r2;r&gt;=r1+1;r--) result[r][c1] = num++; r1++;r2--;c1++;c2--; &#125; return result;&#125; 61. Rotate List (medium)Given a list, rotate the list to the right by k places, where k is non-negative. Example: 12Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public ListNode rotateRight(ListNode head, int k) &#123; // notice corner case if(head == null || head.next == null) return head; ListNode dummy = new ListNode(0), fast = dummy; dummy.next = head; // find length first, and end node int len = 0; while(fast.next != null)&#123; len ++; fast = fast.next; &#125; // find node before new head // k may larger than len =&gt; % ListNode slow = dummy; for(int i=0;i&lt;len-k%len;i++) slow = slow.next; // rotation order, fast.next = dummy.next; dummy.next = slow.next; slow.next = null; return dummy.next;&#125; 62. Unique Paths (medium)A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? Note: m and n will be at most 100. 1234567891011121314public int uniquePaths(int m, int n) &#123; // time O(mn), space O(min(m,n)) if(m &lt;= 0 || n &lt;=0) return 0; // use 1D dp int[] dp = new int[n]; Arrays.fill(dp,1); for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; dp[j] += dp[j-1]; &#125; &#125; return dp[n-1];&#125; 63. Unique Paths II (medium)Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example, There is one obstacle in the middle of a 3x3 grid as illustrated below. 12345[ [0,0,0], [0,1,0], [0,0,0]] The total number of unique paths is 2. 12345678910111213141516171819public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; // similar to previous, use 1D DP if(obstacleGrid==null || obstacleGrid.length==0 || obstacleGrid[0].length==0) return 0; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[] dp = new int[n]; dp[0] = 1; // init head as 0 for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; // obstacle, curr count reset 0 if(obstacleGrid[i][j] == 1) dp[j] = 0; // accumulate when j &gt; 0 else if(j &gt; 0) dp[j] += dp[j-1]; &#125; &#125; return dp[n-1];&#125; 64. Minimum Path Sum (medium)Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example 1: 123[[1,3,1], [1,5,1], [4,2,1]] Given the above grid map, return 17 . Because the path 1→3→1→1→1 minimizes the sum. 12345678910111213141516public int minPathSum(int[][] grid) &#123; if(grid==null || grid.length==0 || grid[0].length==0) return 0; int m = grid.length, n = grid[0].length; // go through first row for(int j=1;j&lt;n;j++) grid[0][j] += grid[0][j-1]; // go through first col for(int i=1;i&lt;m;i++) grid[i][0] += grid[i-1][0]; // go through other for(int i=1;i&lt;m;i++) for(int j=1;j&lt;n;j++) grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]); return grid[m-1][n-1];&#125; 66. Plus One (easy)Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. 123456789101112131415161718192021public int[] plusOne(int[] digits) &#123; if(digits==null || digits.length==0) return new int[0]; // if 9, continue check previous, // if not 9, +1 will stop for(int i=digits.length-1;i&gt;=0;i--)&#123; if(digits[i] == 9) digits[i] = 0; else&#123; digits[i] ++; break; &#125; &#125; // if all 0 if(digits[0] == 0)&#123; int[] result = new int[digits.length+1]; result[0] = 1; return result; &#125; return digits;&#125; 67-add-binary-easyGiven two binary strings, return their sum (also a binary string). For example,a = &quot;11&quot;b = &quot;1&quot;Return &quot;100&quot;. 12345678910111213141516171819public String addBinary(String a, String b) &#123; if(a == null || b == null) return \"\"; // use string builder and reverse StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() - 1; int sum = 0; while(i &gt;= 0 || j &gt;= 0)&#123; if(i &gt;= 0) sum += a.charAt(i--) - '0'; if(j &gt;= 0) sum += b.charAt(j--) - '0'; sb.append(sum % 2); sum /= 2; &#125; if(sum != 0) sb.append(sum); return sb.reverse().toString(); &#125; 69. int sqrt(x) (easy)binary search 12345678910111213141516public int mySqrt(int x) &#123; if(x &lt;= 1) return x; int left = 1, right = x; while(true)&#123; int mid = left + (right-left)/2; if(mid &gt; x / mid) right = mid - 1; else&#123; // mid^2 &lt; x but mid+1 ^2 &gt; x if(mid+1 &gt; x/(mid+1)) return mid; left = mid + 1; &#125; &#125;&#125; #70-climbing-stairs-easyYou are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. **Example 2: 1234567Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step basic: Assume T(n-1) = O(2`n-1)`, therefore T(n) = T(n-1) + T(n-2) + O(1) which is equal to T(n) = O(2`n-1) + O(2n-2) + O(1) = O(2n)` 123456789101112public int climbStairs(int n) &#123; // n step is count n-1 step + count n-2 step if(n &lt;= 2) return n; int first = 1, second = 2, curr = 0; for(int i=3;i&lt;=n;i++)&#123; curr = first + second; first = second; second = curr; &#125; return curr;&#125; add memo top down: 1234567891011121314public int climbStairs(int n) &#123; // 0:1, 1:1, 2:2, 3:3, 4:5, 5:8 if(n &lt;= 1) return 1; int[] memo = new int[n+1]; return helper(n,memo);&#125;private int helper(int n,int[] memo)&#123; if(n &lt;= 1) return 1; if(memo[n] != 0) return memo[n]; memo[n] = helper(n-1,memo) + helper(n-2,memo); return memo[n];&#125; top down dp iteration space O(n) 12345678public int climbStairs(int n) &#123; int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for(int i=2; i&lt;=n; i++) dp[i] = dp[i-1] + dp[i-2]; return dp[n];&#125; iteration O(1) 1234567891011public int climbStairs(int n) &#123; if(n &lt;= 1) return 1; int first = 1, second = 1, result = 0; for(int i=2; i&lt;=n; i++)&#123; result = first + second; first = second; second = result; &#125; return result;&#125; #71-simplify-path-mediumGiven an absolute path for a file (Unix-style), simplify it. For example,path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot; Did you consider the case where path = &quot;/../&quot;?In this case, you should return &quot;/&quot;. Another corner case is the path might contain multiple slashes &#39;/&#39; together, such as &quot;/home//foo/&quot;.In this case, you should ignore redundant slashes and return &quot;/home/foo&quot;. 1234567891011121314151617181920212223242526272829public String simplifyPath(String path) &#123; // use stack .. pop else push if(path == null || path.length() == 0) return \"\"; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for(String s : path.split(\"/\"))&#123; // case .(curr folder) continue if(s.equals(\".\")) continue; // case .. prev folder else if(s.equals(\"..\"))&#123; if(!stack.isEmpty()) stack.pop(); // case name dir, not empty, not /// &#125;else if(!s.isEmpty())&#123; stack.push(s); &#125; &#125; // case / if(stack.isEmpty()) return \"/\"; // pop and build result StringBuilder sb = new StringBuilder(); // build list from stack List&lt;String&gt; list = new ArrayList&lt;&gt;(stack); for(String s : list) sb.append(\"/\").append(s); return sb.toString();&#125; #72-edit-distance-hardGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: 123456Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;) Example 2: 12345678Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;) 123456789101112131415161718192021222324252627282930public int minDistance(String word1, String word2) &#123; // similar regex if(word1==null || word2==null) return 0; // row word1, col word2 int[][] dp = new int[word2.length()+1][word1.length()+1]; // init first row: word1 to \"\" for(int j=0; j&lt;word1.length(); j++) dp[0][j+1] = dp[0][j] + 1; // init first col: \"\" to word2 for(int i=0; i&lt;word2.length(); i++) dp[i+1][0] = dp[i][0] + 1; // the other for(int i=0; i&lt;word2.length(); i++)&#123; for(int j=0; j&lt;word1.length(); j++)&#123; // char1 != char2: // 1. insert: dp[i][j] = dp[i-1][j]+1; // 2. replace: dp[i][j] = dp[i-1][j-1]+1; // 3. delete: dp[i][j] = dp[i][j-1]+1; if(word2.charAt(i) != word1.charAt(j))&#123; dp[i+1][j+1] = 1 + Math.min(dp[i][j], Math.min(dp[i][j+1], dp[i+1][j])); &#125;else // case char1 == char2 dp[i+1][j+1] = dp[i][j]; &#125; &#125; return dp[word2.length()][word1.length()];&#125; #73-set-matrix-zeros-mediumGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Did you use extra space?A straight forward solution using O(m**n) space is probably a bad idea.A simple improvement uses O(m + n) space, but still not the best solution.Could you devise a constant space solution? 123456789101112131415161718192021222324252627282930313233343536373839public void setZeroes(int[][] matrix) &#123; // set all leading row &amp; col to zeros if(matrix.length==0 || matrix[0].length==0) return; boolean firstRow = false, firstCol = false; int row = matrix.length, col = matrix[0].length; // check first col for(int i=0;i&lt;row;i++) if(matrix[i][0] == 0) firstCol = true; // check first row for(int j=0;j&lt;col;j++) if(matrix[0][j] == 0) firstRow = true; // the other for(int i=1;i&lt;row;i++)&#123; for(int j=1;j&lt;col;j++)&#123; if(matrix[i][j] == 0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; // set 0 skip first row &amp; col for(int i=1;i&lt;row;i++)&#123; for(int j=1;j&lt;col;j++)&#123; if(matrix[i][0]==0 || matrix[0][j]==0) matrix[i][j] = 0; &#125; &#125; // update first row &amp; col can cause problem // update first row &amp; col if(firstRow) for(int j=0;j&lt;col;j++) matrix[0][j] = 0; if(firstCol) for(int i=0;i&lt;row;i++) matrix[i][0] = 0;&#125; #74-search-a-2d-matrix-mediumWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example, Consider the following matrix: 12345[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] Given target = 3, return true. 1234567891011121314151617181920public boolean searchMatrix(int[][] matrix, int target) &#123; // convert to binary search if(matrix==null || matrix.length==0 || matrix[0].length==0) return false; final int m = matrix.length, n = matrix[0].length; // left right should be index int left = 0, right = m * n - 1; while(left &lt;= right)&#123; int mid = left + (right-left)/2; int row = mid / n; int col = mid % n; if(matrix[row][col] == target) return true; else if(matrix[row][col] &lt; target) left = mid + 1; else right = mid - 1; &#125; return false;&#125; #75-sort-colors-mediumGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem. 1234567891011121314151617181920public void sortColors(int[] nums) &#123; // 0000|i|1111|j|????|k|2222 if(nums==null || nums.length==0) return; int i = 0, j = 0, k = nums.length-1; // j is unvisited, notice j = k while(j &lt;= k)&#123; if(nums[j] == 0)&#123; swap(nums,i++,j++); &#125;else if(nums[j] == 1) j++; else if(nums[j] == 2) swap(nums,j,k--); &#125;&#125;private void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; 123456789101112131415161718public void sortColors(int[] nums) &#123; // 0000|i|1111|j|????|k|2222 if(nums==null || nums.length==0) return; int i = 0, j = 0, k = nums.length-1; // j is unvisited, notice j = k while(j &lt;= k)&#123; if(nums[j] == 0)&#123; nums[j++] = nums[i]; nums[i++] = 0; &#125;else if(nums[j] == 1)&#123; j ++; &#125;else if(nums[j] == 2)&#123; nums[j] = nums[k]; nums[k--] = 2; &#125; &#125;&#125; #76-minimun-window-substring-hardGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). For example,S = &quot;ADOBECODEBANC&quot;T = &quot;ABC&quot; Minimum window is &quot;BANC&quot;. Note:If there is no such window in S that covers all characters in T, return the empty string &quot;&quot;. If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S. 1234567891011121314151617181920212223242526272829public String minWindow(String s, String t) &#123; if(s==null || t==null) return \"\"; // find t histogram first int[] bin = new int[256]; for(char c : t.toCharArray()) bin[c] ++; // sliding window int head = 0, count = t.length(); int minLen = s.length() + 1, minHead = 0; for(int tail=0;tail&lt;s.length();tail++)&#123; if(bin[s.charAt(tail)] &gt; 0) count --; bin[s.charAt(tail)]--; // valid edge condition while(count == 0)&#123; // update min then shift window if(tail-head+1 &lt; minLen)&#123; minLen = tail - head + 1; minHead = head; &#125; if(bin[s.charAt(head)] == 0) count ++; bin[s.charAt(head)]++; head++; &#125; &#125; return minLen &gt; s.length() ? \"\" : s.substring(minHead,minHead+minLen);&#125; #77-combinations-mediumGiven two integers n and k, return all possible combinations of k numbers out of 1 … n. For example,If n = 4 and k = 2, a solution is: 12345678[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; // backtracking List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,new ArrayList&lt;&gt;(),1,n,k); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,List&lt;Integer&gt; temp,int start,int end,int count)&#123; // optimization here, if start to close to end so no enough elements if(count - temp.size() &gt; end - start + 1) return; ////////////////////////////////////// if(temp.size() == count)&#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=start;i&lt;=end;i++)&#123; temp.add(i); backtrack(result,temp,i+1,end,count); temp.remove(temp.size()-1); &#125;&#125; #78-subsets-mediumGiven a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; // backtracking // distinct List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); backtrack(result,nums,new ArrayList&lt;&gt;(),0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result, int[] nums,List&lt;Integer&gt; temp,int idx)&#123; // add result each level result.add(new ArrayList&lt;&gt;(temp)); for(int i=idx;i&lt;nums.length;i++)&#123; temp.add(nums[i]); backtrack(result,nums,temp,i+1); temp.remove(temp.size()-1); &#125;&#125; #79-word-search-mediumGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example,Given board = 12345[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]] word = &quot;ABCCED&quot;, -&gt; returns true, word = &quot;SEE&quot;, -&gt; returns true, word = &quot;ABCB&quot;, -&gt; returns false. 12345678910111213141516171819202122232425262728293031public boolean exist(char[][] board, String word) &#123; // similar to num of island // use ^256 to obtain space O(1) if(board==null || board.length==0 || board[0].length==0) return false; final int m = board.length, n = board[0].length; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(helper(board,word,0,i,j)) return true; &#125; &#125; return false;&#125;private boolean helper(char[][] board,String word,int idx,int x,int y)&#123; if(idx == word.length()) return true; if(x&lt;0 || x&gt;=board.length || y&lt;0 || y&gt;=board[0].length || word.charAt(idx)!=board[x][y]) return false; // set to not a valid letter board[x][y] ^= 256; if(helper(board,word,idx+1,x-1,y) || helper(board,word,idx+1,x+1,y) || helper(board,word,idx+1,x,y-1) || helper(board,word,idx+1,x,y+1)) return true; // reset to letter board[x][y] ^= 256; return false;&#125; #80-remove-duplicates-from-sorted-array-ii-mediumFollow up for “Remove Duplicates”:What if duplicates are allowed at most twice? For example,Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length. 1234567891011121314151617181920212223242526public int removeDuplicates(int[] nums) &#123; if(nums==null) return 0; if(nums.length &lt;= 2) return nums.length; int tail = 2; // similar but check tail - 2 for(int i=2;i&lt;nums.length;i++)&#123; if(nums[i] != nums[tail-2]) nums[tail++] = nums[i]; &#125; return tail;&#125;public int removeDuplicates(int[] nums) &#123; // optimized if(nums==null) return 0; if(nums.length &lt;= 2) return nums.length; int tail = 0; for(int num : nums)&#123; if(tail &lt; 2 || num != nums[tail-2]) nums[tail++] = num; &#125; return tail;&#125; #81-search-in-rotated-sorted-array-ii-medium Follow up for “Search in Rotated Sorted Array”:What if duplicates are allowed? Would this affect the run-time complexity? How and why? #33-search-in-rotated-sorted-array-medium Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. 12345678910111213141516171819202122232425262728293031323334353637 public boolean search(int[] nums, int target) &#123;// 1) everytime check if targe == nums[mid], if so, we find it.// 2) otherwise, we check if the first half is in order (i.e. nums[left]&lt;=nums[mid]) // and if so, go to step 3), otherwise, the second half is in order, go to step 4)// 3) check if target in the range of [left, mid-1] (i.e. nums[left]&lt;=target &lt; nums[mid]), // if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;// 4) check if target in the range of [mid+1, right] (i.e. nums[mid]&lt;target &lt;= nums[right]), // if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1; if(nums==null || nums.length==0) return false; int left = 0, right = nums.length - 1; while(left &lt;= right)&#123; int mid = left + (right-left)/2; if(nums[mid] == target) return true; // difference to deal with duplicate here if(nums[left]==nums[mid] &amp;&amp; nums[mid]==nums[right])&#123; left++; right--; // left half not rotate &#125;else if(nums[left] &lt;= nums[mid])&#123; // mid in not rotate part if(nums[left]&lt;=target &amp;&amp; target&lt;nums[mid]) right = mid - 1; // mid in rotate part else left = mid + 1; // right half not rotate &#125;else if(nums[mid] &lt;= nums[right])&#123; // mid in not rotate part if(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right]) left = mid + 1; // mid in rotate part else right = mid -1; &#125; &#125; return false; &#125; #82-remove-duplicates-from-sorted-list-ii-mediumGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode dummy = new ListNode(0); ListNode prev = dummy, curr = head; dummy.next = head; while(curr != null)&#123; // if next val = curr val, check next while(curr.next!=null &amp;&amp; curr.val==curr.next.val) curr = curr.next; // if curr is distinct if(prev.next == curr) prev = prev.next; else // prev stays, case next sequence duplication // curr is the last duplication prev.next = curr.next; curr = curr.next; &#125; return dummy.next;&#125; #83-remove-duplicates-from-sorted-list-easyGiven a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. iteration 1234567891011public ListNode deleteDuplicates(ListNode head) &#123; if(head==null || head.next==null) return head; ListNode curr = head; while(curr != null)&#123; while(curr.next!=null &amp;&amp; curr.val==curr.next.val) curr.next = curr.next.next; curr = curr.next; &#125; return head;&#125; recursion 1234567public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); // here head.next != null return head.val == head.next.val ? head.next : head;&#125; #84-largest-rectangle-in-histogram-hardGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. For example,Given heights = [2,1,5,6,2,3],return 10. #42-trapping-rain-water-hard 123456789101112131415161718192021// Maintains an increasing stack// encounter smaller height, check all previous areas.public int largestRectangleArea(int[] heights) &#123; Stack&lt;Integer&gt; idxStack = new Stack&lt;&gt;(); int maxArea = 0; for (int i = 0; i &lt;= heights.length; i++) &#123; // push -1 for last, to pop all previous int height = i == heights.length ? 0 : heights[i]; // when increasing is broken while (!idxStack.isEmpty() &amp;&amp; heights[idxStack.peek()] &gt;= height) &#123; // get previous higher one, compute previous area // it's all area from smaller to the highest int h = heights[idxStack.pop()]; // if is empty, there is a bottom rectangle from current to head int w = idxStack.isEmpty() ? i : i - 1 - idxStack.peek(); maxArea = Math.max(maxArea, h * w); &#125; idxStack.push(i); &#125; return maxArea;&#125; optimized beats 98%, check left then right idea 1234567891011121314151617181920212223242526272829public int largestRectangleArea(int[] heights) &#123; // save left and right index // width is most left &amp; right idx whose h is larger if(heights==null || heights.length==0) return 0; int[] left = new int[heights.length]; int[] right = new int[heights.length]; // find left/right index whose h is larger // utilize previous result to reduce run time for(int i=0;i&lt;heights.length;i++)&#123; int l = i-1; while(l&gt;=0 &amp;&amp; heights[l]&gt;=heights[i]) l = left[l]; left[i] = l; &#125; for(int i=heights.length-1;i&gt;=0;i--)&#123; int r = i+1; while(r&lt;heights.length &amp;&amp; heights[r]&gt;=heights[i]) r = right[r]; right[i] = r; &#125; // then for h, the width is r - l - 1; int maxArea = 0; for(int i=0;i&lt;heights.length;i++)&#123; int w = right[i] - left[i] - 1; maxArea = Math.max(maxArea,heights[i]*w); &#125; return maxArea;&#125; #86-partition-list-mediumGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: 12Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 12345678910111213141516171819public ListNode partition(ListNode head, int x) &#123; // use two head; ListNode dummy1 = new ListNode(0), prev1 = dummy1; ListNode dummy2 = new ListNode(0), prev2 = dummy2; while(head != null)&#123; if(head.val &lt; x)&#123; prev1.next = head; prev1 = prev1.next; &#125;else&#123; prev2.next = head; prev2 = prev2.next; &#125; head = head.next; &#125; // combine two list prev1.next = dummy2.next; prev2.next = null; return dummy1.next;&#125; #87-scramble-string-hardGiven a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = &quot;great&quot;: 1234567 great / \\ gr eat / \\ / \\g r e at / \\ a t To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;. 1234567 rgeat / \\ rg eat / \\ / \\r g e at / \\ a t We say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;. Similarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;. 1234567 rgtae / \\ rg tae / \\ / \\r g ta e / \\ t a We say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: 12Input: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;Output: true Example 2: 12Input: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;Output: false 12345678910111213141516171819202122232425262728public boolean isScramble(String s1, String s2) &#123; // check all possible case if(s1.equals(s2)) return true; // check char count int[] bin = new int[256]; for(int i=0; i&lt;s1.length(); i++)&#123; bin[s1.charAt(i)]++; bin[s2.charAt(i)]--; &#125; // check is char equal for(int n : bin) if(n != 0) return false; // recursion call, check all substring // origin not include, from 1 to length for(int i=1; i&lt;s1.length(); i++)&#123; // a b | c d e, a b | d e c if(isScramble(s1.substring(0,i),s2.substring(0,i)) &amp;&amp; isScramble(s1.substring(i),s2.substring(i))) return true; // a b | c d e, c d e | a b if(isScramble(s1.substring(0,i),s2.substring(s2.length()-i)) &amp;&amp; isScramble(s1.substring(i),s2.substring(0,s2.length()-i))) return true; &#125; return false;&#125; #88-merge-sorted-array-easyGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: 12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 12345678public void merge(int[] nums1, int m, int[] nums2, int n) &#123; // from end to head, int i = m - 1, j = n - 1, k = m + n - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) nums1[k--] = nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--]; while(j &gt;= 0) // nums2 rest nums1[k--] = nums2[j--];&#125; #89-gray-code-mediumThe gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given n = 2, return [0,1,3,2]. Its gray code sequence is: 123400 - 001 - 111 - 310 - 2 Note:For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. 123456789public List&lt;Integer&gt; grayCode(int n) &#123; // bit manipulate List&lt;Integer&gt; result = new ArrayList(); // total should &lt; 1 &lt;&lt; n for(int i=0; i &lt; 1&lt;&lt;n; i++)&#123; result.add(i ^ i&gt;&gt;1); &#125; return result;&#125; #90-subsets-ii-mediumGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 12345678910Input: [1,2,2]Output:[ [2], [1], [1,2,2], [2,2], [1,2], []] 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); // since remove duplicate, need sorting Arrays.sort(nums); backtrack(result,nums,new ArrayList&lt;&gt;(),0); return result;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; result,int[] nums,List&lt;Integer&gt; temp,int idx)&#123; // no need to check result.add(new ArrayList&lt;&gt;(temp)); for(int i=idx;i&lt;nums.length;i++)&#123; // jump duplicate // notice its &gt; idx not &gt; 0 if(i&gt;idx &amp;&amp; nums[i]==nums[i-1]) continue; temp.add(nums[i]); backtrack(result,nums,temp,i+1); temp.remove(temp.size()-1); &#125;&#125; #92-reverse-linked-list-ii-mediumReverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 1234567891011121314151617public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummy = new ListNode(0); ListNode start = dummy; dummy.next = head; // find slow prev first for(int i=1; i&lt;m; i++) start = start.next; // end not change, curr for saving ListNode end = start.next, curr = null; for(int i=0; i&lt;n-m; i++)&#123; curr = end.next; end.next = curr.next; curr.next = start.next; start.next = curr; &#125; return dummy.next;&#125; #93-restore-ip-addresses-mediumGiven a string containing only digits, restore it by returning all possible valid IP address combinations. Example: 12Input: &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 12345678910111213141516171819202122232425262728293031public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); backtrack(result,s,new StringBuilder(),0,1); return result;&#125;private void backtrack(List&lt;String&gt; result,String s,StringBuilder sb,int idx,int block)&#123; // to 5 block and s is empty if(block == 5 &amp;&amp; idx == s.length())&#123; result.add(sb.toString()); return; &#125; // s left or block left if(block &gt; 4 || idx == s.length()) return; int len = sb.length(); // for reset // one block most 3 digit for(int i=1; i&lt;4 &amp;&amp; idx+i&lt;=s.length(); i++)&#123; String partition = s.substring(idx,idx+i); // case 001 &amp;&amp; 256 if(i!=1 &amp;&amp; partition.charAt(0)=='0' || i==3 &amp;&amp; Integer.parseInt(partition)&gt;255) continue; sb.append(partition); // for seperator if(block &lt; 4) sb.append('.'); // backtrack backtrack(result,s,sb,idx+i,block+1); sb.setLength(len); &#125;&#125; #94-binary-tree-inorder-traversal-mediumRecursion: 123456789101112public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); dfs(root,result); return result;&#125;private void dfs(TreeNode root,List&lt;Integer&gt; result)&#123; if(root == null) return; dfs(root.left,result); result.add(root.val); dfs(root.right,result);&#125; Iteration: 123456789101112131415public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.isEmpty() || root!=null)&#123; if(root != null)&#123; stack.push(root); root = root.left; &#125;else&#123; TreeNode curr = stack.pop(); result.add(curr.val); root = curr.right; &#125; &#125; return result;&#125; #95-unique-bst-ii-mediumGiven an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. Example: 1234567891011121314151617Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&apos;s shown below: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 1234567891011121314151617181920212223242526272829public List&lt;TreeNode&gt; generateTrees(int n) &#123; if(n == 0) return new ArrayList&lt;&gt;(); return helper(1,n); &#125;public List&lt;TreeNode&gt; helper(int left,int right)&#123; List&lt;TreeNode&gt; trees = new ArrayList&lt;&gt;(); if(left &gt; right)&#123; trees.add(null); return trees; &#125; if(left == right)&#123; trees.add(new TreeNode(left)); return trees; &#125; for(int rootVal=left; rootVal&lt;=right; rootVal++)&#123; List&lt;TreeNode&gt; leftSubTrees = helper(left,rootVal-1); List&lt;TreeNode&gt; rightSubTrees = helper(rootVal+1,right); for(TreeNode l : leftSubTrees)&#123; for(TreeNode r : rightSubTrees)&#123; TreeNode root = new TreeNode(rootVal); root.left = l; root.right = r; trees.add(root); &#125; &#125; &#125; return trees;&#125; #96-unique-bst-mediumGiven n, how many structurally unique BST’s (binary search trees) that store values 1 … n? Example: 12345678910Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST&apos;s: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 12345678910111213141516public int numTrees(int n) &#123; // for n = 5 // if 1 as root, dp[0] * dp[4] // if 2 as root, dp[1] * dp[3] // if 3 as root, dp[2] * dp[2] // if 4 as root, dp[3] * dp[1] // if 5 as root, dp[4] * dp[0] // find how many node in left &amp; right subtree int[] dp = new int[n+1]; dp[0] = 1; // use 1 * the other subtree dp[1] = 1; for(int i=2; i&lt;=n; ++i) for(int j=0; j&lt;i; ++j) dp[i] += dp[j] * dp[i-1-j]; return dp[n];&#125; #97-interleaving-string-hardGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: 12Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;Output: true Example 2: 12Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;Output: false 12345678910111213141516171819202122232425262728293031public boolean isInterleave(String s1, String s2, String s3) &#123; if(s1==null || s2==null || s3==null) return false; if(s1.length() + s2.length() != s3.length()) return false; // s2 row, s1 col boolean[][] dp = new boolean[s1.length()+1][s2.length()+1]; dp[0][0] = true; // \"\" + \"\" == \"\" // init first row: check j-1 &amp;&amp; char==char for s2 for(int j=0; j&lt;s2.length(); j++) dp[0][j+1] = dp[0][j] &amp;&amp; s2.charAt(j)==s3.charAt(j); // init first col: check i-1 &amp;&amp; char==char for s1 for(int i=0; i&lt;s1.length(); i++) dp[i+1][0] = dp[i][0] &amp;&amp; s1.charAt(i)==s3.charAt(i); // dp for(int i=0; i&lt;s1.length(); i++)&#123; for(int j=0; j&lt;s2.length(); j++)&#123; // case1, add s1.char at tail // [i-1][j] &amp;&amp; s1.char==s3.char // case2, add s2.char at tail // [i][j-1] &amp;&amp; s2.char==s3.char char c1 = s1.charAt(i); char c2 = s2.charAt(j); char c3 = s3.charAt(i+j+1); // notice +1 // use if will quicker dp[i+1][j+1] = (dp[i][j+1] &amp;&amp; c1==c3) || (dp[i+1][j] &amp;&amp; c2==c3); &#125; &#125; return dp[s1.length()][s2.length()];&#125; #98-validate-binary-search-tree-mediumGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 1234567891011121314151617181920public boolean isValidBST(TreeNode root) &#123; // inorder iteration Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode prev = null; while(!stack.isEmpty() || root!=null)&#123; if(root != null)&#123; stack.push(root); root = root.left; &#125;else&#123; TreeNode curr = stack.pop(); // do inorder here if(prev==null || prev.val&lt;curr.val) prev = curr; // valid, mush &lt; else return false; root = curr.right; &#125; &#125; return true;&#125; #100-same-tree-easy123456789public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p==null &amp;&amp; q==null) return true; if(p==null || q==null) return false; if(p.val == q.val) return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); return false;&#125; #101-symmetric-tree-easyrecursion: 12345678910111213public boolean isSymmetric(TreeNode root) &#123; return root == null || isSymmetric(root.left,root.right); &#125;private boolean isSymmetric(TreeNode left,TreeNode right)&#123; if(left == null &amp;&amp; right == null) return true; if(left == null || right == null) return false; if(left.val == right.val) return isSymmetric(left.left,right.right) &amp;&amp; isSymmetric(left.right,right.left); return false;&#125; iteration: 12345678910111213141516171819202122public boolean isSymmetric(TreeNode root) &#123; if(root == null) return true; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root.left); queue.offer(root.right); while(queue.size() &gt;= 2)&#123; TreeNode left = queue.poll(); TreeNode right = queue.poll(); if(left==null &amp;&amp; right==null) continue; if(left==null || right==null) return false; if(left.val != right.val) return false; queue.add(left.left); queue.add(right.right); queue.add(left.right); queue.add(right.left); &#125; return true;&#125; #102-level-order-traversal-mediumIteration: 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(size); result.add(level); for(int i=0; i&lt;size; i++)&#123; TreeNode curr = queue.poll(); level.add(curr.val); if(curr.left != null) queue.offer(curr.left); if(curr.right != null) queue.offer(curr.right); &#125; &#125; return result;&#125; DFS recursion: 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; dfs(result,root,0); return result;&#125;private void dfs(List&lt;List&lt;Integer&gt;&gt; result, TreeNode root,int level)&#123; if(root == null) return; if(result.size() &lt; level + 1) result.add(new ArrayList&lt;&gt;()); result.get(level).add(root.val); dfs(result,root.left,level+1); dfs(result,root.right,level+1);&#125; DFS iteration: 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Map&lt;TreeNode,Integer&gt; map = new HashMap&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); map.put(root,0); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); int level = map.get(node); if(level + 1 &gt; result.size()) result.add(new ArrayList&lt;&gt;()); result.get(level).add(node.val); if(node.right != null)&#123; stack.push(node.right); map.put(node.right,level+1); &#125; if(node.left != null)&#123; stack.push(node.left); map.put(node.left,level+1); &#125; &#125; return result;&#125; Level order II 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if(root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(size); result.add(0,level); for(int i=0; i&lt;size; i++)&#123; TreeNode curr = queue.poll(); level.add(curr.val); if(curr.left != null) queue.offer(curr.left); if(curr.right != null) queue.offer(curr.right); &#125; &#125; return result;&#125; #103-zigzag-level-order-traversal-mediumGiven a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 return its zigzag level order traversal as: 12345[ [3], [20,9], [15,7]] 1234567891011121314151617181920212223242526public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int cnt = 0; while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; level = new LinkedList&lt;&gt;(); result.add(level); for(int i=0; i&lt;size; i++)&#123; TreeNode curr = queue.poll(); if(cnt % 2 == 0) level.add(curr.val); else level.add(0,curr.val); if(curr.left != null) queue.offer(curr.left); if(curr.right != null) queue.offer(curr.right); &#125; cnt ++; &#125; return result;&#125; #105-construct-tree-preorder-inorder-mediumGiven preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] Return the following binary tree: 12345 3 / \\9 20 / \\ 15 7 123456789101112131415161718192021public TreeNode buildTree(int[] preorder, int[] inorder) &#123; // use preorder traverse root, inorder find left &amp; right return helper(preorder,inorder,0,0,inorder.length-1);&#125;private TreeNode helper(int[] preorder,int[] inorder,int preTail,int inHead,int inTail)&#123; if(inHead &gt; inTail || preTail==preorder.length) return null; TreeNode node = new TreeNode(preorder[preTail]); // search node in inorder int idx = 0; for(int i=inHead; i&lt;=inTail; i++)&#123; if(inorder[i] == node.val) idx = i; &#125; // [inHead, i-1] left part, [i+1,inTail] right part int leftNode = preTail + 1; int rightNode = preTail + 1 + idx - inHead; node.left = helper(preorder,inorder,leftNode,inHead,idx-1); node.right = helper(preorder,inorder,rightNode,idx+1,inTail); return node;&#125; #106-construct-tree-inorder-postorder-mediumGiven inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12inorder = [9,3,15,20,7]postorder = [9,15,7,20,3] Return the following binary tree: 12345 3 / \\9 20 / \\ 15 7 12345678910111213141516171819202122232425public TreeNode buildTree(int[] inorder, int[] postorder) &#123; // from postorder define root, left child, // from inorder define left half, right half return helper(inorder, postorder, 0, inorder.length-1, 0, postorder.length-1);&#125;private TreeNode helper(int[] inorder, int[] postorder, int inHead, int inTail, int postHead, int postTail)&#123; // postHead,postTail not matter if(inHead &gt; inTail || postHead &gt; postTail) return null; // use postTail define root TreeNode node = new TreeNode(postorder[postTail]); // define left half and right half, search in inorder int idx = 0; for(int i=inHead; i&lt;=inTail; i++) if(inorder[i] == node.val)&#123; idx = i; break; &#125; // define left child and right child int leftNode = postHead + (idx - inHead - 1); int rightNode = leftNode + 1; node.left = helper(inorder,postorder,inHead,idx-1,postHead,leftNode); node.right = helper(inorder,postorder,idx+1,inTail,rightNode,postTail-1); return node;&#125; #109-sorted-list-to-bst-mediumGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 12345678910111213141516171819202122public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; // from here see tail init null, exclude return helper(head,null);&#125;private TreeNode helper(ListNode head,ListNode tail)&#123; // tail exclude if(head == tail) return null; ListNode slow = head, fast = head; // find mid when fast reach tail while(fast != tail &amp;&amp; fast.next != tail)&#123; slow = slow.next; fast = fast.next.next; &#125; // mid is slow TreeNode node = new TreeNode(slow.val); node.left = helper(head,slow);// mid exclude node.right = helper(slow.next,tail); return node;&#125; #110-balanced-binary-tree-easy12345678910111213public boolean isBalanced(TreeNode root) &#123; if(root == null) return true; int left = depth(root.left); int right = depth(root.right); if(Math.abs(left - right) &gt; 1) return false; return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125;private int depth(TreeNode root)&#123; return root == null ? 0 : 1 + Math.max(depth(root.left),depth(root.right));&#125; #111-min-depth-of-binary-tree-easy12345678910public int minDepth(TreeNode root) &#123; if(root == null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); if(left == 0 || right == 0) return left + right + 1; else return Math.min(left,right) + 1;&#125; #112-path-sum-easyGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. 12345678public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; // when leaf node if(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==sum) return true; return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);&#125; #113-path-sum-ii-mediumGiven a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); helper(root,sum,result,new ArrayList&lt;&gt;()); return result;&#125;private void helper(TreeNode root,int sum,List&lt;List&lt;Integer&gt;&gt; result,List&lt;Integer&gt; temp)&#123; if(root == null) return; // add here, add when null=&gt;duplicate result temp.add(root.val); // valid result added if(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==sum) result.add(new ArrayList&lt;&gt;(temp)); // left and right helper(root.left,sum-root.val,result,temp); helper(root.right,sum-root.val,result,temp); // remove curr temp.remove(temp.size()-1);&#125; #114-flatten-binary-tree-to-linked-list-mediumGiven a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 / \\ 2 5 / \\ \\3 4 6 The flattened tree should look like: 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 12345678910111213class Solution &#123; TreeNode prev = null; public void flatten(TreeNode root) &#123; if(root == null) return; // use reverse post order flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; &#125;&#125; #115-distinct-subsequences-hardGiven a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ACE&quot; is a subsequence of &quot;ABCDE&quot; while &quot;AEC&quot; is not). Example 1: 12345678910111213Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;Output: 3Explanation:As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.(The caret symbol ^ means the chosen letters)rabbbit^^^^ ^^rabbbit^^ ^^^^rabbbit^^^ ^^^ 12345678910111213141516171819202122232425public int numDistinct(String s, String t) &#123; // similar to regex 10 // use dp if(s==null || t==null) return 0; // rows t, columns s, remove char from s int[][] dp = new int[t.length()+1][s.length()+1]; // init first row: remove all to get \"\" for(int col=0; col&lt;=s.length(); col++) dp[0][col] = 1; // init first col: should all be 0: \"\" cannot get un-\"\" for(int i=0; i&lt;t.length(); i++)&#123; // for t for(int j=0; j&lt;s.length(); j++)&#123; // for s // 1. if same char: keep it || remove it // if keep dp[i][j] = dp[i-1][j-1]; // if remove dp[i][j] = dp[i][j-1]; if(s.charAt(j) == t.charAt(i))&#123; dp[i+1][j+1] = dp[i][j] + dp[i+1][j]; &#125;else&#123; // 2. if not same: remove it dp[i+1][j+1] = dp[i+1][j]; &#125; &#125; &#125; return dp[t.length()][s.length()]; &#125; #116-populating-next-right-pointer-mediumGiven a binary tree 12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. After calling your function, the tree should look like: 12345 1 -&gt; NULL / \\ 2 -&gt; 3 -&gt; NULL / \\ / \\4-&gt;5-&gt;6-&gt;7 -&gt; NULL 1234567891011121314151617public void connect(TreeLinkNode root) &#123; if(root == null) return; TreeLinkNode level = root, curr = null; while(level != null)&#123; curr = level; while(curr != null)&#123; if(curr.left != null)&#123; curr.left.next = curr.right; if(curr.next != null) curr.right.next = curr.next.left; &#125; curr = curr.next; &#125; level = level.left; &#125;&#125; #117-populating-next-right-pointer-ii-mediumGiven the following binary tree, 12345 1 / \\ 2 3 / \\ \\4 5 7 After calling your function, the tree should look like: 12345 1 -&gt; NULL / \\ 2 -&gt; 3 -&gt; NULL / \\ \\4-&gt; 5 -&gt; 7 -&gt; NULL 123456789101112131415161718192021222324252627282930public void connect(TreeLinkNode root) &#123; TreeLinkNode curr = root; // one high level TreeLinkNode head = null, prev = null; // two low level while(curr != null)&#123; // in curr level while(curr != null)&#123; if(curr.left != null)&#123; if(prev == null)&#123; // no head found head = curr.left; &#125;else&#123; prev.next = curr.left; &#125; prev = curr.left; &#125; if(curr.right != null)&#123; if(prev == null)&#123; head = curr.right; &#125;else&#123; prev.next = curr.right; &#125; prev = curr.right; &#125; curr = curr.next; &#125; // jump to next level head &amp; reset curr = head; head = null; prev = null; &#125;&#125; #118-pascals-triangle-easy123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 1234567891011public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for(int row=1; row&lt;=numRows; row++)&#123; temp.add(1); for(int i=temp.size()-2; i&gt;0; i--) temp.set(i,temp.get(i)+temp.get(i-1)); result.add(new ArrayList&lt;&gt;(temp)); &#125; return result;&#125; #120-triangle-mediumGiven a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 1234567891011121314151617public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; // add bottom up, so that space O(1) if(triangle.size() == 0) return 0; int n = triangle.size(); // n+1 for the last line int[] memo = new int[n+1]; // for location i, check i &amp; i+1 for(int i=n-1; i&gt;=0; i--)&#123; for(int j=0; j&lt;triangle.get(i).size(); j++)&#123; int curr = triangle.get(i).get(j); // memo is init as 0s memo[j] = Math.min(memo[j],memo[j+1]) + curr; &#125; &#125; return memo[0];&#125; #127-word-ladder-mediumGiven two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: 123456789Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output: 5Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5. Example 2: 12345678Input:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: 0Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation. 1234567891011121314151617181920212223242526272829303132333435public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; // bfs Set&lt;String&gt; dict = new HashSet&lt;&gt;(); for(String word : wordList) dict.add(word); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginWord); int len = 1; // return depth of level to reach endword while(!queue.isEmpty())&#123; int size = queue.size(); len ++; // remember use level, otherwise wrong for(int level=0; level&lt;size; ++level)&#123; char[] curr = queue.poll().toCharArray(); for(int i=0; i&lt;curr.length; ++i)&#123; // replace curr[i] with a to z char prev = curr[i]; for(char c='a'; c&lt;='z'; ++c)&#123; if(c != prev)&#123; curr[i] = c; String newWord = String.valueOf(curr); if(dict.contains(newWord))&#123; if(newWord.equals(endWord)) return len; queue.offer(newWord); dict.remove(newWord); &#125; &#125; &#125; curr[i] = prev; &#125; &#125; &#125; return 0;&#125; #128-longest-consecutive-sequence-hardGiven an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: 123Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 1234567891011121314151617181920public int longestConsecutive(int[] nums) &#123; // union find using set // find the head (head - 1 not exist) if(nums == null || nums.length == 0) return 0; int result = 0; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num : nums) set.add(num); for(int num : nums)&#123; // find a head if(!set.contains(num - 1))&#123; int len = 1; while(set.contains(++num)) len ++; result = Math.max(result,len); &#125; &#125; return result;&#125; #130-surrounded-regionsGiven a 2D board containing &#39;X&#39; and &#39;O&#39; (the letter O), capture all regions surrounded by &#39;X&#39;. A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region. For example, 1234X X X XX O O XX X O XX O X X After running your function, the board should be: 1234X X X XX X X XX X X XX O X X Notice overflow case: 12345678910OOOOOOOOOOXXXXXXXXXOOOOOOOOOOOOXXXXXXXXXOOOOOOOOOOXXXXXXXXXOOOOOOOOOOOOXXXXXXXXXOOOOOOOOOOXXXXXXXXXO 12345678910OOOOOOOOOOOXXXXXXXXXXXOXXOOOOOOOOOOXXOXXXXXXXXXXXOOOOOOOOOOXXXXXXXXXXXOXXOOOOOOOOOOXXOXXXXXXXXXXXOOOOOOOOOOXXXXXXXXXXXOX 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void solve(char[][] board) &#123; // if surrounded, must at edge // check edge set 0 to 1 if(board==null||board.length==0||board[0].length==0) return; int m = board.length, n = board[0].length; // set first last row for(int j=0; j&lt;n; j++)&#123; check(board,m,n,0,j); if(m &gt; 1) check(board,m,n,m-1,j); &#125; // set left right col for(int i=1; i&lt;m; i++)&#123; check(board,m,n,i,0); if(n &gt; 1) check(board,m,n,i,n-1); &#125; // set 1 to 0, 0 to X for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(board[i][j] == '1') board[i][j] = 'O'; else if(board[i][j] == 'O') board[i][j] = 'X'; &#125; &#125;&#125;private void check(char[][] board,int m,int n,int i,int j)&#123; // use trick avoid TLE, skip first row and left col // skip only one not both for best performance if(board[i][j] == 'O')&#123; board[i][j] = '1'; // use i&gt;1 instead of i&gt;=1 if(i &gt; 1) check(board,m,n,i-1,j); if(i &lt; m-1) check(board,m,n,i+1,j); // use j&gt;1 instead of j&gt;=1 if(j &gt; 1) check(board,m,n,i,j-1); if(j &lt; n-1) check(board,m,n,i,j+1); &#125;&#125; #133-clone-graph-mediumClone an undirected graph. Each node in the graph contains a label and a list of its neighbors. 123456789101112131415161718192021222324/** * Definition for undirected graph. * class UndirectedGraphNode &#123; * int label; * List&lt;UndirectedGraphNode&gt; neighbors; * UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125; * &#125;; */ public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; Map&lt;Integer,UndirectedGraphNode&gt; visited = new HashMap&lt;&gt;(); return clone(node,visited); &#125; private UndirectedGraphNode clone(UndirectedGraphNode node, Map&lt;Integer,UndirectedGraphNode&gt; visited)&#123; if(node == null) return null; if(visited.containsKey(node.label)) return visited.get(node.label); UndirectedGraphNode newNode = new UndirectedGraphNode(node.label); visited.put(node.label,newNode); for(UndirectedGraphNode n : node.neighbors)&#123; newNode.neighbors.add(clone(n,visited)); &#125; return newNode; &#125; #136-single-number-easyGiven a non-empty array of integers, every element appears twice except for one. Find that single one. 123456public int singleNumber(int[] nums) &#123; int result = 0; for(int num : nums) result ^= num; return result;&#125; #141-linked-list-cycle-easyGiven a linked list, determine if it has a cycle in it. 123456789101112public boolean hasCycle(ListNode head) &#123; if(head == null) return false; ListNode slow = head, fast = head; do&#123; if(fast==null || fast.next==null) return false; slow = slow.next; fast = fast.next.next; &#125;while(slow != fast); return true;&#125; 123456789101112public boolean hasCycle(ListNode head) &#123; if(head==null) return false; ListNode slow = head, fast = head; while(fast !=null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if(slow == fast) return true;; &#125; return false;&#125; #142-linked-list-cycle-ii-mediumGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. 12345678910111213141516public ListNode detectCycle(ListNode head) &#123; if(head==null || head.next==null) return null; ListNode slow = head, fast = head; do&#123; if(fast==null || fast.next==null) return null; slow = slow.next; fast = fast.next.next; &#125;while(slow != fast); while(head != fast)&#123; head = head.next; fast = fast.next; &#125; return head;&#125; #146-lru-cache-hardDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class LRUCache &#123; // implement double linked list // most recent at head // least recent at tail DListNode head = null; DListNode tail = null; int capacity = 0; Map&lt;Integer,DListNode&gt; map; // save key, node public LRUCache(int capacity) &#123; this.capacity = capacity; map = new HashMap&lt;&gt;(); // init head tail head = new DListNode(); tail = new DListNode(); head.next = tail; tail.prev = head; &#125; public int get(int key) &#123; if(!map.containsKey(key)) return -1; DListNode node = map.get(key); moveToHead(node); // most recent return node.val; &#125; public void put(int key, int value) &#123; // notice when same key, diff val if(map.containsKey(key))&#123; DListNode node = map.get(key); node.setVal(value); moveToHead(node); // active return; &#125; DListNode node = new DListNode(key,value); if(capacity == 0)&#123; int removeKey = removeLast(); // remove least from list and map map.remove(removeKey); capacity ++; &#125; addFirst(node); map.put(key,node); capacity --; &#125; // add most recent to head private void addFirst(DListNode node)&#123; node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; &#125; // remove a node private void remove(DListNode node)&#123; node.prev.next = node.next; node.next.prev = node.prev; node.prev = null; node.next = null; &#125; // remove least recent node, return key private int removeLast()&#123; DListNode last = tail.prev; remove(tail.prev); return last.key; &#125; // set to head private void moveToHead(DListNode node)&#123; remove(node); addFirst(node); &#125; private class DListNode&#123; int key; int val; DListNode prev; DListNode next; public DListNode()&#123;&#125; public DListNode(int key,int val)&#123; this.key = key; this.val = val; &#125; // use when put with same key public void setVal(int val)&#123; this.val = val; &#125; &#125;&#125; #149-max-points-on-a-line-hardGiven n points on a 2D plane, find the maximum number of points that lie on the same straight line. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a point. * class Point &#123; * int x; * int y; * Point() &#123; x = 0; y = 0; &#125; * Point(int a, int b) &#123; x = a; y = b; &#125; * &#125; */class Solution &#123; public int maxPoints(Point[] points) &#123; // use O(n^2) to find all pair, store slope as key if(points == null) return 0; int result = 0; // map: slope as key, count as val Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); // loop over all points for(int i=0; i&lt;points.length; ++i)&#123; // check all lines with i and j // find max point on a line except i and overlap int max = 0, overlap = 0; map.clear(); for(int j=i+1; j&lt;points.length; ++j)&#123; // x,y pair as slope int x = points[j].x - points[i].x; int y = points[j].y - points[i].y; if(x == 0 &amp;&amp; y == 0)&#123; // points overlap overlap ++; continue; &#125; int gcd = getGCD(x,y); // vertical and horizontal covered x /= gcd; y /= gcd; String key = x + \",\" + y; if(map.containsKey(key)) map.put(key,map.get(key)+1); else map.put(key,1); // max for one start point max = Math.max(max,map.get(key)); &#125; // start point + other point on line + same as start result = Math.max(result,max+overlap+1); &#125; return result; &#125; private int getGCD(int a,int b)&#123; return a == 0 ? b : getGCD(b%a,a); &#125;&#125; #151-reverse-words-in-a-string-medium1234567891011121314151617181920212223242526272829303132333435363738394041public String reverseWords(String s) &#123; if(s == null || s.length() == 0) return \"\"; char[] input = s.toCharArray(); int l = 0, r = 0; while(r &lt; input.length)&#123; // find head l = r; while(l&lt;input.length &amp;&amp; input[l]==' ') l++; // find tail r = l; while(r&lt;input.length &amp;&amp; input[r]!=' ') r++; // reverse reverse(input,l,r-1); &#125; // reverse whole reverse(input,0,input.length-1); return reduce(input); &#125;private String reduce(char[] c)&#123; int head = 0; for(int tail=0; tail&lt;c.length; tail++)&#123; if(c[tail]==' ' &amp;&amp; (head==0 || c[tail-1]==' ')) continue; c[head++] = c[tail]; &#125; // case last \" \" if(head &gt; 0 &amp;&amp; c[head-1] == ' ') return new String(c,0,head-1); return new String(c,0,head);&#125;private void reverse(char[] c,int i,int j)&#123; while(i &lt; j)&#123; char temp = c[i]; c[i] = c[j]; c[j] = temp; i++; j--; &#125;&#125; #156-binary-tree-upside-down-mediumGiven a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root. For example:Given a binary tree {1,2,3,4,5}, 12345 1 / \\ 2 3 / \\4 5 return the root of the binary tree [4,5,2,#,#,3,1]. 1234567891011 4 / \\ 5 2 / \\ 3 1 1 / 2 -- 3 / 4 -- 5 1234567891011121314151617181920public TreeNode upsideDownBinaryTree(TreeNode root) &#123; // 1 // / \\ // 2 - 3 // / \\ // 4 - 5 TreeNode curr = root; TreeNode next = null, prev = null, right = null; while(curr != null)&#123; next = curr.left; // save left curr.left = right; right = curr.right; curr.right = prev; prev = curr; curr = next; &#125; return prev;&#125; #159-longest-substring-with-at-most-2-distince-characters-hardGiven a string s , find the length of the longest substring t that contains at most 2 distinct characters. Example 1: 123Input: &quot;eceba&quot;Output: 3Explanation: t is &quot;ece&quot; which its length is 3. Example 2: 123Input: &quot;ccaabbb&quot;Output: 5Explanation: t is &quot;aabbb&quot; which its length is 5. 123456789101112131415161718192021public int lengthOfLongestSubstringTwoDistinct(String s) &#123; // sliding window if(s == null || s.length() == 0) return 0; int[] bin = new int[256]; int head = 0, maxLen = 0, count = 0; for(int tail=0; tail&lt;s.length(); tail++)&#123; if(bin[s.charAt(tail)] == 0) // new char count ++; bin[s.charAt(tail)] ++; while(count &gt; 2)&#123; // make it most 2 if(bin[s.charAt(head)] == 1) // remove a distinct char count --; bin[s.charAt(head)] --; head++; &#125; maxLen = Math.max(maxLen,tail-head+1); &#125; return maxLen;&#125; #160-intersection-of-two-linked-list-easyWrite a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 O(n) &amp; O(1) 1234567891011public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; ListNode pointer1 = headA; ListNode pointer2 = headB; // 2 iterations to overcome the difference while(pointer1 != pointer2)&#123; pointer1 = pointer1==null? headB:pointer1.next; pointer2 = pointer2==null? headA:pointer2.next; &#125; return pointer1;&#125; #163-missing-ranges-mediumGiven a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges. For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return [&quot;2&quot;, &quot;4-&gt;49&quot;, &quot;51-&gt;74&quot;, &quot;76-&gt;99&quot;]. Corner cases: Integer.min, Integer.max #228-summary-ranges-medium 1234567891011121314151617181920212223242526272829public List&lt;String&gt; findMissingRanges(int[] nums, int lower, int upper) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(nums==null) return result; int head = lower; for(int i=0; i&lt;nums.length; i++)&#123; // deal with corner case // [-2147483648,-2147483648,0,2147483647,2147483647] // -2147483648 // 2147483647 if(nums[i] == Integer.MIN_VALUE)&#123; // tail cannot be nums[i] - 1 head = nums[i] + 1; continue; &#125; int tail = nums[i] - 1; if(tail &gt;= head) result.add(head + (tail&gt;head? \"-&gt;\"+tail : \"\")); // deal with corner case, return here if(nums[i] == Integer.MAX_VALUE) return result; head = nums[i] + 1; &#125; // deal with last num if(head &lt;= upper) result.add(head + (upper&gt;head? \"-&gt;\"+upper : \"\")); return result;&#125; #165-compare-version-numbers-mediumCompare two version numbers version1 and version2.If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character.The . character does not represent a decimal point and is used to separate number sequences.For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. Here is an example of version numbers ordering: 120.1 &lt; 1.1 &lt; 1.2 &lt; 13.37 01 = 1, 1.0 = 1 12345678910111213141516public int compareVersion(String version1, String version2) &#123; // . match a char String[] v1 = version1.split(\"\\\\.\"); String[] v2 = version2.split(\"\\\\.\"); for(int i=0,j=0;i&lt;v1.length||j&lt;v2.length;)&#123; int num1 = i &gt;= v1.length ? 0 : Integer.parseInt(v1[i++]); int num2 = j &gt;= v2.length ? 0 : Integer.parseInt(v2[j++]); if(num1 == num2) continue; else if(num1 &lt; num2) return -1; else return 1; &#125; return 0;&#125; #169-majority-element-easyGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Can use sorting as well #229-majority-element-ii-medium 12345678910public int majorityElement(int[] nums) &#123; // Boyer-Moore Voting Algorithm int result = 0, count = 0; for(int num : nums)&#123; if(count == 0) result = num; count += num == result ? 1 : -1; &#125; return result;&#125; 200. Number of Islands (medium)Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. *Example 1:* Answer: 1 123411110110101100000000 *Example 2:* Answer: 3 123411000110000010000011 dfs approach time O(mn), space O(mn) worst 1234567891011121314151617181920212223242526272829public int numIslands(char[][] grid) &#123; if(grid==null || grid.length==0 || grid[0].length==0) return 0; // dfs approach, connected component idea int m = grid.length, n = grid[0].length; int count = 0; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; // if 1, count ++, traverse neighbor if(grid[i][j] == '1')&#123; count ++; dfs(grid,i,j); &#125; &#125; &#125; return count;&#125;private void dfs(char[][] grid,int i,int j)&#123; int m = grid.length, n = grid[0].length; // if out of bound, or not island if(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || grid[i][j]=='0') return; grid[i][j] = '0'; // set visited // visit up down left right dfs(grid,i-1,j); dfs(grid,i+1,j); dfs(grid,i,j-1); dfs(grid,i,j+1);&#125; BFS approach, time O(mn), space O(min(m,n)) 12345678910111213141516171819202122232425262728293031323334353637383940public int numIslands(char[][] grid) &#123; // bfs approach if(grid==null || grid.length==0 || grid[0].length==0) return 0; int count = 0; int m = grid.length, n = grid[0].length; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; // only care about 1 if(grid[i][j] == '1')&#123; count ++; grid[i][j] = '0'; int[] curr = &#123;i,j&#125;; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(curr); while(!queue.isEmpty())&#123; curr = queue.poll(); int row = curr[0], col = curr[1]; if(row-1&gt;=0 &amp;&amp; grid[row-1][col] == '1')&#123; queue.offer(new int[]&#123;row-1,col&#125;); grid[row-1][col] = '0'; &#125; if(row+1&lt;m &amp;&amp; grid[row+1][col] == '1')&#123; queue.offer(new int[]&#123;row+1,col&#125;); grid[row+1][col] = '0'; &#125; if(col-1&gt;=0 &amp;&amp; grid[row][col-1] == '1')&#123; queue.offer(new int[]&#123;row,col-1&#125;); grid[row][col-1] = '0'; &#125; if(col+1&lt;n &amp;&amp; grid[row][col+1] == '1')&#123; queue.offer(new int[]&#123;row,col+1&#125;); grid[row][col+1] = '0'; &#125; &#125; &#125; &#125; &#125; return count;&#125; #201-bitwise-and-of-numbers-range-mediumGiven a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. For example, given the range [5, 7], you should return 4. 123456789101112131415public int rangeBitwiseAnd(int m, int n) &#123; // right shift, all tail digits are 0 // until m == n, this is the head // append 0 tail to head if(m == 0) // 0 &amp; x == 0 return 0; int tailLen = 0; while(m != n)&#123; m &gt;&gt;= 1; n &gt;&gt;= 1; tailLen ++; &#125; return m &lt;&lt; tailLen;&#125; #204-count-primes-easyDescription: Count the number of prime numbers less than a non-negative number, n. 1234567891011121314151617public int countPrimes(int n) &#123; if(n &lt; 1) return 0; // indicate whether prime boolean[] prime = new boolean[n]; Arrays.fill(prime,true); int count = 0; for(int i=2; i&lt;n; i++)&#123; if(prime[i])&#123; count ++; for(int j=2; i*j&lt;n; j++)&#123; prime[i * j] = false; &#125; &#125; &#125; return count;&#125; #207-course-schedule-mediumThere are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: 1234Input: 2, [[1,0]] Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. 1234567891011121314151617181920212223242526272829303132333435public boolean canFinish(int numCourses, int[][] prerequisites) &#123; // detect cycle // use adjacency list, assume input valid List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); for(int i=0; i&lt;numCourses; i++) graph.add(new ArrayList&lt;&gt;()); for(int[] prerequisite : prerequisites)&#123; graph.get(prerequisite[0]).add(prerequisite[1]); &#125; // track visited node Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); // track along a path for one start Set&lt;Integer&gt; path = new HashSet&lt;&gt;(); for(int i=0; i&lt;numCourses; i++)&#123; if(hasCycle(graph,visited,path,i)) return false; &#125; return true;&#125;private boolean hasCycle(List&lt;List&lt;Integer&gt;&gt; graph,Set&lt;Integer&gt; visited,Set&lt;Integer&gt; path,int node)&#123; // visited in path, cycle if(path.contains(node)) return true; // no need to visit if(visited.contains(node)) return false; visited.add(node); // set visited path.add(node); // add to path for(int child : graph.get(node))&#123; if(hasCycle(graph,visited,path,child)) return true; &#125; path.remove(node); // path finish, remove return false;&#125; #210-course-schedule-ii-mediumtopological sort a directed graph dfs with check cycle: 12345678910111213141516171819202122232425262728293031323334353637383940public int[] findOrder(int numCourses, int[][] prerequisites) &#123; // dfs topological, stack result // no outcome node bottom, no income top List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); // graph save cout come edge for(int i=0; i&lt;numCourses; i++) graph.add(new ArrayList&lt;&gt;()); for(int[] p : prerequisites) graph.get(p[1]).add(p[0]); // check path, and visited (in result) // use stack to save visited node boolean[] path = new boolean[numCourses]; boolean[] visited = new boolean[numCourses]; Stack&lt;Integer&gt; order = new Stack&lt;&gt;(); // start dfs for(int i=0; i&lt;numCourses; i++)&#123; if(hasCycle(graph,order,visited,path,i)) return new int[0]; &#125; int[] result = new int[numCourses]; int idx = 0; while(!order.isEmpty()) result[idx++] = order.pop(); return result;&#125;private boolean hasCycle(List&lt;List&lt;Integer&gt;&gt; graph,Stack&lt;Integer&gt; order,boolean[] visited,boolean[] path,int curr)&#123; if(visited[curr]) return false; if(path[curr]) return true; path[curr] = true; for(int child : graph.get(curr))&#123; if(hasCycle(graph,order,visited,path,child)) return true; &#125; path[curr] = false; visited[curr] = true; order.push(curr); return false;&#125; BFS: ADJ list save outcome, then count income 1234567891011121314151617181920212223242526272829303132333435public int[] findOrder(int numCourses, int[][] prerequisites) &#123; // topological output: no income node firse, this case no pre // check degree 0 node (no prerequisites), add to queue, // adj list save out edge [0,1] =&gt; 1 -&gt; 0, when save 1 : 0 List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); // graph saved is node and outcome // but countPre save income number int[] countPre = new int[numCourses]; for(int i=0; i&lt;numCourses; i++) graph.add(new LinkedList&lt;&gt;()); for(int[] p : prerequisites)&#123; graph.get(p[1]).add(p[0]); // save outcome countPre[p[0]]++; // count income (pre) &#125; // init queue, find course with no pre int[] order = new int[numCourses]; int idx = 0; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i=0; i&lt;countPre.length; i++)&#123; if(countPre[i] == 0) queue.offer(i); &#125; // start bfs while(!queue.isEmpty())&#123; int curr = queue.poll(); order[idx++] = curr; // no income(pre) for(int child : graph.get(curr))&#123; // for all outcome node, income -- countPre[child]--; if(countPre[child] == 0) queue.offer(child); &#125; &#125; return idx == numCourses ? order : new int[0];&#125; #211-add-and-search-word-mediumDesign a data structure that supports the following two operations: 12void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example: 1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true Note:You may assume that all words are consist of lowercase letters a-z. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class WordDictionary &#123; class TrieNode&#123; TrieNode[] children; boolean isEnd; TrieNode()&#123; children = new TrieNode[26]; isEnd = false; &#125; &#125; private TrieNode root; /** Initialize your data structure here. */ public WordDictionary() &#123; root = new TrieNode(); &#125; /** Adds a word into the data structure. */ public void addWord(String word) &#123; if(word == null || word.length() == 0) return; TrieNode curr = root; for(char c : word.toCharArray())&#123; TrieNode child = curr.children[c - 'a']; if(child == null)&#123; child = new TrieNode(); curr.children[c - 'a'] = child; &#125; curr = child; &#125; curr.isEnd = true; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word) &#123; if(word == null || word.length() == 0) return false; return search(root,word,0); &#125; public boolean search(TrieNode curr,String word,int idx)&#123; if(idx == word.length()) return curr.isEnd; char c = word.charAt(idx); if(c != '.')&#123; TrieNode child = curr.children[c - 'a']; if(child == null) return false; return search(child,word,idx+1); &#125;else&#123; for(int i=0; i&lt;26; i++)&#123; TrieNode child = curr.children[i]; if(child!=null &amp;&amp; search(child,word,idx+1)) return true; &#125; return false; &#125; &#125;&#125; #217-contains-duplicate-easyGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Use HashSet: time O(n), space O(n) Use Sort: time O(nlgn), space O(1) #219-contains-duplicate-ii-easyGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. 123456789public boolean containsNearbyDuplicate(int[] nums, int k) &#123; if(k&lt;=0) return false; Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(i-k&gt;0) visited.remove(nums[i-k-1]); if(!visited.add(nums[i])) return true; &#125; return false;&#125; #220-contains-duplicate-iii-mediumGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. Use TreeSet 1234567891011121314151617181920212223242526public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; // abs(nums[i] - nums[j]) &lt;= t // abs(i - j) &lt;= k // O(n log k) if(nums==null || nums.length==0 || t&lt;0 || k&lt;0) return false; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for(int i=0; i&lt;nums.length; i++)&#123; // maintance a window if(i - k &gt; 0) set.remove(nums[i - k - 1]); // floor: greatest less or equal to // ceiling: smallest greater or equal to // NOTICE: overflow Integer left = set.ceiling(Integer.MIN_VALUE + t &lt; nums[i] ? nums[i] - t : Integer.MIN_VALUE); Integer right = set.floor(Integer.MAX_VALUE - t &gt; nums[i] ? nums[i] + t : Integer.MAX_VALUE); if(left != null &amp;&amp; left &lt;= nums[i] || right != null &amp;&amp; right &gt;= nums[i]) return true; // add set set.add(nums[i]); &#125; return false;&#125; #223-rectangle-area-mediumFind the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. Assume that the total area is never beyond the maximum possible value of int. 12345678910111213141516171819202122232425262728293031public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; // FIND INTERSECTION // x axis: A---C E---F int X = 0; if(C-A&gt;G-E &amp;&amp; E&gt;=A &amp;&amp; G&lt;=C) X = G - E; else if(C-A&lt;=G-E &amp;&amp; A&gt;=E &amp;&amp; C&lt;=G) X = C - A; // after above 2, low priority else if(G&gt;A &amp;&amp; E&lt;A) X = G - A; else if(E&lt;C &amp;&amp; G&gt;C) X = C - E; // y axis: B---D F---H int Y = 0; // check include relation first if(D-B&gt;H-F &amp;&amp; F&gt;=B &amp;&amp; H&lt;=D) Y = H - F; else if(D-B&lt;=H-F &amp;&amp; B&gt;=F &amp;&amp; D&lt;=H) Y = D - B; else if(H&gt;B &amp;&amp; F&lt;B) Y = H - B; else if(F&lt;D &amp;&amp; H&gt;D) Y = D - F; // compute int area1 = (C-A) * (D-B); int area2 = (G-E) * (H-F); int area3 = X * Y; return area1 + area2 - area3;&#125; #227-basic-calculator-ii-mediumImplement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero. Example 1: 12Input: &quot;3+2*2&quot;Output: 7 Example 2: 12Input: &quot; 3/2 &quot;Output: 1 Example 3: 12Input: &quot; 3+5 / 2 &quot;Output: 5 1234567891011121314151617181920212223242526public int calculate(String s) &#123; if(s == null || s.length() == 0) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); char sign = '+'; // for first number; int num = 0; for(int i=0; i&lt;s.length(); ++i)&#123; if(Character.isDigit(s.charAt(i))) num = num * 10 + s.charAt(i) - '0'; // when to add prev val // cannot use else if if(!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != ' ' || i == s.length()-1)&#123; switch(sign)&#123; case '+': stack.push(num); break; case '-': stack.push(-num); break; case '*': stack.push(stack.pop()*num); break; case '/': stack.push(stack.pop()/num); break; &#125; sign = s.charAt(i); num = 0; &#125; &#125; while(!stack.isEmpty()) num += stack.pop(); return num;&#125; #228-summary-ranges-mediumGiven a sorted integer array without duplicates, return the summary of its ranges. Example 1: 12Input: [0,1,2,4,5,7]Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;] Example 2: 12Input: [0,2,3,4,6,8,9]Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;] 1234567891011121314151617181920212223public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(nums==null || nums.length==0) return result; Integer head = null; StringBuilder sb = new StringBuilder(); for(int i=0; i&lt;nums.length; i++)&#123; if(head == null) head = nums[i]; if(i&lt;nums.length-1 &amp;&amp; nums[i]+1==nums[i+1]) continue; else&#123; // last one or new range sb.append(head); // notice one num if(head != nums[i]) sb.append(\"-&gt;\"+nums[i]); result.add(sb.toString()); sb.setLength(0); head = null; &#125; &#125; return result;&#125; 12345678910111213141516public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(nums==null || nums.length==0) return result; for(int head=0; head&lt;nums.length; head++)&#123; int tail = head; while(tail&lt;nums.length-1 &amp;&amp; nums[tail]+1==nums[tail+1]) tail ++; if(head != tail) result.add(nums[head] + \"-&gt;\" + nums[tail]); else result.add(nums[head] + \"\"); head = tail; &#125; return result;&#125; #229-majority-element-ii-mediumGiven an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space. Check existence first!! 1234567891011121314151617181920212223242526272829303132333435363738public List&lt;Integer&gt; majorityElement(int[] nums) &#123; // majority vote List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(nums == null || nums.length == 0) return result; int major1 = 0, major2 = 0, cnt1 = 0, cnt2 = 0; for(int num : nums)&#123; // order matters if(major1 == num) cnt1 ++; else if(major2 == num) cnt2 ++; else if(cnt1 == 0)&#123; major1 = num; cnt1 ++; &#125;else if(cnt2 == 0)&#123; major2 = num; cnt2 ++; &#125;else&#123; cnt1 --; cnt2 --; &#125; &#125; // 2nd pass, cnt accurance cnt1 = cnt2 = 0; for(int num : nums)&#123; if(major1 == num) cnt1 ++; else if(major2 == num) cnt2 ++; &#125; // add to result if(cnt1 &gt; nums.length / 3) result.add(major1); if(cnt2 &gt; nums.length / 3) result.add(major2); return result;&#125; #235-lca-of-a-bst-easyGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. 123456789 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null) return null; if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right,p,q); if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left,p,q); return root;&#125; #236-lca-of-a-binay-tree-mediumGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” 1234567891011public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null) return right; if(right == null) return left; return root; &#125; #239-sliding-window-maxmum-hardGiven an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 123456789101112131415161718192021222324// use deque maintains max at headpublic int[] maxSlidingWindow(int[] nums, int k) &#123; if(nums==null || nums.length==0) return new int[0]; int[] result = new int[nums.length - k + 1]; Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); for(int i=0;i&lt;k-1;i++) inQueue(deque,nums[i]); for(int i=k-1;i&lt;nums.length;i++)&#123; inQueue(deque,nums[i]); result[i-k+1] = deque.peekFirst(); outQueue(deque,nums[i-k+1]); &#125; return result;&#125;private void inQueue(Deque&lt;Integer&gt; deque,int num)&#123; while(!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;num) deque.pollLast(); deque.offerLast(num);&#125;private void outQueue(Deque&lt;Integer&gt; deque,int num)&#123; if(deque.peekFirst() == num) deque.pollFirst();&#125; #241-different-ways-to-add-parentheses-mediumGiven a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1 Input: &quot;2-1-1&quot;. 12((2-1)-1) = 0(2-(1-1)) = 2 Output: [0, 2] Example 2 Input: &quot;2*3-4*5&quot; 12345(2*(3-(4*5))) = -34((2*3)-(4*5)) = -14((2*(3-4))*5) = -10(2*((3-4)*5)) = -10(((2*3)-4)*5) = 10 Output: [-34, -14, -10, -10, 10] 12345678910111213141516171819202122232425262728293031323334353637public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; // use recursion List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int i=0;i&lt;input.length();i++)&#123; char c = input.charAt(i); // divide input to two part if(c=='+' || c=='-' || c=='*')&#123; String left = input.substring(0,i); String right = input.substring(i+1); List&lt;Integer&gt; list1 = diffWaysToCompute(left); List&lt;Integer&gt; list2 = diffWaysToCompute(right); // combine to subset for(int num1 : list1)&#123; for(int num2 : list2)&#123; int temp = 0; switch(c)&#123; case '+': temp = num1 + num2; break; case '-': temp = num1 - num2; break; case '*': temp = num1 * num2; break; &#125; // one possible result result.add(temp); &#125; &#125; &#125; &#125; // case theres no operator in input if(result.size() == 0) result.add(Integer.parseInt(input)); return result;&#125; add memory and optimization 1234567891011121314151617181920212223242526272829303132333435363738394041424344public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); return dfs(input,map,0,input.length());&#125;private List&lt;Integer&gt; dfs(String input,Map&lt;String,List&lt;Integer&gt;&gt; map,int start,int end)&#123; // use recursion // if this expression is saved String expression = input.substring(start,end); if(map.containsKey(expression)) return map.get(expression); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int i=start;i&lt;end;i++)&#123; char c = input.charAt(i); // divide input to two part if(c=='+' || c=='-' || c=='*')&#123; List&lt;Integer&gt; list1 = dfs(input,map,start,i); List&lt;Integer&gt; list2 = dfs(input,map,i+1,end); // combine to subset for(int num1 : list1)&#123; for(int num2 : list2)&#123; int temp = 0; switch(c)&#123; case '+': temp = num1 + num2; break; case '-': temp = num1 - num2; break; case '*': temp = num1 * num2; break; &#125; // one possible result result.add(temp); &#125; &#125; &#125; &#125; // case theres no operator in input if(result.size() == 0) result.add(Integer.parseInt(expression)); map.put(expression,result); return result; &#125; #243-shortest-word-distance-easyGiven a list of words and two words word1 and word2, return the shortest distance between these two words in the list. For example,Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]. Given word1 = “coding”, word2 = “practice”, return 3.Given word1 = &quot;makes&quot;, word2 = &quot;coding&quot;, return 1. Note:You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. 123456789101112131415public int shortestDistance(String[] words, String word1, String word2) &#123; if(words==null || words.length==0) return 0; int idx1 = -1, idx2 = -1, min = words.length; for(int i=0;i&lt;words.length;i++)&#123; if(words[i].equals(word1)) idx1 = i; else if(words[i].equals(word2)) idx2 = i; // need to check whether idx are set if(idx1!=-1 &amp;&amp; idx2!=-1) min = Math.min(min,Math.abs(idx1-idx2)); &#125; return min;&#125; #244-shortest-word-distance-ii-mediumThis is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it? Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list. For example,Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]. Given word1 = “coding”, word2 = “practice”, return 3.Given word1 = &quot;makes&quot;, word2 = &quot;coding&quot;, return 1. Note:You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. 123456789101112131415161718192021222324252627class WordDistance &#123; Map&lt;String,List&lt;Integer&gt;&gt; map; public WordDistance(String[] words) &#123; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;words.length;i++)&#123; if(!map.containsKey(words[i])) map.put(words[i],new ArrayList&lt;&gt;()); map.get(words[i]).add(i); &#125; &#125; public int shortest(String word1, String word2) &#123; List&lt;Integer&gt; l1 = map.get(word1); List&lt;Integer&gt; l2 = map.get(word2); int min = Integer.MAX_VALUE; int idx1 = 0, idx2 = 0; // utilize two pointer to optimize while(idx1&lt;l1.size() &amp;&amp; idx2&lt;l2.size())&#123; min = Math.min(min,Math.abs(l1.get(idx1)-l2.get(idx2))); if(l1.get(idx1) &lt; l2.get(idx2)) idx1++; else idx2++; &#125; return min; &#125;&#125; #245-shortest-word-distance-iii-mediumThis is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2. Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. word1 and word2 may be the same and they represent two individual words in the list. For example,Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]. Given word1 = “makes”, word2 = “coding”, return 1.Given word1 = &quot;makes&quot;, word2 = &quot;makes&quot;, return 3. Note:You may assume word1 and word2 are both in the list. 1234567891011121314151617181920public int shortestWordDistance(String[] words, String word1, String word2) &#123; if(words==null || words.length==0) return 0; int min = words.length; int idx1 = -1, idx2 = -1; for(int i=0; i&lt;words.length; i++)&#123; if(words[i].equals(word1)) idx1 = i; if(words[i].equals(word2))&#123; if(word1.equals(word2)) // set idx1 to prev idx2 idx1 = idx2; idx2 = i; &#125; if(idx1 != -1 &amp;&amp; idx2 != -1)&#123; min = Math.min(min,Math.abs(idx1-idx2)); &#125; &#125; return min;&#125; quicker 12345678910111213141516171819202122232425262728public int shortestWordDistance(String[] words, String word1, String word2) &#123; if(words==null || words.length==0) return 0; int min = words.length; int idx1 = -1, idx2 = -1; if(word1.equals(word2))&#123; for(int i=0;i&lt;words.length;i++)&#123; if(words[i].equals(word1))&#123; if(idx1 == -1) idx1 = i; else&#123; min = Math.min(min,i-idx1); idx1 = i; &#125; &#125; &#125; &#125;else&#123; for(int i=0;i&lt;words.length;i++)&#123; if(words[i].equals(word1)) idx1 = i; else if(words[i].equals(word2)) idx2 = i; if(idx1!=-1 &amp;&amp; idx2!=-1) min = Math.min(min,Math.abs(idx1-idx2)); &#125; &#125; return min;&#125; #248-strobogrammatic-number-iii-hardA strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to count the total strobogrammatic numbers that exist in the range of low &lt;= num &lt;= high. Example: 123Input: low = &quot;50&quot;, high = &quot;100&quot;Output: 3 Explanation: 69, 88, and 96 are three strobogrammatic numbers. Note:Because the range might be a large number, the low and high numbers are represented as string. 12345678910111213141516171819202122232425262728293031323334public int strobogrammaticInRange(String low, String high) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i=low.length(); i&lt;=high.length(); i++)&#123; list.addAll(findStrobogrammatic(i)); &#125; int count = 0; for(String s : list)&#123; if(s.length()==low.length() &amp;&amp; s.compareTo(low)&lt;0 || s.length()==high.length() &amp;&amp; s.compareTo(high)&gt;0) continue; count ++; &#125; return count;&#125;public List&lt;String&gt; findStrobogrammatic(int n) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(n % 2 == 0) result = Arrays.asList(\"\"); else result = Arrays.asList(\"0\",\"1\",\"8\"); for(int i=(n%2)+2; i&lt;=n; i+=2)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(String s : result)&#123; if(i != n) list.add(\"0\" + s + \"0\"); list.add(\"1\" + s + \"1\"); list.add(\"8\" + s + \"8\"); list.add(\"6\" + s + \"9\"); list.add(\"9\" + s + \"6\"); &#125; result = list; &#125; return result;&#125; #253-meeting-rooms-ii-mediumGiven an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si &lt; ei), find the minimum number of conference rooms required. Example 1: 12Input: [[0, 30],[5, 10],[15, 20]]Output: 2 Example 2: 12Input: [[7,10],[2,4]]Output: 1 12345678910111213141516171819202122public int minMeetingRooms(Interval[] intervals) &#123; // seperate array of start and end then sort if(intervals == null || intervals.length == 0) return 0; int[] starts = new int[intervals.length]; int[] ends = new int[intervals.length]; for(int i=0; i&lt;intervals.length; i++)&#123; starts[i] = intervals[i].start; ends[i] = intervals[i].end; &#125; Arrays.sort(starts); Arrays.sort(ends); // if start &lt; end add room, else update end int count = 0, end = 0; for(int i=0; i&lt;starts.length; i++)&#123; if(starts[i] &lt; ends[end]) count ++; else end ++; &#125; return count;&#125; Greedy: 123456789101112131415161718192021222324 public int minMeetingRooms(Interval[] intervals) &#123; // greedy, sort on start first // then use heap on end time to track rooms if(intervals == null || intervals.length == 0) return 0; // sort start time and init end sorted heap Arrays.sort(intervals,(o1,o2)-&gt;o1.start-o2.start); PriorityQueue&lt;Interval&gt; heap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o1.end-o2.end);// start heap.offer(intervals[0]);Interval prev = intervals[0], curr = null;for (int i = 1; i &lt; intervals.length; i++) &#123; // find min end room, cannot use peek prev = heap.poll(); curr = intervals[i]; // can put in this min end room, update end time if(curr.start &gt;= prev.end) prev.end = curr.end; else // sign a new room heap.offer(curr); heap.offer(prev);&#125;return heap.size(); &#125; count max schedules 123456789101112131415public int maxSchedules(Interval[] intervals) &#123; if(intervals == null || intervals.length == 0) return 0; // sort on end time Arrays.sort(intervals, (o1,o2)-&gt;o1.end-o2.end); int count = 0; Interval prev = null; for(int i=0; i&lt;intervals.length; i++) &#123; if(prev == null || intervals[i].start&gt;=prev.end) &#123; count ++; prev = intervals[i]; &#125; &#125; return count;&#125; #263-ugly-number-easyWrite a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note: 1 is typically treated as an ugly number. Input is within the 32-bit signed integer range. 12345678910public boolean isUgly(int num) &#123; if(num == 0) return false; if(num == 1) return true; while(num % 2 == 0) num /= 2; while(num % 3 == 0) num /= 3; while(num % 5 == 0) num /= 5; return num == 1;&#125; #264-ugly-number-ii-mediumWrite a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly number, and n does not exceed 1690. The idea of this solution is from this page:http://www.geeksforgeeks.org/ugly-numbers/ 123456789101112131415161718public int nthUglyNumber(int n) &#123; // pointer for multi of 2,3,5 int i2 = 0, i3 = 0, i5 = 0; // dp int[] dp = new int[n]; dp[0] = 1; for(int i=1; i&lt;n; i++)&#123; int ugly = Math.min(dp[i5]*5, Math.min(dp[i2]*2, dp[i3]*3)); dp[i] = ugly; // check to increase pointer if(dp[i2]*2 == ugly) i2++; if(dp[i3]*3 == ugly) i3++; if(dp[i5]*5 == ugly) i5++; &#125; return dp[n-1];&#125; #268-missing-number-easyGiven an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: 12Input: [3,0,1]Output: 2 Example 2: 12Input: [9,6,4,2,3,5,7,0,1]Output: 8 1234567891011121314public int missingNumber(int[] nums) &#123; for(int i=0; i&lt;nums.length; i++)&#123; while(nums[i]!=nums.length &amp;&amp; nums[i]!=nums[nums[i]])&#123; int temp = nums[nums[i]]; nums[nums[i]] = nums[i]; nums[i] = temp; &#125; &#125; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i] != i) return i; &#125; return nums.length;&#125; #271-encode-and-decode-strings-mediumDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. 12345678910111213141516171819202122232425262728293031public class Codec &#123; // Encodes a list of strings to a single string. public String encode(List&lt;String&gt; strs) &#123; // count#str StringBuilder sb = new StringBuilder(); for(String str : strs)&#123; // append one by one sb.append(str.length() + \"#\" + str); &#125; return sb.toString(); &#125; // Decodes a single string to a list of strings. public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); int i = 0; while(i &lt; s.length())&#123; int j = i; while(s.charAt(j) != '#') j ++; int len = Integer.parseInt(s.substring(i,j)); result.add(s.substring(j+1,j+1+len)); i = j + 1 + len; &#125; return result; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.decode(codec.encode(strs)); num#len1#len2#12 1234567891011121314151617181920212223242526272829303132333435363738// Encodes a list of strings to a single string.public String encode(List&lt;String&gt; strs) &#123; StringBuilder sb = new StringBuilder(); sb.append(strs.size() + \"#\"); for(String str : strs) sb.append(str.length() + \"#\"); for(String str : strs) sb.append(str); return sb.toString();&#125;// Decodes a single string to a list of strings.public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); int head = 0, tail = 0; // find count while(tail&lt;s.length() &amp;&amp; s.charAt(tail)!='#') tail++; int count = Integer.parseInt(s.substring(head,tail)); int[] len = new int[count]; for(int i=0; i&lt;count; i++)&#123; head = tail + 1; tail = head; while(tail&lt;s.length() &amp;&amp; s.charAt(tail)!='#') tail++; len[i] = Integer.parseInt(s.substring(head,tail)); &#125; head = tail + 1; for(int i=0; i&lt;count; i++)&#123; if(head == s.length()) result.add(\"\"); else&#123; result.add(s.substring(head,head+len[i])); head += len[i]; &#125; &#125; return result;&#125; #272-closest-bst-value-ii-hardGiven a non-empty binary search tree and a target value, find k values in the BST that are closest to the target. Note: Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target. Example: 123456789Input: root = [4,2,5,1,3], target = 3.714286, and k = 2 4 / \\ 2 5 / \\1 3Output: [4,3] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) &#123; // use two stack, one for pre one for suc // 12345, 3,7 // =&gt; pres 1,2,3 // =&gt; succ 5,4 List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(root == null) return result; Stack&lt;Integer&gt; pres = new Stack&lt;&gt;(); Stack&lt;Integer&gt; sucs = new Stack&lt;&gt;(); // notice one of should have equal condition inorderPre(root,target,pres); inorderSuc(root,target,sucs); // then find k while(k-- &gt; 0)&#123; if(pres.isEmpty()) result.add(sucs.pop()); else if(sucs.isEmpty()) result.add(pres.pop()); else if(Math.abs(pres.peek()-target) &lt; Math.abs(sucs.peek()-target)) result.add(pres.pop()); else result.add(sucs.pop()); &#125; return result;&#125;private void inorderPre(TreeNode root, double target, Stack&lt;Integer&gt; pres)&#123; if(root == null) return; inorderPre(root.left, target, pres); // push all smaller pred, choose equal (or sucs equal) if(root.val &gt;= target) return; pres.push(root.val); inorderPre(root.right, target, pres);&#125;private void inorderSuc(TreeNode root, double target, Stack&lt;Integer&gt; sucs)&#123; // reverse inorder if(root == null) return; inorderSuc(root.right, target, sucs); // find all larger suc if(root.val &lt; target) return; sucs.push(root.val); inorderSuc(root.left, target, sucs);&#125; #279-perfect-squares-mediumGiven a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. 1234567891011121314151617public int numSquares(int n) &#123; // use dp check prev sum int[] dp = new int[n+1]; // dp iteration for(int i=1; i&lt;=n; i++)&#123; // for num i, check all squares // curr square + (i-square) int min = Integer.MAX_VALUE; for(int j=1; j*j&lt;=i; j++)&#123; // dp[j*j] is 1 // so population not needed min = Math.min(min, dp[i-j*j] + 1); &#125; dp[i] = min; &#125; return dp[n];&#125; #285-inorder-successor-in-bst-mediumGiven a binary search tree and a node in it, find the in-order successor of that node in the BST. Note: If the given node has no in-order successor in the tree, return null. recursion: 12345678910public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123; if(root == null) return root; // if root &lt;= p, just check right side if(root.val &lt;= p.val) return inorderSuccessor(root.right,p); // if root &gt; p, root is possible result TreeNode result = inorderSuccessor(root.left,p); return result == null? root : result;&#125; iteration: 1234567891011121314public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123; if(root == null) return root; // if root.val &gt; p, it's possible result TreeNode result = null; while(root != null)&#123; if(root.val &gt; p.val)&#123; result = root; root = root.left; &#125;else root = root.right; &#125; return result;&#125; predecessor: 123456789public TreeNode inorderPredecessor(TreeNode root, TreeNode p) &#123; if(root == null) return null; // if root.val &lt; p, possible result if(root.val &gt;= p) return inorderPredecessor(root.left,p); TreeNode result = inorderPredecessor(root.right,p); return result == null ? root : result;&#125; #287-find-duplicate-number-mediumGiven an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: 123Input: [1,3,4,2,2]Output: 2[2,2,2,2] 1234567891011121314public int findDuplicate(int[] nums) &#123; // find entrance of cycle int slow = nums[0], fast = nums[0]; do&#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125;while(slow != fast); int idx1 = nums[0], idx2 = slow; while(idx1 != idx2)&#123; idx1 = nums[idx1]; idx2 = nums[idx2]; &#125; return idx1;&#125; #295-find-median-from-data-stream-hardMedian is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. Example: 12345addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2 1234567891011121314151617181920212223242526class MedianFinder &#123; // use two heap (min &amp; max) PriorityQueue&lt;Long&gt; minHeap, maxHeap; /** initialize your data structure here. */ public MedianFinder() &#123; minHeap = new PriorityQueue&lt;&gt;(); maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); &#125; public void addNum(int num) &#123; // left max heap, right min heap // every time add to left, maxHeap.offer((long)num); minHeap.offer(maxHeap.poll()); // keep max heap larger if(maxHeap.size() &lt; minHeap.size()) maxHeap.offer(minHeap.poll()); &#125; public double findMedian() &#123; if(minHeap.size() == maxHeap.size()) return (double)(minHeap.peek() + maxHeap.peek()) / 2; return (double)maxHeap.peek(); &#125;&#125; #297-encode-and-decode-binary-tree-hardSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. preorder bfs recursion 12345678910111213141516171819202122232425262728293031323334public class Codec &#123; // use preorder dfs // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); buildString(root,sb); return sb.toString(); &#125; private void buildString(TreeNode root,StringBuilder sb)&#123; if(root == null)&#123; sb.append(\"X\").append(\",\"); return; &#125; sb.append(root.val).append(\",\"); buildString(root.left,sb); buildString(root.right,sb); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.addAll(Arrays.asList(data.split(\",\"))); return buildTree(queue); &#125; private TreeNode buildTree(Queue&lt;String&gt; queue)&#123; String val = queue.poll(); if(val==null || val.equals(\"X\")) return null; TreeNode root = new TreeNode(Integer.parseInt(val)); root.left = buildTree(queue); root.right = buildTree(queue); return root; &#125;&#125; bfs iteration 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; if(root == null) return \"\"; StringBuilder sb = new StringBuilder(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); if(node == null)&#123; sb.append(\"X,\"); continue; &#125; sb.append(node.val+\",\"); queue.offer(node.left); queue.offer(node.right); &#125; return sb.toString(); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if(data==null || data.length()==0) return null; String[] values = data.split(\",\"); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); TreeNode root = new TreeNode(Integer.parseInt(values[0])); queue.offer(root); int idx = 1; while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); if(!values[idx].equals(\"X\"))&#123; node.left = new TreeNode(Integer.parseInt(values[idx])); queue.offer(node.left); &#125; idx++; if(!values[idx].equals(\"X\"))&#123; node.right = new TreeNode(Integer.parseInt(values[idx])); queue.offer(node.right); &#125; idx++; &#125; return root; &#125;&#125; #300-longest-increasing-subsequence-mediumGiven an unsorted array of integers, find the length of longest increasing subsequence. Example: 123Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. n^2 dp: 1234567891011121314public int lengthOfLIS(int[] nums) &#123; int[] dp = new int[nums.length]; int result = 0; for(int i=0; i&lt;nums.length; i++)&#123; int maxLen = 0; for(int j=0; j&lt;i; j++)&#123; if(nums[i] &gt; nums[j]) maxLen = Math.max(maxLen,dp[j]); &#125; dp[i] = maxLen + 1; result = Math.max(result,dp[i]); &#125; return result;&#125; binary search dp: 1234567891011121314151617181920public int lengthOfLIS(int[] nums) &#123; int[] dp = new int[nums.length]; // maintain an increasing dp array // use maxLen as tail int maxLen = 0; for(int num : nums)&#123; int left = 0, right = maxLen; while(left &lt; right)&#123; int mid = left + (right - left)/2; if(dp[mid] &lt; num) left = mid + 1; else right = mid; &#125; dp[left] = num; if(left == maxLen) maxLen ++; &#125; return maxLen;&#125; #313-supper-ugly-number-mediumWrite a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4. Note:(1) 1 is a super ugly number for any given primes.(2) The given numbers in primes are in ascending order.(3) 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000.(4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer. 1234567891011121314151617181920212223242526public int nthSuperUglyNumber(int n, int[] primes) &#123; // use idea of ugly number ii // array to save result, first is 1 int[] nums = new int[n]; nums[0] = 1; // array to save index int[] idx = new int[primes.length]; for(int i=1; i&lt;n; i++)&#123; // find min to be curr ugly num int ugly = Integer.MAX_VALUE; for(int j=0; j&lt;idx.length; j++)&#123; // nums[idx for j] * primes[j] int candidate = primes[j] * nums[idx[j]]; ugly = Math.min(ugly,candidate); &#125; // set curr result nums[i] = ugly; // update index for all primes for(int j=0; j&lt;idx.length; j++)&#123; int prev = nums[idx[j]]; if(prev * primes[j] == ugly) idx[j] ++; &#125; &#125; return nums[n-1];&#125; #325-max-size-subarray-sum-equals-k-mediumGiven an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn’t one, return 0 instead. Note:The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range. Example 1: Given nums = [1, -1, 5, -2, 3], k = 3,return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest) Example 2: Given nums = [-2, -1, 2, 1], k = 1,return 2. (because the subarray [-1, 2] sums to 1 and is the longest) 12345678910111213141516public int maxSubArrayLen(int[] nums, int k) &#123; if(nums==null || nums.length==0) return 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int sum = 0, maxLen = 0; for(int i=0; i&lt;nums.length; i++)&#123; sum += nums[i]; if(sum == k) maxLen = i + 1; else if(map.containsKey(sum - k)) maxLen = Math.max(maxLen,i-map.get(sum-k)); if(!map.containsKey(sum)) map.put(sum,i); &#125; return maxLen;&#125; #335-self-crossing-hardYou are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not. Example 1: 1234567Given x = [2, 1, 1, 2],?????? ????????&gt; ?Return true (self crossing) Example 2: 12345678Given x = [1, 2, 3, 4],????????? ????????????????&gt;Return false (not self crossing) Example 3: 123456Given x = [1, 1, 1, 1],?????? ??????&gt;Return true (self crossing) 12345678910111213141516171819202122public boolean isSelfCrossing(int[] x) &#123; // i could cross with i-3, i-4, i-5 if(x==null || x.length&lt;=3) return false; // start from 3 for(int i=3; i&lt;x.length; i++)&#123; // check i &amp; i-3 // 7 4: 7&gt;=5, 6&gt;=4 if(x[i]&gt;=x[i-2] &amp;&amp; x[i-1]&lt;=x[i-3]) return true; // check i &amp; i-4 // 7 3: 7+3&gt;=5, 6==4 if(i&gt;=4 &amp;&amp; x[i]+x[i-4]&gt;=x[i-2] &amp;&amp; x[i-1]==x[i-3]) return true; // check i &amp; i-5 // 7 2: 7+3&gt;=5, 5&gt;=3, 6+2&gt;=4, 6&lt;=4 !(4&gt;=2) if(i&gt;=5 &amp;&amp; x[i]+x[i-4]&gt;=x[i-2] &amp;&amp; x[i-2]&gt;=x[i-4] &amp;&amp; x[i-1]+x[i-5]&gt;=x[i-3] &amp;&amp; x[i-1]&lt;=x[i-3]) return true; &#125; return false;&#125; #350-intersection-of-two-arrays-easyGiven two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. sort O(nlogn) 12345678910111213141516171819public int[] intersect(int[] nums1, int[] nums2) &#123; Arrays.sort(nums1); Arrays.sort(nums2); int idx1 = 0, idx2 = 0; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(idx1 &lt; nums1.length &amp;&amp; idx2 &lt; nums2.length)&#123; if(nums1[idx1] == nums2[idx2])&#123; list.add(nums1[idx1]); idx1++;idx2++; &#125;else if(nums1[idx1] &lt; nums2[idx2]) idx1 ++; else idx2 ++; &#125; int[] result = new int[list.size()]; for(int i=0; i&lt;result.length; i++) result[i] = list.get(i); return result;&#125; map count O(1) 123456789101112131415161718public int[] intersect(int[] nums1, int[] nums2) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); if(nums1.length &gt; nums2.length) return intersect(nums2,nums1); for(int num : nums1) map.put(num,map.getOrDefault(num,0)+1); for(int num : nums2)&#123; if(map.getOrDefault(num,0) != 0)&#123; list.add(num); map.put(num,map.get(num)-1); &#125; &#125; int[] result = new int[list.size()]; for(int i=0; i&lt;result.length; i++) result[i] = list.get(i); return result;&#125; #371-sum-of-two-integers-easyCalculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example:Given a = 1 and b = 2, return 3. Iteration: 12345678910public int getSum(int a, int b) &#123; int sum = a, carry = b; while(carry != 0)&#123; int nextSum = sum ^ carry; int nextCarry = (sum &amp; carry) &lt;&lt; 1; sum = nextSum; carry = nextCarry; &#125; return sum;&#125; Recursion: 1234567public int getSum(int a, int b) &#123; if(b == 0) return a; int sum = a ^ b; int carry = (a &amp; b) &lt;&lt; 1; return getSum(sum,carry);&#125; #373-find-k-pairs-with-smallest-sum-mediumYou are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums. Example 1: 123456Given nums1 = [1,7,11], nums2 = [2,4,6], k = 3Return: [1,2],[1,4],[1,6]The first 3 pairs are returned from the sequence:[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 123456789101112131415161718192021222324public List&lt;int[]&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; List&lt;int[]&gt; result = new ArrayList&lt;&gt;(); if(nums1.length==0 || nums2.length==0) return result; PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;&gt;(k,new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1,int[] o2)&#123; return o1[0] + o1[1] - o2[0] - o2[1]; &#125; &#125;); // populate first array first, curr[2] save index for(int i=0;i&lt;nums1.length &amp;&amp; i&lt;k;i++) heap.offer(new int[]&#123;nums1[i],nums2[0],0&#125;); while(!heap.isEmpty() &amp;&amp; result.size()&lt;k)&#123; int[] curr = heap.poll(); int n1 = curr[0], n2 = curr[1], idx2 = curr[2]; result.add(new int[]&#123;n1,n2&#125;); if(idx2 == nums2.length - 1) continue; heap.offer(new int[]&#123;n1,nums2[idx2+1],idx2+1&#125;); &#125; return result;&#125; #378-k-th-smallest-element-in-a-sorted-matrix-mediumGiven a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: 12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. Could use Dijkstra Use heap init with row 123456789101112131415161718192021public int kthSmallest(int[][] matrix, int k) &#123; // similar to #373 if(matrix==null || matrix.length==0 || matrix[0].length==0) return -1; int m = matrix.length, n = matrix[0].length; // use [val,i,j] to save cell PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o1[0]-o2[0]); // init heap with first row, space O(c) for(int j=0; j&lt;n; ++j) heap.offer(new int[]&#123;matrix[0][j],0,j&#125;); // push cell below int[] curr = null; while(k &gt; 0 &amp;&amp; !heap.isEmpty())&#123; curr = heap.poll(); k--; int val = curr[0], i = curr[1], j = curr[2]; if(i + 1 &lt; m) heap.offer(new int[]&#123;matrix[i+1][j],i+1,j&#125;); &#125; return curr[0];&#125; if k th distinct: 1234567891011121314151617181920212223public int kthSmallest(int[][] matrix, int k) &#123; // similar to #373 if(matrix==null || matrix.length==0 || matrix[0].length==0) return -1; int m = matrix.length, n = matrix[0].length; // use [val,i,j] to save cell PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o1[0]-o2[0]); // init heap with first row, space O(c) for(int j=0; j&lt;n; ++j) heap.offer(new int[]&#123;matrix[0][j],0,j&#125;); // push cell below int[] curr = null, prev = null; while(k &gt; 0 &amp;&amp; !heap.isEmpty())&#123; curr = heap.poll(); if(prev==null || prev!=null &amp;&amp; curr[0]!=prev[0]) k--; prev = curr; int val = curr[0], i = curr[1], j = curr[2]; if(i + 1 &lt; m) heap.offer(new int[]&#123;matrix[i+1][j],i+1,j&#125;); &#125; return curr[0];&#125; Binary Search: 123456789101112131415161718192021public int kthSmallest(int[][] matrix, int k) &#123; if(matrix==null || matrix.length==0 || matrix[0].length==0) return 0; int row = matrix.length, col = matrix[0].length; int low = matrix[0][0], high = matrix[row-1][col-1]; while(low &lt; high)&#123; int mid = low + (high - low)/2; int count = 0; // count smallest num for(int i=0;i&lt;row;i++)&#123; int j = col - 1; while(j&gt;=0 &amp;&amp; matrix[i][j] &gt; mid) j --; count += j + 1; // count &lt;= mid &#125; if(count &lt; k) // mid too small low = mid + 1; else high = mid; &#125; return low;&#125; #384-shuffle-an-array-mediumShuffle a set of numbers without duplicates. Example: 123456789101112// Init an array with set 1, 2, and 3.int[] nums = &#123;1,2,3&#125;;Solution solution = new Solution(nums);// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.solution.shuffle();// Resets the array back to its original configuration [1,2,3].solution.reset();// Returns the random shuffling of array [1,2,3].solution.shuffle(); 12345678910111213141516171819202122232425262728293031323334class Solution &#123; int[] nums = null; Random random; public Solution(int[] nums) &#123; this.nums = nums; random = new Random(); &#125; /** Resets the array to its original configuration and return it. */ public int[] reset() &#123; return nums; &#125; /** Returns a random shuffling of the array. */ public int[] shuffle() &#123; int[] copy = nums.clone(); // i is at i P = 1/i+1 // i is not at i P = 1-1/i+1 = i/i+1 // i at the other i P = 1/ i; // i at each location 0 to i is 1/i+1 for(int i=1;i&lt;copy.length;i++)&#123; // nextInt(a) a is exclusive int j = random.nextInt(i+1); swap(copy,i,j); &#125; return copy; &#125; private void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; #388-longest-absolute-file-path-mediumSuppose we abstract our file system by a string in the following manner: The string &quot;dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext&quot; represents: 1234dir subdir1 subdir2 file.ext The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string &quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext&quot; represents: 1234567dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.ext The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is &quot;dir/subdir2/subsubdir2/file2.ext&quot;, and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Note: The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a .. Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. 123456789101112131415161718192021222324252627public int lengthLongestPath(String input) &#123; // use stack, // for a level, stack saves only higher level len // if same level exit then pop if(input == null) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(0); // dummy bottom int maxLen = 0; // every \\n =&gt; a folder or a file for(String s : input.split(\"\\n\"))&#123; // define the level // first level -1+1=0, \\t=&gt;1, \\t\\t=&gt;2 int level = s.lastIndexOf(\"\\t\") + 1; // check whether stack has only higher level // l0=&gt;size 1,l1=&gt;size 2,l2=&gt;size 3 while(stack.size() &gt; level+1) // find parent stack.pop(); // push curr level len to stack, remove \\t, add / int len = stack.peek() + s.length() - level + 1; stack.push(len); // if it's a file, compute maxlen if(s.contains(\".\")) maxLen = Math.max(maxLen,len - 1); // remove / &#125; return maxLen;&#125; #406-queue-reconstruction-by-height-mediumSuppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note:The number of people is less than 1,100. Example 12345Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 123456789101112131415161718public int[][] reconstructQueue(int[][] people) &#123; // height decrease, count increase, insert if(people==null || people.length==0 || people[0].length==0) return people; Arrays.sort(people,new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] a,int[] b)&#123; if(a[0] != b[0]) // decrease return b[0] - a[0]; else // increase return a[1] - b[1]; &#125; &#125;); List&lt;int[]&gt; result = new LinkedList&lt;&gt;(); for(int[] p : people) result.add(p[1],p); return result.toArray(new int[people.length][2]);&#125; 419. Battleships in a Board (medium)Given an 2D board, count how many battleships are in it. The battleships are represented with &#39;X&#39;s, empty slots are represented with &#39;.&#39;s. You may assume the following rules: You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships. Example: 123X..X...X...X In the above board there are 2 battleships. Invalid Example: 123...XXXXX...X This is an invalid board that you will not receive - as battleships will always have a cell separating between them. 12345678910111213141516171819public int countBattleships(char[][] board) &#123; // idea only find ship head, left top cell if(board==null || board.length==0 || board[0].length==0) return 0; final int m = board.length, n = board[0].length; int count = 0; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(board[i][j] == '.') continue; if(i&gt;0 &amp;&amp; board[i-1][j] == 'X') continue; if(j&gt;0 &amp;&amp; board[i][j-1] == 'X') continue; count ++; &#125; &#125; return count;&#125; #443-string-compression-easyGiven an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array. Follow up:Could you solve it using only O(1) extra space? Example: 123456789Input:[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]Output:Return 4, and the first 4 characters of the input array should be: [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;].Explanation:Since the character &quot;a&quot; does not repeat, it is not compressed. &quot;bbbbbbbbbbbb&quot; is replaced by &quot;b12&quot;.Notice each digit has it&apos;s own entry in the array. Note: All characters have an ASCII value in [35, 126]. 1 &lt;= len(chars) &lt;= 1000. 12345678910111213141516171819202122public int compress(char[] chars) &#123; if(chars==null || chars.length==0) return 0; // start for result tail, end for curr int start = 0, end = 0; while(end &lt; chars.length)&#123; char curr = chars[end]; int count = 1; // count same char while(end&lt;chars.length-1 &amp;&amp; chars[end]==chars[end+1])&#123; count ++; end ++; &#125; // put curr char down chars[start++] = chars[end++]; // then add count if(count != 1) for(char c : String.valueOf(count).toCharArray()) chars[start++] = c; &#125; return start;&#125; #448-find-all-disappeared-number-easyGiven an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: 12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] 12345678910111213141516public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); // 2 passes // 1 pass to set negative for(int num : nums)&#123; int index = Math.abs(num) - 1; if(nums[index] &gt; 0) nums[index] *= -1; &#125; // second pass find positive index for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i] &gt; 0) result.add(i+1); &#125; return result;&#125; #463-island-perimeter-easyExample: 1234567[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: 123456789101112131415161718192021public int islandPerimeter(int[][] grid) &#123; if(grid==null || grid.length==0 || grid[0].length==0) return 0; final int row = grid.length; final int col = grid[0].length; int count = 0; for(int i=0; i&lt;row; i++)&#123; for(int j=0; j&lt;col; j++)&#123; if(grid[i][j] == 0) continue; // check up and left, if nei is 1, remove edge count += 4; // default 4 added first // -2 : two block double edge remove if(i &gt; 0 &amp;&amp; grid[i-1][j] == 1) count -= 2; if(j &gt; 0 &amp;&amp; grid[i][j-1] == 1) count -= 2; &#125; &#125; return count;&#125; #476-number-complement-easyGiven a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. Example 1: 123Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2: 123Input: 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. 1234567public int findComplement(int num) &#123; // use 11111 - num int n = 1; while(n &lt; num) n = n &lt;&lt; 1 | 1; return n - num;&#125; #500-keyboard-row-easyGiven a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. Example 1: 12Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] Note: You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet. 123456789101112131415161718192021222324public String[] findWords(String[] words) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(words==null || words.length==0) return result.toArray(new String[0]); // build map String[] rows = &#123;\"QWERTYUIOP\",\"ASDFGHJKL\",\"ZXCVBNM\"&#125;; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;rows.length;i++) for(char c : rows[i].toCharArray()) map.put(c,i); // add to result WORDS: for(String word : words)&#123; if(word.equals(\"\")) continue; int idx = map.get(Character.toUpperCase(word.charAt(0))); for(int i=1;i&lt;word.length();i++)&#123; if(map.get(Character.toUpperCase(word.charAt(i))) != idx) continue WORDS; &#125; result.add(word); &#125; return result.toArray(new String[result.size()]);&#125; 123456789101112public String[] findWords(String[] words) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(words==null || words.length==0) return result.toArray(new String[0]); String regex = \"[QWERTYUIOP]*|[ASDFGHJKL]*|[ZXCVBNM]*\"; for(String word : words)&#123; if(word.toUpperCase().matches(regex))&#123; result.add(word); &#125; &#125; return result.toArray(new String[result.size()]);&#125; #496-next-greater-element-i-easyYou are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1‘s elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number. Example 1: 123456Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. 1. brute force 2. stack 123456789101112131415161718public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; // if decreasing, keep pushing stack] // if increase, find result, pop and put Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int num : nums2)&#123; while(!stack.isEmpty() &amp;&amp; num &gt; stack.peek())&#123; map.put(stack.pop(),num); &#125; stack.push(num); &#125; while(!stack.isEmpty()) map.put(stack.pop(),-1); int[] result = new int[nums1.length]; for(int i=0; i&lt;result.length; ++i) result[i] = map.get(nums1[i]); return result;&#125; #503-next-greater-element-ii-medium]Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number. Example 1: 12345Input: [1,2,1]Output: [2,-1,2]Explanation: The first 1&apos;s next greater number is 2; The number 2 can&apos;t find next greater number; The second 1&apos;s next greater number needs to search circularly, which is also 2. iterate twice for circular arrays 123456789101112public int[] nextGreaterElements(int[] nums) &#123; int n = nums.length; int[] result = new int[n]; Arrays.fill(result,-1); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();// index for(int i=0; i&lt;n*2; ++i)&#123; while(!stack.isEmpty() &amp;&amp; nums[i%n]&gt;nums[stack.peek()]) result[stack.pop()] = nums[i%n]; stack.push(i % n); &#125; return result;&#125; #516-longest-palindromic-subsequence-mediumGiven a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000. Example 1:Input: 1&quot;bbbab&quot; Output: 14 One possible longest palindromic subsequence is “bbbb”. 12345678910111213141516public int longestPalindromeSubseq(String s) &#123; int[][] dp = new int[s.length()][s.length()]; // row need to bottom up, to make i+1 available for(int i=s.length()-1; i&gt;=0; i--)&#123; dp[i][i] = 1; for(int j=i+1; j&lt;s.length(); j++)&#123; // head + tail + len(head to tail) // 2 + dp[i+1][j-1] if(s.charAt(i) == s.charAt(j)) dp[i][j] = 2 + dp[i+1][j-1]; else // [i-1][j] or [i][j-1] dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]); &#125; &#125; return dp[0][s.length()-1];&#125; #556-next-greater-element-iii-mediumGiven a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer nand is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. #31-next-permutation-medium Example 1: 12Input: 12Output: 21 12345678910111213141516171819202122232425262728293031323334public int nextGreaterElement(int n) &#123; //123987421, similar to #31-next-permutation-medium char[] num = String.valueOf(n).toCharArray(); int idx1 = num.length - 2; while(idx1 &gt;=0 &amp;&amp; num[idx1] &gt;= num[idx1+1]) idx1 --; if(idx1 &lt; 0) return -1; int idx2 = num.length - 1; while(num[idx2] &lt;= num[idx1]) idx2 --; swap(num,idx1,idx2); reverse(num,idx1+1,num.length-1); String s = new String(num); // handle overflow String threshold = String.valueOf(Integer.MAX_VALUE); // string compare consider length first if(s.length() &gt;= threshold.length() &amp;&amp; s.compareTo(threshold) &gt; 0) return -1; return Integer.parseInt(s); &#125;private void swap(char[] num,int i,int j)&#123; char temp = num[i]; num[i] = num[j]; num[j] = temp;&#125;private void reverse(char[] num,int i,int j)&#123; while(i &lt; j)&#123; swap(num,i,j); i++; j--; &#125;&#125; #560-subarray-sum-equals-k-mediumGiven an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: 12Input:nums = [1,1,1], k = 2Output: 2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. 1234567891011121314public int subarraySum(int[] nums, int k) &#123; if(nums==null || nums.length==0) return 0; // use map to save curr sum &amp; count Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); // int count = 0, sum = 0; for(int num : nums)&#123; sum += num; count += map.getOrDefault(sum-k,0); map.put(sum,map.getOrDefault(sum,0)+1); &#125; return count;&#125; #604-compressed-string-iterator-easyDesign and implement a data structure for a compressed string iterator. It should support the following operations: next and hasNext. The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string. next() - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.hasNext() - Judge whether there is any letter needs to be uncompressed. Note:Please remember to RESET your class variables declared in StringIterator, as static/class variables are persisted across multiple test cases. Please see here for more details. Example: 12345678910111213StringIterator iterator = new StringIterator(&quot;L1e2t1C1o1d1e1&quot;);iterator.next(); // return &apos;L&apos;iterator.next(); // return &apos;e&apos;iterator.next(); // return &apos;e&apos;iterator.next(); // return &apos;t&apos;iterator.next(); // return &apos;C&apos;iterator.next(); // return &apos;o&apos;iterator.next(); // return &apos;d&apos;iterator.hasNext(); // return trueiterator.next(); // return &apos;e&apos;iterator.hasNext(); // return falseiterator.next(); // return &apos; &apos; 123456789101112131415161718192021222324252627282930313233343536class StringIterator &#123; // use int[2] save char, count // use queue Queue&lt;int[]&gt; queue; public StringIterator(String compressedString) &#123; queue = new LinkedList&lt;&gt;(); int len = compressedString.length(); for(int i=0; i&lt;len;)&#123; int[] pair = new int[2]; pair[0] = compressedString.charAt(i); int j = i + 1; // num is before letters String cnt = \"\"; while(j&lt;len &amp;&amp; compressedString.charAt(j)&lt;'A')&#123; cnt += compressedString.charAt(j); j ++; &#125; pair[1] = Integer.parseInt(cnt); queue.offer(pair); i = j; &#125; &#125; public char next() &#123; if(queue.isEmpty()) return ' '; int[] pair = queue.peek(); if(--pair[1] == 0) queue.poll(); return (char) pair[0]; &#125; public boolean hasNext() &#123; return !queue.isEmpty(); &#125;&#125; #625-minimun-factorization-mediumGiven a positive integer a, find the smallest positive integer b whose multiplication of each digit equals to a. If there is no answer or the answer is not fit in 32-bit signed integer, then return 0. Example 1Input: 148 Output: 168 123456789101112131415161718public int smallestFactorization(int a) &#123; if(a &lt; 9) return a; // try larger first long result = 0, multi = 1; for(int i=9; i&gt;=2; i--)&#123; while(a % i == 0)&#123; a /= i; result += multi * i; if(result &gt; Integer.MAX_VALUE) return 0; multi *= 10; &#125; &#125; if(a != 1) return 0; return (int) result;&#125; #632-smallest-range-hardYou have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the klists. We define the range [a,b] is smaller than range [c,d] if b-a &lt; d-c or a &lt; c if b-a == d-c. Example 1: 123456Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]Output: [20,24]Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24].List 2: [0, 9, 12, 20], 20 is in range [20,24].List 3: [5, 18, 22, 30], 22 is in range [20,24]. 1234567891011121314151617181920212223242526272829303132333435363738public int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123; // use heap similar to merge k sorted list // maintain a max, when poll a min, update result, offer its next if(nums == null || nums.size() == 0) return new int[0]; // use int[3] save: &#123;row,idx,val&#125; PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1,int[] o2)&#123; return o1[2] - o2[2]; &#125; &#125;); int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE; int minRange = Integer.MAX_VALUE; int[] result = new int[2]; // init max and heap use first col for(int row=0; row&lt;nums.size(); row++)&#123; int value = nums.get(row).get(0); max = Math.max(max,value); heap.offer(new int[]&#123;row,0,value&#125;); &#125; // start, condition: heap size while(heap.size() == nums.size())&#123; int[] curr = heap.poll(); // update result if(max - curr[2] &lt; minRange)&#123; minRange = max - curr[2]; result = new int[]&#123;curr[2],max&#125;; &#125; // offer min's next, update max if(curr[1] + 1 &lt; nums.get(curr[0]).size())&#123; int next = nums.get(curr[0]).get(curr[1]+1); max = Math.max(max,next); heap.offer(new int[]&#123;curr[0],curr[1]+1,next&#125;); &#125; &#125; return result;&#125; #809-expressive-word-mediumSometimes people repeat letters to represent extra feeling, such as “hello” -&gt; “heeellooo”, “hi” -&gt; “hiiii”. Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different. A group is extended if that group is length 3 or more, so “e” and “o” would be extended in the first example, and “i” would be extended in the second example. As another example, the groups of “abbcccaaaa” would be “a”, “bb”, “ccc”, and “aaaa”; and “ccc” and “aaaa” are the extended groups of that string. For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups. Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more. Note that we cannot extend a group of size one like “h” to a group of size two like “hh” - all extensions must leave the group extended - ie., at least 3 characters long. Given a list of query words, return the number of words that are stretchy. 12345678Example:Input: S = &quot;heeellooo&quot;words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]Output: 1Explanation: We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.We can&apos;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not extended. 123456789101112131415161718192021222324252627public int expressiveWords(String S, String[] words) &#123; if(S==null || S.length()==0 || words==null || words.length==0) return 0; int count = 0; for(String word : words)&#123; // i for S &lt;= j for word int i = 0, j = 0; while(i &lt; S.length())&#123; // S.char == word.char, keep going if(j&lt;word.length() &amp;&amp; S.charAt(i)==word.charAt(j))&#123; i++; j++; // check S.char is extend? &#125;else if(i&gt;0 &amp;&amp; S.charAt(i)==S.charAt(i-1) &amp;&amp; i&lt;S.length()-1 &amp;&amp; S.charAt(i)==S.charAt(i+1))&#123; i += 2; // check S when j reach word tail &#125;else if(i&gt;1 &amp;&amp; S.charAt(i)==S.charAt(i-1) &amp;&amp; S.charAt(i)==S.charAt(i-2))&#123; i++; &#125;else break; if(i==S.length() &amp;&amp; j==word.length()) count++; &#125; &#125; return count;&#125; #814-binary-tree-pruning-mediumWe are given the head node root of a binary tree, where additionally every node’s value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) 1234567891011public TreeNode pruneTree(TreeNode root) &#123; // can use no helper if(root == null) return root; root.left = pruneTree(root.left); root.right = pruneTree(root.right); // post order if(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==0) return null; return root;&#125; #817-linked-list-components-mediumWe are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1: 123456Input: head: 0-&gt;1-&gt;2-&gt;3G = [0, 1, 3]Output: 2Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components. Example 2: 123456Input: head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4]Output: 2Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. Note: If N is the length of the linked list given by head, 1 &lt;= N &lt;= 10000. The value of each node in the linked list will be in the range[0, N - 1]. 1 &lt;= G.length &lt;= 10000. G is a subset of all values in the linked list. 1234567891011121314151617public int numComponents(ListNode head, int[] G) &#123; // use set, count tail of components Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num : G) set.add(num); int count = 0; while(head != null)&#123; // if contains curr: // 1. this is end // 2. not contain next (tail) if(set.contains(head.val) &amp;&amp; (head.next==null || !set.contains(head.next.val))) count ++; head = head.next; &#125; return count;&#125; #855-exam-room-mediumIn an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. (Also, if no one is in the room, then the student sits at seat number 0.) Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room. It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p. Example 1: 12345678910Input: [&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]Output: [null,0,9,4,2,null,5]Explanation:ExamRoom(10) -&gt; nullseat() -&gt; 0, no one is in the room, then the student sits at seat number 0.seat() -&gt; 9, the student sits at the last seat number 9.seat() -&gt; 4, the student sits at the last seat number 4.seat() -&gt; 2, the student sits at the last seat number 2.leave(4) -&gt; nullseat() -&gt; 5, the student sits at the last seat number 5. 1234567891011121314151617181920212223242526272829303132333435363738class ExamRoom &#123; int N; TreeSet&lt;Integer&gt; set; // use TreeSet to maintain increasing idx // idx = left + maxDist / 2; public ExamRoom(int N) &#123; this.N = N; this.set = new TreeSet&lt;&gt;(); &#125; public int seat() &#123; int idx = 0; // this way handles seat at 0 if(set.size() &gt; 0)&#123; int maxDist = set.first(); // deal with first interval int prev = -1; for(int student : set)&#123; // iteration in order if(prev != -1)&#123; int dist = (student - prev) / 2; if(dist &gt; maxDist)&#123; maxDist = dist; idx = prev + maxDist; &#125; &#125; prev = student; &#125; // deal with last interval if(N - 1 - set.last() &gt; maxDist) idx = N - 1; &#125; set.add(idx); return idx; &#125; public void leave(int p) &#123; set.remove(p); &#125;&#125; #856-score-of-parentheses-mediumGiven a balanced parentheses string S, compute the score of the string based on the following rule: () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string. Example 4: 12Input: &quot;(()(()))&quot;Output: 6 12345678910111213141516171819202122232425public int scoreOfParentheses(String S) &#123; // assume S is balanced if(S==null || S.length()==0) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(char c : S.toCharArray())&#123; if(c == '(') // use 0 mark ( stack.push(0); else&#123; int temp = 0; // sum in same level while(stack.peek()!=0) temp += stack.pop(); stack.pop(); // pop the 0 // if temp is 0, push 1, else push 2*temp stack.push(Math.max(2*temp,1)); &#125; &#125; // 0 level sum int result = 0; while(!stack.isEmpty()) result += stack.pop(); return result;&#125; space O(1): maintain level 1234567891011public int scoreOfParentheses(String S) &#123; int level = 0, result = 0; for(int i=0; i&lt;S.length(); ++i)&#123; // maintain level level += S.charAt(i)=='(' ? 1:-1; // add when find (), only () could add to result if(S.charAt(i) == '(' &amp;&amp; S.charAt(i+1) == ')') result += 1 &lt;&lt; (level-1); &#125; return result;&#125; #862-shortest-subarray-with-sum-at-least-k-hardReturn the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1. Example 1: 12Input: A = [1], K = 1Output: 1 Example 2: 12Input: A = [1,2], K = 4Output: -1 Example 3: 12Input: A = [2,-1,2], K = 3Output: 3 12345678910111213141516171819202122public int shortestSubarray(int[] A, int K) &#123; if(A == null || A.length == 0) return -1; int[] sums = new int[A.length + 1]; // accumulated array for(int i=0; i&lt;A.length; ++i) sums[i+1] = sums[i] + A[i]; int minLen = A.length + 1; Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); for(int i=0; i&lt;sums.length; ++i)&#123; // sliding window, if only increasing then this case while(!deque.isEmpty() &amp;&amp; sums[i] - sums[deque.peekFirst()] &gt;= K) minLen = Math.min(minLen,i - deque.pollFirst()); // if i+1 negative value in A, sums will decrease at i // keep the deque increasing // smaller sum with larger idx could be result instead of large sum with small idx while(!deque.isEmpty() &amp;&amp; sums[i] &lt;= sums[deque.peekLast()]) deque.pollLast(); deque.offerLast(i); &#125; return minLen &gt; A.length ? -1 : minLen;&#125; #863-all-nodes-distance-k-in-binary-tree-mediumWe are given a binary tree (with root node root), a target node, and an integer value K. Return a list of the values of all nodes that have a distance K from the target node. The answer can be returned in any order. Example 1: 12345678Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2Output: [7,4,1]Explanation: The nodes that are a distance 2 from the target node (with value 5)have values 7, 4, and 1.Note that the inputs &quot;root&quot; and &quot;target&quot; are actually TreeNodes.The descriptions of the inputs above are just serializations of these objects. Note: The given tree is non-empty. Each node in the tree has unique values 0 &lt;= node.val &lt;= 500. The target node is a node in the tree. 0 &lt;= K &lt;= 1000. geeks for geeks reference Undirected graph bfs: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; // use BFS, treat as undirected graph // nei of a node: left, right, parent List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(root == null || target == null) return result; // build parentMap Map&lt;TreeNode,TreeNode&gt; parentMap = new HashMap&lt;&gt;(); findParent(root,null,parentMap); // init bfs Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); queue.offer(target); int dist = 0; while(!queue.isEmpty())&#123; if(dist == K)&#123; while(!queue.isEmpty()) result.add(queue.poll().val); return result; &#125; // level order int size = queue.size(); for(int i=0; i&lt;size; ++i)&#123; TreeNode curr = queue.poll(); visited.add(curr); // add left, right, parent if(curr.left != null &amp;&amp; !visited.contains(curr.left)) queue.offer(curr.left); if(curr.right != null &amp;&amp; !visited.contains(curr.right)) queue.offer(curr.right); TreeNode parent = parentMap.get(curr); if(parent != null &amp;&amp; !visited.contains(parent)) queue.offer(parent); &#125; dist ++; &#125; return result;&#125;private void findParent(TreeNode root,TreeNode parent,Map&lt;TreeNode,TreeNode&gt; parentMap)&#123; if(root == null) return; // child -&gt; parent if(parent != null) parentMap.put(root,parent); findParent(root.left,root,parentMap); findParent(root.right,root,parentMap);&#125; DFS consider subtree and ancestor: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; // dfs 2 cases: // first: subtree of target node // second: ancestor or other subtree List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); getDist(root,target,K,result); return result;&#125;// for first case, no target found return -1, // return 0 when find target, then backtrack increase dist// backward get K, or search in the other subtree private int getDist(TreeNode root,TreeNode target,int K,List&lt;Integer&gt; result)&#123; if(root == null) return -1; if(root == target)&#123; // search subtree then search second case findSubTree(root,K,result); return 0; &#125; int leftDist = getDist(root.left,target,K,result); // target in left subtree if(leftDist != -1)&#123; if(leftDist + 1 == K) result.add(root.val); else // search right subtree findSubTree(root.right,K-2-leftDist,result); return 1 + leftDist; &#125; int rightDist = getDist(root.right,target,K,result); if(rightDist != -1)&#123; if(rightDist + 1 == K) result.add(root.val); else findSubTree(root.left,K-2-rightDist,result); return 1 + rightDist; &#125; return -1;&#125;// for case search in target subtreeprivate void findSubTree(TreeNode root,int K,List&lt;Integer&gt; result)&#123; if(root == null) return; if(K == 0)&#123; result.add(root.val); return; &#125; findSubTree(root.left,K-1,result); findSubTree(root.right,K-1,result);&#125; #864-random-pick-with-blacklist-hardGiven a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B. Optimize it such that it minimizes the call to system’s Math.random(). Note: 1 &lt;= N &lt;= 1000000000 0 &lt;= B.length &lt; min(100000, N) [0, N) does NOT include N. See interval notation). 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; Map&lt;Integer,Integer&gt; map; Set&lt;Integer&gt; blackSet; Random random; int range; public Solution(int N, int[] blacklist) &#123; // B black num, N total, N-B valid // map black num [0,N-B] to valid num [N-B,N] // [0,N-B)[N-B,N) this.blackSet = new HashSet&lt;&gt;(); this.map = new HashMap&lt;&gt;(); this.random = new Random(); int B = blacklist.length; // save black num after N-B for(int num : blacklist)&#123; if(num &gt;= N-B) blackSet.add(num); &#125; int val = N - B; // map black num before N-B for(int num : blacklist)&#123; if(num &lt; N - B)&#123; while(blackSet.contains(val)) val ++; map.put(num,val++);// notice ++ &#125; &#125; this.range = N - B; &#125; public int pick() &#123; int key = this.random.nextInt(range); // if contains in black map, return val // otherwise valid, return directly return map.getOrDefault(key,key); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jliao011.github.io/categories/leetcode/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-05-27T07:11:14.000Z","updated":"2018-05-27T12:41:27.000Z","comments":true,"path":"2018/05/27/hello-world/","link":"","permalink":"https://jliao011.github.io/2018/05/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}